---
title: Жизненный цикл действия
description: Действия — это фундаментальный Стандартный блок приложений Android, который может существовать в нескольких разных состояниях. Жизненный цикл действия начинается с создания экземпляра и заканчивается на уничтожение и включает много состояний между. Когда действие изменяет состояние, вызывается соответствующий метод события жизненного цикла, уведомляющий о действии ожидающего изменения состояния и позволяя ему выполнить код для адаптации к этому изменению. В этой статье изучается жизненный цикл действий и объясняется ответственность за то, что действие в ходе каждого из этих изменений состояния является частью хорошо организованного надежного приложения.
ms.prod: xamarin
ms.assetid: 05B34788-F2D2-4347-B66B-40AFD7B1D167
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 02/28/2018
ms.openlocfilehash: 6e69d21bb734f13d220c042535842538306d16c8
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73016997"
---
# <a name="activity-lifecycle"></a>Жизненный цикл действия

_Действия — это фундаментальный Стандартный блок приложений Android, который может существовать в нескольких разных состояниях. Жизненный цикл действия начинается с создания экземпляра и заканчивается на уничтожение и включает много состояний между. Когда действие изменяет состояние, вызывается соответствующий метод события жизненного цикла, уведомляющий о действии ожидающего изменения состояния и позволяя ему выполнить код для адаптации к этому изменению. В этой статье изучается жизненный цикл действий и объясняется ответственность за то, что действие в ходе каждого из этих изменений состояния является частью хорошо организованного надежного приложения._

## <a name="activity-lifecycle-overview"></a>Общие сведения о жизненном цикле действия

Действия — это необычная концепция программирования, относящаяся к Android. В традиционной разработке приложений обычно используется статический метод Main, который выполняется для запуска приложения. Тем не менее, в Android используются разные элементы. Приложения Android можно запускать с помощью любого зарегистрированного действия в приложении. На практике большинство приложений будут иметь только определенное действие, указанное в качестве точки входа приложения. Однако если приложение аварийно завершает работу или завершается операционной системой, операционная система может попытаться перезапустить приложение на последнем открытом действии или в любом другом месте предыдущего стека действий.
Кроме того, операционная система может приостановить действия, когда они неактивны, и высвободить их в случае нехватки памяти. Следует тщательно учитывать необходимость в том, чтобы приложение было правильно восстанавливать свое состояние в случае перезапуска действия, особенно если это действие зависит от данных из предыдущих действий.

Жизненный цикл действия реализуется как коллекция методов, которые вызывает операционная система в течение всего жизненного цикла действия. Эти методы позволяют разработчикам реализовать функциональные возможности, необходимые для удовлетворения требований к состоянию и управлению ресурсами своих приложений.

Разработчику приложения очень важно анализировать требования каждого действия, чтобы определить, какие методы, предоставляемые жизненным циклом действия, должны быть реализованы. Невыполнение этого действия может привести к нестабильной работе приложения, сбоям, чрезмерному повышению ресурсов и, возможно, даже к базовой нестабильной работе ОС.

В этой главе подробно рассматривается жизненный цикл действия, включая:

- Состояния действий
- Методы жизненного цикла
- Сохранение состояния приложения

В этом разделе также содержится [Пошаговое руководство](~/android/app-fundamentals/activity-lifecycle/saving-state.md) , в котором содержатся практические примеры эффективного сохранения состояния во время жизненного цикла действия. В конце этой главы вы получите представление о жизненном цикле действий и о том, как его поддерживать в приложении Android.

## <a name="activity-lifecycle"></a>Жизненный цикл действия

Жизненный цикл действия Android состоит из коллекции методов, предоставляемых в классе действия, которые предоставляют разработчику инфраструктуру управления ресурсами. Эта платформа позволяет разработчикам удовлетворить уникальные требования к управлению состоянием каждого действия в приложении и надлежащим образом обрабатывает управление ресурсами.

### <a name="activity-states"></a>Состояния действий

Действия единолично операционной системы Android в зависимости от их состояния. Это помогает Android выявление действий, которые больше не используются, что позволяет операционной системе высвободить память и ресурсы. На следующей схеме показаны состояния, через которые действие может пройти в течение своего времени существования:

[Схема состояний действий![](images/image1-sml.png)](images/image1.png#lightbox)

Эти состояния можно разбить на четыре основные группы следующим образом:

1. *Активные или выполняющиеся* действия &ndash; считаются активными или выполняются, если они находятся на переднем плане, также называемой верхней частью стека действий. Это действие считается самым высоким приоритетом в Android, поэтому операционная система будет уничтожена только операционной системой в экстремальных ситуациях, например если действие пытается использовать больше памяти, чем доступно на устройстве, так как это может привести к тому, что пользовательский интерфейс перестанет отвечать на запросы.

1. *Приостановленные* &ndash; когда устройство переходит в спящий режим или действие остается видимым, но частично скрыто новым, неполным или прозрачным действием, действие считается приостановленным. Приостановленные действия по-прежнему действуют, то есть сохраняют все сведения о состоянии и члене и остаются присоединенными к диспетчеру окон. Это считается вторым действием с наивысшим приоритетом в Android и, таким образом, будет уничтожено только операционной системой, если завершение этого действия будет удовлетворять требованиям к ресурсам, необходимым для обеспечения стабильного и быстрого реагирования активного и работающего действия.

1. *Остановленные и фоновые* действия &ndash;, которые полностью скрыты другим действием, считаются остановленными или в фоновом режиме.
    Остановленные действия по-прежнему пытаются сохранить сведения о состоянии и члене в течение как можно больше, но остановленные действия считаются наименьшим приоритетом трех состояний и, по существу, операционная система будет сначала прерывать действия в этом состоянии для удовлетворения ресурса. требования к действиям с более высоким приоритетом.

1. *Перезагрузка* &ndash; возможно, что в течение жизненного цикла действие, которое находится в состоянии "приостановлено", будет остановлено из памяти Android. Если пользователь вернется к действию, его необходимо перезапустить, восстановить в ранее сохраненное состояние, а затем показать пользователю.

### <a name="activity-re-creation-in-response-to-configuration-changes"></a>Повторное создание действия в ответ на изменения конфигурации

Чтобы сделать их более сложными, Android создает еще один гаечного ключа в сочетании, именуемом изменениями конфигурации. Изменения конфигурации — это циклы быстрого удаления и повторного создания действий, происходящие при изменении конфигурации действия, например при смене [устройства (и](~/android/app-fundamentals/handling-rotation.md) необходимости повторного построения действия в альбомной или портретной ориентации), когда Отобразится клавиатура (и для действия предоставляется возможность изменить размер) или когда устройство помещается в закрепление, а не в другие.

Изменения конфигурации по-прежнему вызывают те же изменения состояния действий, которые произошли бы во время остановки и перезапуска действия. Однако, чтобы убедиться, что приложение реагирует на запросы и хорошо работает во время изменений конфигурации, важно, чтобы они обрабатывались как можно быстрее. По этой причине в Android имеется специальный API, который можно использовать для сохранения состояния во время изменений конфигурации.
Это будет рассмотрено далее в [состоянии управления в течение всего жизненного цикла](~/android/app-fundamentals/activity-lifecycle/index.md#Managing_State_Throughout_the_Lifecycle) .

### <a name="activity-lifecycle-methods"></a>Методы жизненного цикла действия

Пакет SDK для Android и, по расширению, платформа Xamarin. Android предоставляет мощную модель для управления состоянием действий в приложении. Когда состояние действия изменяется, действие получает уведомления операционной системы, которое вызывает определенные методы для этого действия. На следующей схеме показаны эти методы в зависимости от жизненного цикла действия.

[Блок-схема жизненного цикла действий![](images/image2-sml.png)](images/image2.png#lightbox)

Разработчик может управлять изменениями состояния, переопределяя эти методы в рамках действия. Однако важно отметить, что все методы жизненного цикла вызываются в потоке пользовательского интерфейса и блокируют выполнение следующей части работы пользовательского интерфейса, например скрытие текущего действия, отображение нового действия и т. д. Таким образом, код в этих методах должен быть как можно более кратким, чтобы приложение было хорошо работать. Все длительно выполняемые задачи должны выполняться в фоновом потоке.

Давайте рассмотрим каждый из этих методов жизненного цикла и их использование:

#### <a name="oncreate"></a>OnCreate

[OnCreate](xref:Android.App.Activity.OnCreate*) — это первый метод, который вызывается при создании действия.
`OnCreate` всегда переопределяется для выполнения инициализации запуска, которая может потребоваться для действия, например:

- Создание представлений
- Инициализация переменных
- Привязка статических данных к спискам

`OnCreate` принимает параметр [пакета](xref:Android.OS.Bundle) , который является словарем для хранения и передачи сведений о состоянии и объектов между действиями, если пакет не равен null, это указывает на то, что действие перезапускается и должно восстановить его состояние из предыдущего вхождение. В следующем коде показано, как извлечь значения из пакета:

```csharp
protected override void OnCreate(Bundle bundle)
{
   base.OnCreate(bundle);

   string intentString;
   bool intentBool;

   if (bundle != null)
   {
      intentString = bundle.GetString("myString");
      intentBool = bundle.GetBoolean("myBool");
   }

   // Set our view from the "main" layout resource
   SetContentView(Resource.Layout.Main);
}
```

По завершении `OnCreate` будет вызвана `OnStart`.

#### <a name="onstart"></a>OnStart

[OnStart](xref:Android.App.Activity.OnStart) всегда вызывается системой после завершения `OnCreate`. Действия могут переопределять этот метод, если им нужно выполнять определенные задачи до того, как действие станет видимым, например обновлять текущие значения представлений в рамках действия. Android выполнит вызов `OnResume` сразу после этого метода.

#### <a name="onresume"></a>Onresume

Система вызывает [Onresume](xref:Android.App.Activity.OnResume) , когда действие готово к началу взаимодействия с пользователем.
Действия должны переопределять этот метод для выполнения таких задач, как:

- Увеличение частоты кадров (типичная задача при разработке игр)
- Запуск анимации
- Прослушивание обновлений GPS
- Отображение всех соответствующих предупреждений или диалогов
- Подсоединить внешние обработчики событий

Например, в следующем фрагменте кода показано, как инициализировать камеру:

```csharp
public void OnResume()
{
    base.OnResume(); // Always call the superclass first.

    if (_camera==null)
    {
        // Do camera initializations here
    }
}
```

`OnResume` важен, так как любая операция, выполняемая в `OnPause`, должна быть отменена в `OnResume`, так как это единственный метод жизненного цикла, который гарантированно будет выполняться после `OnPause` при возврате действия в жизнь.

#### <a name="onpause"></a>Приостановка

[OnPause](xref:Android.App.Activity.OnPause) вызывается, когда система собирается перевести действие в фоновый режим или когда действие становится частично незаметной. Действия должны переопределять этот метод, если необходимо:

- Зафиксировать несохраненные изменения в постоянных данных

- Удаление или очистка других объектов, использующих ресурсы

- Снижение частоты кадров и приостановка анимации

- Отмените регистрацию обработчиков внешних событий или обработчиков уведомлений (т. е. тех, которые привязаны к службе). Это необходимо сделать для предотвращения утечек памяти действий.

- Аналогично, если действие отображает какие бы то ни было диалоговые окна или оповещения, оно должно быть очищено с помощью метода `.Dismiss()`.

Например, в следующем фрагменте кода будет освобождена камера, так как действие не может использовать его при приостановке:

```csharp
public void OnPause()
{
    base.OnPause(); // Always call the superclass first

    // Release the camera as other activities might need it
    if (_camera != null)
    {
        _camera.Release();
        _camera = null;
    }
}
```

Существует два возможных метода жизненного цикла, которые будут вызываться после `OnPause`:

1. `OnResume` будет вызываться, если действие должно возвращаться на передний план.
1. `OnStop` будет вызываться, если действие помещается в фоновом режиме.

#### <a name="onstop"></a>OnStop

[OnStop](xref:Android.App.Activity.OnStop) вызывается, когда действие больше не видимо для пользователя. Это происходит, когда происходит одно из следующих событий:

- Запускается новое действие, которое охватывает это действие.
- Существующее действие переносится на передний план.
- Действие уничтожается.

`OnStop` не всегда могут вызываться в ситуациях нехватки памяти, например, когда Android недоступен для ресурсов и не может правильно запланировать действие. По этой причине лучше не полагаться на вызов `OnStop` при подготовке действия к уничтожению. Следующие методы жизненного цикла, которые могут быть вызваны после этого, будут `OnDestroy`, если действие выходит из него, или `OnRestart`, если действие возвращается к взаимодействию с пользователем.

#### <a name="ondestroy"></a>OnDestroy

[OnDestroy](xref:Android.App.Activity.OnDestroy) — это окончательный метод, который вызывается для экземпляра действия до его уничтожения и полного удаления из памяти. В экстремальных ситуациях Android может прекратить процесс приложения, в котором размещается действие, что приведет к `OnDestroy` не будет вызываться. Большинство действий не реализуют этот метод, так как большинство операций очистки и завершения работы выполняются в методах `OnPause` и `OnStop`. Метод `OnDestroy` обычно переопределяется для очистки долго выполняющихся ресурсов, которые могут привести к утечке ресурсов. Например, это могут быть фоновые потоки, которые были запущены в `OnCreate`.

После уничтожения действия методы жизненного цикла не будут вызываться.

#### <a name="onrestart"></a>Restart

[Restart](xref:Android.App.Activity.OnRestart) вызывается после того, как действие было остановлено, прежде чем оно будет запущено снова. Хорошим примером этого может быть то, что пользователь нажмет кнопку «домой» при выполнении действия в приложении. Когда это происходит `OnPause` а затем вызываются `OnStop` методы, и действие перемещается в фон, но не уничтожается. Если пользователь восстановит приложение с помощью диспетчера задач или аналогичного приложения, Android вызовет метод `OnRestart` действия.

Не существует общих правил для того, какой тип логики следует реализовать в `OnRestart`. Это связано с тем, что `OnStart` всегда вызывается независимо от того, создается или перезапускается действие, поэтому все ресурсы, необходимые для действия, должны инициализироваться в `OnStart`, а не `OnRestart`.

Следующий метод жизненного цикла, вызываемый после `OnRestart`, будет `OnStart`.

### <a name="back-vs-home"></a>Обратная и домашняя

У многих устройств Android есть две отдельные кнопки: кнопка "назад" и кнопка "домой". Пример можно увидеть на следующем снимке экрана Android 4.0.3:

[![кнопки "назад" и "домой"](images/image4-sml.png)](images/image4.png#lightbox)

Существует небольшая разница между двумя кнопками, хотя они имеют одинаковый результат размещения приложения в фоновом режиме. Когда пользователь нажимает кнопку "назад", он сообщает Android о том, что они выполняются с действием. Android приведет к уничтожению действия. В противоположность этому, когда пользователь нажимает кнопку "домой", действие просто помещается в фоновый &ndash; Android не будет прерывать действие.

<a name="Managing_State_Throughout_the_Lifecycle" />

## <a name="managing-state-throughout-the-lifecycle"></a>Управление состоянием в течение жизненного цикла

Когда действие остановлено или уничтожено, система предоставляет возможность сохранить состояние действия для последующего переброски.
Это сохраненное состояние называется состоянием экземпляра. Android предоставляет три варианта хранения состояния экземпляра во время жизненного цикла действия:

1. Хранение примитивных значений в `Dictionary` называется [набором](xref:Android.OS.Bundle) , который Android будет использовать для сохранения состояния.

1. Создание пользовательского класса, который будет содержать сложные значения, такие как точечные рисунки. Android будет использовать этот пользовательский класс для сохранения состояния.

1. Обход жизненного цикла изменения конфигурации и предположение полной ответственности за поддержание состояния в действии.

В этом руководстве рассматриваются два первых варианта.

### <a name="bundle-state"></a>Состояние пакета

Основным вариантом сохранения состояния экземпляра является использование объекта словаря ключей и значений, известного как [пакет](xref:Android.OS.Bundle).
Помните, что когда создается действие, которое метод `OnCreate` передается в качестве параметра, этот пакет можно использовать для восстановления состояния экземпляра. Не рекомендуется использовать пакет для более сложных данных, которые не будут быстро или легко сериализоваться в пары "ключ-значение" (например, точечные рисунки); Вместо этого он должен использоваться для простых значений, таких как строки.

Действие предоставляет методы, помогающие сохранить и извлечь состояние экземпляра в пакете:

- [Онсавеинстанцестате](xref:Android.App.Activity.OnSaveInstanceState*) &ndash; это вызывается Android при уничтожении действия. Действия могут реализовать этот метод, если нужно сохранить все элементы состояния ключа или значения.

- [Онрестореинстанцестате](xref:Android.App.Activity.OnRestoreInstanceState*) &ndash; это вызывается после завершения метода `OnCreate` и предоставляет еще одну возможность восстановления его состояния после завершения инициализации.

На следующей схеме показано, как используются эти методы.

[Блок-схема состояний пакета![](images/image3-sml.png)](images/image3.png#lightbox)

#### <a name="onsaveinstancestate"></a>онсавеинстанцестате

[Онсавеинстанцестате](xref:Android.App.Activity.OnSaveInstanceState*) будет вызываться при остановке действия. Он получит параметр пакета, в котором действие может сохранить свое состояние в. Когда устройство изменяет конфигурацию, действие может использовать `Bundle` объект, передаваемый для сохранения состояния действия путем переопределения `OnSaveInstanceState`. Рассмотрим следующий пример кода:

```csharp
int c;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  this.SetContentView (Resource.Layout.SimpleStateView);

  var output = this.FindViewById<TextView> (Resource.Id.outputText);

  if (bundle != null) {
    c = bundle.GetInt ("counter", -1);
  } else {
    c = -1;
  }

  output.Text = c.ToString ();

  var incrementCounter = this.FindViewById<Button> (Resource.Id.incrementCounter);

  incrementCounter.Click += (s,e) => {
    output.Text = (++c).ToString();
  };
}
```

Приведенный выше код увеличивает целое число с именем `c` при нажатии кнопки с именем `incrementCounter`, отображая результат в `TextView` с именем `output`. Когда происходит изменение конфигурации (например, при вращении устройства), приведенный выше код потеряет значение `c`, так как `bundle` будет `null`, как показано на рисунке ниже.

[![отображения не показывает предыдущее значение](images/07-sml.png)](images/07.png#lightbox)

Чтобы сохранить значение `c` в этом примере, действие может переопределить `OnSaveInstanceState`, сохранив значение в пакете, как показано ниже:

```csharp
protected override void OnSaveInstanceState (Bundle outState)
{
  outState.PutInt ("counter", c);
  base.OnSaveInstanceState (outState);
}
```

Теперь, когда устройство поворачивается на новую ориентацию, целое число сохраняется в пакете и извлекается со строкой:

```csharp
c = bundle.GetInt ("counter", -1);
```

> [!NOTE]
> Важно всегда вызывать базовую реализацию `OnSaveInstanceState` так, чтобы состояние иерархии представления также можно было сохранить.

##### <a name="view-state"></a>Состояние представления

Переопределение `OnSaveInstanceState` является подходящим механизмом для сохранения временных данных в рамках действия по изменению ориентации, например счетчика в приведенном выше примере. Однако реализация `OnSaveInstanceState` по умолчанию позаботится о сохранении временных данных в пользовательском интерфейсе для каждого представления, если каждому представлению назначен идентификатор. Например, предположим, что приложение содержит элемент `EditText`, определенный в XML следующим образом:

```xml
<EditText android:id="@+id/myText"
  android:layout_width="fill_parent"
  android:layout_height="wrap_content"/>
```

Поскольку элементу управления `EditText` назначено `id`, когда пользователь вводит некоторые данные и поворачивает устройство, данные по-прежнему отображаются, как показано ниже:

[![данные сохраняются в альбомном режиме](images/08-sml.png)](images/08.png#lightbox)

#### <a name="onrestoreinstancestate"></a>онрестореинстанцестате

[Онрестореинстанцестате](xref:Android.App.Activity.OnRestoreInstanceState*) будет вызван после `OnStart`. Она предоставляет действию возможность восстановления любого состояния, которое ранее было сохранено в пакете во время предыдущего `OnSaveInstanceState`. Однако это тот же пакет, который предоставляется для `OnCreate`.

В следующем коде показано, как можно восстановить состояние в `OnRestoreInstanceState`.

```csharp
protected override void OnRestoreInstanceState(Bundle savedState)
{
    base.OnRestoreSaveInstanceState(savedState);
    var myString = savedState.GetString("myString");
    var myBool = savedState.GetBoolean("myBool");
}
```

Этот метод существует для обеспечения некоторой гибкости при восстановлении состояния. Иногда лучше ожидать завершения всех инициализаций перед восстановлением состояния экземпляра. Кроме того, подклассу существующего действия может потребоваться восстановить только определенные значения из состояния экземпляра. Во многих случаях нет необходимости переопределять `OnRestoreInstanceState`, так как большинство действий могут восстанавливать состояние с помощью пакета, предоставленного для `OnCreate`.

Пример сохранения состояния с помощью `Bundle`см. в [пошаговом руководстве — сохранение состояния действия](saving-state.md).

#### <a name="bundle-limitations"></a>Ограничения пакета

Хотя `OnSaveInstanceState` упрощает сохранение временных данных, у него есть некоторые ограничения.

- Он не вызывается во всех случаях. Например, если нажать клавишу **Home** или **назад** для выхода из действия, `OnSaveInstanceState` не будет вызван.

- Пакет, переданный в `OnSaveInstanceState`, не предназначен для больших объектов, таких как изображения. В случае с большими объектами рекомендуется сохранить объект из [онретаиннонконфигуратионинстанце](xref:Android.App.Activity.OnRetainNonConfigurationInstance) , как описано ниже.

- Данные, сохраненные с помощью пакета, сериализуются, что может привести к задержкам.

Состояние пакета полезно для простых данных, которые не используют много памяти, в то время как *данные экземпляра, не относящиеся к конфигурации* , полезны для более сложных данных или данных, которые извлекаются дорого, например из вызова веб-службы или сложного запроса к базе данных. Данные экземпляра, не относящиеся к конфигурации, сохраняются в объекте по мере необходимости. В следующем разделе представлены `OnRetainNonConfigurationInstance` как способ сохранения более сложных типов данных с помощью изменений конфигурации.

### <a name="persisting-complex-data"></a>Сохранение сложных данных

Кроме сохранения данных в пакете, Android также поддерживает сохранение данных путем переопределения [онретаиннонконфигуратионинстанце](xref:Android.App.Activity.OnRetainNonConfigurationInstance) и возврата экземпляра `Java.Lang.Object`, содержащего данные для сохранения. Существует два основных преимущества использования `OnRetainNonConfigurationInstance` для сохранения состояния:

- Объект, возвращаемый из `OnRetainNonConfigurationInstance`, хорошо работает с большими, более сложными типами данных, так как память удерживает этот объект.

- Метод `OnRetainNonConfigurationInstance` вызывается по запросу и только при необходимости. Это более экономично, чем использование кэша вручную.

Использование `OnRetainNonConfigurationInstance` подходит для сценариев, где дорогостоящее извлечение данных происходит несколько раз, например в вызовах веб-служб. Например, рассмотрим следующий код, который выполняет поиск в Twitter:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);
    SearchTwitter ("xamarin");
  }

  public void SearchTwitter (string text)
  {
    string searchUrl = String.Format("http://search.twitter.com/search.json?" + "q={0}&rpp=10&include_entities=false&" + "result_type=mixed", text);

    var httpReq = (HttpWebRequest)HttpWebRequest.Create (new Uri (searchUrl));
    httpReq.BeginGetResponse (new AsyncCallback (ResponseCallback), httpReq);
  }

  void ResponseCallback (IAsyncResult ar)
  {
    var httpReq = (HttpWebRequest)ar.AsyncState;

    using (var httpRes = (HttpWebResponse)httpReq.EndGetResponse (ar)) {
      ParseResults (httpRes);
    }
  }

  void ParseResults (HttpWebResponse httpRes)
  {
    var s = httpRes.GetResponseStream ();
    var j = (JsonObject)JsonObject.Load (s);

    var results = (from result in (JsonArray)j ["results"] let jResult = result as JsonObject select jResult ["text"].ToString ()).ToArray ();

    RunOnUiThread (() => {
      PopulateTweetList (results);
    });
  }

  void PopulateTweetList (string[] results)
  {
    ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
  }
}
```

Этот код извлекает результаты из веб-формата в формате JSON, анализирует их, а затем представляет результаты в списке, как показано на следующем снимке экрана:

[Результаты![, отображаемые на экране](images/06-sml.png)](images/06.png#lightbox)

При изменении конфигурации (например, при смене устройства) код повторяет процесс. Чтобы повторно использовать полученные ранее результаты и не вызывали лишних, избыточных сетевых вызовов, можно использовать `OnRetainNonconfigurationInstance` для сохранения результатов, как показано ниже:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  TweetListWrapper _savedInstance;

  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);

    var tweetsWrapper = LastNonConfigurationInstance as TweetListWrapper;

    if (tweetsWrapper != null) {
      PopulateTweetList (tweetsWrapper.Tweets);
    } else {
      SearchTwitter ("xamarin");
    }

    public override Java.Lang.Object OnRetainNonConfigurationInstance ()
    {
      base.OnRetainNonConfigurationInstance ();
      return _savedInstance;
    }

    ...

    void PopulateTweetList (string[] results)
    {
      ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
      _savedInstance = new TweetListWrapper{Tweets=results};
    }
}
```

После смены устройства исходные результаты извлекаются из свойства `LastNonConfiguartionInstance`. В этом примере результаты состоят из `string[]`, содержащей твиты. Поскольку `OnRetainNonConfigurationInstance` требует, чтобы `Java.Lang.Object` возвращался, `string[]` упаковывается в класс, подклассы `Java.Lang.Object`, как показано ниже:

```csharp
class TweetListWrapper : Java.Lang.Object
{
  public string[] Tweets { get; set; }
}
```

Например, попытка использовать `TextView` в качестве объекта, возвращаемого из `OnRetainNonConfigurationInstance`, приведет к утечке действия, как показано в следующем коде:

```csharp
TextView _textView;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  var tv = LastNonConfigurationInstance as TextViewWrapper;

  if(tv != null) {
    _textView = tv;
    var parent = _textView.Parent as FrameLayout;
    parent.RemoveView(_textView);
  } else {
    _textView = new TextView (this);
    _textView.Text = "This will leak.";
  }

  SetContentView (_textView);
}

public override Java.Lang.Object OnRetainNonConfigurationInstance ()
{
  base.OnRetainNonConfigurationInstance ();
  return _textView;
}
```

В этом разделе мы узнали, как сохранять простые данные о состоянии с помощью `Bundle`и сохранять более сложные типы данных с `OnRetainNonConfigurationInstance`.

## <a name="summary"></a>Сводка

Жизненный цикл действий Android предоставляет мощную платформу для управления состоянием действий в приложении, но может быть непростой для понимания и реализации. В этой главе представлены различные состояния, на которые может пройти действие во время его существования, а также методы жизненного цикла, связанные с этими состояниями. Затем в каждом из этих методов было указано, какой тип логики следует выполнять.

## <a name="related-links"></a>Связанные ссылки

- [Обработка поворота](~/android/app-fundamentals/handling-rotation.md)
- [Действие Android](xref:Android.App.Activity)
