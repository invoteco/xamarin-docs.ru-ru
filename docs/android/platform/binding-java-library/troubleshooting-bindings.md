---
title: Устранение неполадок с привязками
description: В этой статье перечислены общие ошибки сервера, которые могут возникнуть при создании привязок, а также возможные причины и способы их устранения.
ms.prod: xamarin
ms.assetid: BB81FCCF-F7BF-4C78-884E-F02C49AA819A
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 03/01/2018
ms.openlocfilehash: 0c273797d7512f062260e49e0f71fdd1132f037b
ms.sourcegitcommit: db422e33438f1b5c55852e6942c3d1d75dc025c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76723807"
---
# <a name="troubleshooting-bindings"></a>Устранение неполадок с привязками

_В этой статье перечислены общие ошибки сервера, которые могут возникнуть при создании привязок, а также возможные причины и способы их устранения._

## <a name="overview"></a>Обзор

Привязка библиотеки Android (файл **. AAR** или **. jar**) редко является простым привязанности; обычно требуются дополнительные усилия по устранению проблем, возникающих в результате различий между Java и .NET.
Эти проблемы не позволят Xamarin. Android привязать библиотеку Android и представлять их как сообщения об ошибках в журнале сборки. В этом руководство будут представлены некоторые советы по устранению неполадок, перечислены некоторые из наиболее распространенных проблем и сценариев, а также предоставлены возможные решения для успешной привязки библиотеки Android.

При привязке существующей библиотеки Android необходимо иметь в виду следующие моменты.

- **Внешние зависимости для библиотеки** &ndash; все зависимости Java, необходимые для библиотеки Android, должны быть добавлены в проект Xamarin. Android как **Референцежар** или как **ембеддедреференцежар**.

- **Уровень API Android, предназначенных библиотека Android,** &ndash; невозможно "перейти на более раннюю версию" уровня API Android. Убедитесь, что в проекте привязки Xamarin. Android используется тот же уровень API (или выше), что и в библиотеке Android.

- **Версия JDK Android, которая использовалась для упаковки библиотеки android** &ndash; ошибки привязки, может возникнуть, если библиотека Android была построена с использованием другой версии JDK, отличной от используемой Xamarin. Android. Если возможно, перескомпилируйте библиотеку Android с использованием той же версии JDK, которая используется в вашей установке Xamarin. Android.

Первым шагом в устранении неполадок привязки библиотеки Xamarin. Android является включение [выходных данных диагностики MSBuild](~/android/troubleshooting/troubleshooting.md#Diagnostic_MSBuild_Output).
После включения диагностических данных перестройте проект привязки Xamarin. Android и изучите журнал сборки, чтобы найти сведения о причине проблемы.

Также может оказаться полезным декомпилировать библиотеку Android и исследовать типы и методы, которые пытается выполнить привязка Xamarin. Android. Более подробно эти сведения рассматриваются далее в этом пошаговом окне.

## <a name="decompiling-an-android-library"></a>Декомпиляция библиотеки Android

Изучение классов и методов классов Java может предоставить ценную информацию, которая поможет привязать библиотеку.
[JD — графический интерфейс пользователя](http://jd.benow.ca/) — это графическая программа, которая может отображать исходный код Java из файлов **классов** , содержащихся в JAR-файле. Его можно запустить как автономное приложение или как подключаемый модуль для IntelliJ или Eclipse.

Чтобы декомпилировать библиотеку Android, откройте **. JAR** -файл с декомпилятором Java. Если библиотека является **. AAR** , необходимо извлечь файл **Classes. jar** из файла архива. Ниже приведен пример снимка экрана с использованием JD-GUI для анализа JAR [принцессу](https://square.github.io/picasso/) :

![Использование декомпилятора Java для анализа Пикассо-2.5.2. jar](troubleshooting-bindings-images/troubleshoot-bindings-01.png)

После декомпиляции библиотеки Android изучите исходный код. Говоря вообще, ищите:

- **Классы с характеристиками запутывания** &ndash; характеристики запутанных классов включают:

  - Имя класса включает **$** , т. е. **класс $.**
  - Имя класса полностью скомпрометировано символов нижнего регистра, т. е. **класса.**      

- **`import` операторы для библиотек без ссылок** &ndash; указать библиотеку, на которую нет ссылок, и добавить эти зависимости в проект привязки Xamarin. Android с **действием сборки** **референцежар** или **ембедддедреференцежар**.

> [!NOTE]
> Декомпиляция библиотеки Java может быть запрещена или подчиняется юридическим ограничениям на основе местного законодательства или лицензии, с которой была опубликована библиотека Java. При необходимости закрепите службы юридического лица, прежде чем пытаться декомпилировать библиотеку Java и изучить исходный код.

## <a name="inspect-apixml"></a>Проверьте API. КОД

В процессе создания проекта привязки Xamarin. Android создает имя XML-файла **obj/Debug/API. XML**:

![Созданный API. XML в файле obj/Debug](troubleshooting-bindings-images/troubleshoot-bindings-02.png)

Этот файл содержит список всех API-интерфейсов Java, которые выполняет привязка Xamarin. Android. Содержимое этого файла может помочь определить отсутствующие типы или методы, дублирующие привязки. Хотя проверка этого файла выполняется утомительно и занимает много времени, она может предоставить сведения о том, что может вызвать проблемы с привязкой. Например, **файл API. XML** может обнаружить, что свойство возвращает недопустимый тип, или что существует два типа, имеющих одно и то же управляемое имя.

## <a name="known-issues"></a>Известные проблемы

В этом разделе перечислены некоторые распространенные сообщения об ошибках или симптомы, которые возникают при попытке привязать библиотеку Android.

### <a name="problem-java-version-mismatch"></a>Проблема: несоответствие версии Java

Иногда типы не будут создаваться или непредвиденные сбои могут возникать из-за того, что вы используете более новую или более раннюю версию Java по сравнению с библиотекой, с которой была выполнена компиляция. Перекомпилируйте библиотеку Android с той же версией JDK, которую использует проект Xamarin. Android.

### <a name="problem-at-least-one-java-library-is-required"></a>Проблема. требуется по крайней мере одна библиотека Java

Вы получаете сообщение об ошибке «требуется по крайней мере одна библиотека Java», даже если. Был добавлен JAR-файл.

#### <a name="possible-causes"></a>Возможные причины:

Убедитесь, что для действия сборки задано значение `EmbeddedJar`. Так как существует несколько действий сборки для. JAR-файлы (такие как `InputJar`, `EmbeddedJar`, `ReferenceJar` и `EmbeddedReferenceJar`), генератор привязок не может автоматически угадать, какой из них использовать по умолчанию. Дополнительные сведения о действиях сборки см. в разделе [действия сборки](~/android/platform/binding-java-library/index.md).

### <a name="problem-binding-tools-cannot-load-the-jar-library"></a>Проблема. средства привязки не могут загрузить. Библиотека JAR-файлов

Генератору библиотек привязки не удается загрузить. Библиотека JAR.

#### <a name="possible-causes"></a>Возможные причины

Некоторых. Библиотеки JAR, использующие маскировку кода (с помощью таких средств, как reguard), не могут быть загружены средствами Java. Так как в нашем средстве используется отражение Java и библиотека инженерного кода ASM, эти зависимые средства могут отклонять маскированные библиотеки, в то время как средства среды выполнения Android могут передаваться. Для решения этой проблемы можно вручную привязать эти библиотеки вместо использования генератора привязки.

### <a name="problem-missing-c-types-in-generated-output"></a>Проблема. отсутствующие C# типы в создаваемых выходных данных.

Сборка Binding **. dll** создает, но не пропустила некоторые типы Java, C# или созданный источник не строится из-за ошибки, сообщающей о наличии отсутствующих типов.

#### <a name="possible-causes"></a>Возможные причины:

Эта ошибка может возникать по нескольким причинам, указанным ниже.

- Связанная библиотека может ссылаться на вторую библиотеку Java. Если открытый API для привязанной библиотеки использует типы из второй библиотеки, необходимо также ссылаться на управляемую привязку для второй библиотеки.

- Возможно, что библиотека была внедрена из-за отражения Java, аналогично причине ошибки загрузки библиотеки выше, что привело к непредвиденной загрузке метаданных. В настоящее время средства Xamarin. Android не могут решить эту проблему. В этом случае библиотека должна быть привязана вручную.

- В среде выполнения .NET 4,0 возникла ошибка, которая не смогла загрузить сборки, когда она должна иметь. Эта проблема исправлена в среде выполнения .NET 4,5.

- Java позволяет наследовать открытый класс от класса, не являющегося открытым, но это не поддерживается в .NET. Поскольку генератор привязки не создает привязки для классов, не являющихся открытыми, производные классы, такие как, не могут быть сформированы правильно. Чтобы устранить эту проблему, удалите запись метаданных для этих производных классов с помощью Remove-Node в **файле Metadata. XML**или исправьте метаданные, которые отправляют неоткрытый класс в открытый. Несмотря на то, что Последнее решение создаст привязку, C# чтобы источник выполнит сборку, не следует использовать неоткрытый класс.

  Пример:

  ```xml
  <attr path="/api/package[@name='com.some.package']/class[@name='SomeClass']"
      name="visibility">public</attr>
  ```

- Средства, которые закрывают библиотеки Java, могут конфликтовать с генератором привязок Xamarin. Android и его C# возможностью создавать классы-оболочки. В следующем фрагменте кода показано, как обновить **файл metadata. XML** для демаскировки имени класса:

  ```xml
  <attr path="/api/package[@name='{package_name}']/class[@name='{name}']"
      name="obfuscated">false</attr>
  ```

### <a name="problem-generated-c-source-does-not-build-due-to-parameter-type-mismatch"></a>Проблема. не C# удалось выполнить сборку созданного источника из-за несоответствия типов параметров

Созданный C# источник не строится. Типы параметров переопределенного метода не совпадают.

#### <a name="possible-causes"></a>Возможные причины:

Xamarin. Android включает множество полей Java, сопоставленных с перечислениями в C# привязках. Это может привести к несовместимости типов в созданных привязках. Чтобы устранить эту проблему, необходимо изменить подписи методов, созданные в генераторе привязок, чтобы использовать перечисления. Дополнительные сведения см. в разделе [исправление перечислений](~/android/platform/binding-java-library/customizing-bindings/java-bindings-metadata.md).

### <a name="problem-noclassdeffounderror-in-packaging"></a>Проблема: Ноклассдеффаундеррор в упаковке

на шаге упаковки выдается `java.lang.NoClassDefFoundError`.

#### <a name="possible-causes"></a>Возможные причины:

Наиболее вероятная причина этой ошибки заключается в том, что обязательная библиотека Java должна быть добавлена в проект приложения (**CSPROJ**). . JAR-файлы не разрешаются автоматически. Привязка библиотеки Java не всегда создается для пользовательской сборки, которая не существует на целевом устройстве или эмуляторе (например, в Google Maps **Map. jar**). Это не так для поддержки проекта библиотеки Android в качестве библиотеки. JAR-файл внедряется в библиотеку DLL. Например: [ошибка 4288](https://bugzilla.xamarin.com/show_bug.cgi?id=4288)

### <a name="problem-duplicate-custom-eventargs-types"></a>Проблема: дублирование пользовательских типов EventArgs

Сбой сборки из-за дублирования пользовательских типов EventArgs. Произошла ошибка, подобная следующей:

```shell
error CS0102: The type `Com.Google.Ads.Mediation.DismissScreenEventArgs' already contains a definition for `p0'
```

#### <a name="possible-causes"></a>Возможные причины:

Это обусловлено тем, что существует конфликт между типами событий, поступающими из более чем одного типа "прослушиватель" интерфейса, который использует одинаковые имена для методов. Например, если есть два интерфейса Java, как показано в приведенном ниже примере, генератор создает `DismissScreenEventArgs` как для `MediationBannerListener`, так и для `MediationInterstitialListener`, что приводит к ошибке.

```java
// Java:
public interface MediationBannerListener {
    void onDismissScreen(MediationBannerAdapter p0);
}
public interface MediationInterstitialListener {
    void onDismissScreen(MediationInterstitialAdapter p0);
}
```

Это сделано по шаблону, чтобы избежать длинных имен в типах аргументов событий. Чтобы избежать этих конфликтов, требуется преобразование некоторых метаданных. Измените **трансформс\метадата.ксмл** и добавьте атрибут `argsType` в любой из интерфейсов (или в метод интерфейса):

```xml
<attr path="/api/package[@name='com.google.ads.mediation']/
        interface[@name='MediationBannerListener']/method[@name='onDismissScreen']"
        name="argsType">BannerDismissScreenEventArgs</attr>

<attr path="/api/package[@name='com.google.ads.mediation']/
        interface[@name='MediationInterstitialListener']/method[@name='onDismissScreen']"
        name="argsType">IntersitionalDismissScreenEventArgs</attr>

<attr path="/api/package[@name='android.content']/
        interface[@name='DialogInterface.OnClickListener']"
        name="argsType">DialogClickEventArgs</attr>
```

### <a name="problem-class-does-not-implement-interface-method"></a>Проблема: класс не реализует метод интерфейса

Выдается сообщение об ошибке, указывающее, что создаваемый класс не реализует метод, необходимый для интерфейса, реализуемого созданным классом. Однако, взглянув на созданный код, можно увидеть, что метод реализован.

Ниже приведен пример ошибки.

```shell
obj\Debug\generated\src\Oauth.Signpost.Basic.HttpURLConnectionRequestAdapter.cs(8,23):
error CS0738: 'Oauth.Signpost.Basic.HttpURLConnectionRequestAdapter' does not
implement interface member 'Oauth.Signpost.Http.IHttpRequest.Unwrap()'.
'Oauth.Signpost.Basic.HttpURLConnectionRequestAdapter.Unwrap()' cannot implement
'Oauth.Signpost.Http.IHttpRequest.Unwrap()' because it does not have the matching
return type of 'Java.Lang.Object'
```

#### <a name="possible-causes"></a>Возможные причины:

Это проблема, возникающая при связывании методов Java с ковариантными возвращаемыми типами. В этом примере методу `Oauth.Signpost.Http.IHttpRequest.UnWrap()` необходимо возвращать `Java.Lang.Object`. Однако метод `Oauth.Signpost.Basic.HttpURLConnectionRequestAdapter.UnWrap()` имеет тип возвращаемого значения `HttpURLConnection`. Устранить эту проблему можно двумя способами:

- Добавьте объявление разделяемого класса для `HttpURLConnectionRequestAdapter` и явно реализуйте `IHttpRequest.Unwrap()`:

  ```csharp
  namespace Oauth.Signpost.Basic {
      partial class HttpURLConnectionRequestAdapter {
          Java.Lang.Object OauthSignpost.Http.IHttpRequest.Unwrap() {
              return Unwrap();
          }
      }
  }
  ```

- Удалите ковариацию из созданного C# кода. Это включает добавление следующего преобразования в **трансформс\метадата.ксмл** , которое приведет к тому, C# что созданный код будет иметь тип возвращаемого значения `Java.Lang.Object`:

  ```xml
  <attr
      path="/api/package[@name='oauth.signpost.basic']/class[@name='HttpURLConnectionRequestAdapter']/method[@name='unwrap']"
      name="managedReturn">Java.Lang.Object
  </attr>
  ```

### <a name="problem-name-collisions-on-inner-classes--properties"></a>Проблема. конфликты имен во внутренних классах и свойствах

Конфликтующая видимость наследуемых объектов.

В Java не требуется, чтобы производный класс имел ту же видимость, что и его родитель. Java просто исправит это решение. В C#, это должно быть явным, поэтому необходимо убедиться, что все классы в иерархии имеют соответствующую видимость. В следующем примере показано, как изменить имя пакета Java с `com.evernote.android.job` на `Evernote.AndroidJob`.

```xml
<!-- Change the visibility of a class -->
<attr path="/api/package[@name='namespace']/class[@name='ClassName']" name="visibility">public</attr>

<!-- Change the visibility of a method -->
<attr path="/api/package[@name='namespace']/class[@name='ClassName']/method[@name='MethodName']" name="visibility">public</attr>
```

### <a name="problem-a-so-library-required-by-the-binding-is-not-loading"></a>Проблема: а **. Поэтому** Библиотека, необходимая для привязки, не загружается

Некоторые проекты привязки могут также зависеть от функциональности в **. Итак,** библиотека. Возможно, Xamarin. Android не будет автоматически загружать библиотеку **.** При выполнении упакованного кода Java Xamarin. Android не сможет выполнить вызов JNI и сообщение об ошибке _Java. lang. унсатисфиедлинкеррор: собственный метод не найден:_ будет отображаться в logcat out для приложения.

Исправление предназначено для того, чтобы вручную загрузить библиотеку **. для** библиотеки с вызовом `Java.Lang.JavaSystem.LoadLibrary`. Например, предположим, что проект Xamarin. Android имеет libpocketsphinx_jni общей библиотеки **. так что** он включается в проект привязки с действием сборки **ембеддеднативелибрари**, следующий фрагмент кода (выполненный перед использованием общей библиотеки) загрузит библиотеку **. так** :

```csharp
Java.Lang.JavaSystem.LoadLibrary("pocketsphinx_jni");
```

## <a name="summary"></a>Сводка

В этой статье перечислены распространенные проблемы устранения неполадок, связанные с привязками Java, и описаны способы их устранения.

## <a name="related-links"></a>Связанные ссылки

- [Проекты библиотек](https://developer.android.com/tools/projects/index.html#LibraryProjects)
- [Работа с JNI](~/android/platform/java-integration/working-with-jni.md)
- [Включить вывод диагностических данных](~/android/troubleshooting/troubleshooting.md#Diagnostic_MSBuild_Output)
- [Xamarin для разработчиков Android](~/android/get-started/java-developers.md)
- [JD-GUI](http://jd.benow.ca/)
