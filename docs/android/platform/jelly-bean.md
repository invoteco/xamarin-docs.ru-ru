---
title: Возможности Jelly Bean
description: 'В этом документе предоставлен общий обзор новых возможностей для разработчиков, которые появились в Android 4.1. Среди этих возможностей: улучшенные уведомления, обновления Android Beam для совместного использования больших файлов, обновления для мультимедиа, обнаружение одноранговых сетей, анимации, новые разрешения.'
ms.prod: xamarin
ms.assetid: 23F57634-2EF9-5C15-C710-B3E19A5AF7E1
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 03/01/2018
ms.openlocfilehash: a638ccf7810c737faaeded7fcc98fcf657c85288
ms.sourcegitcommit: 9ee02a2c091ccb4a728944c1854312ebd51ca05b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/10/2020
ms.locfileid: "73027210"
---
# <a name="jelly-bean-features"></a>Возможности Jelly Bean

_В этом документе предоставлен общий обзор новых возможностей для разработчиков, которые появились в Android 4.1. Среди этих возможностей: улучшенные уведомления, обновления Android Beam для совместного использования больших файлов, обновления для мультимедиа, обнаружение одноранговых сетей, анимации, новые разрешения._

## <a name="overview"></a>Обзор

ОС Android 4.1 (API уровня 16), также известная как Jelly Bean, выпущена 9 июля 2012 г. В этой статье приведены вводные сведения верхнего уровня о некоторых новых возможностях в Android 4.1 для разработчиков, использующих Xamarin.Android. Некоторые из представленных новых возможностей являются улучшениями анимации для запуска действия, новыми звуками для камеры и улучшенной поддержкой навигации по стеку приложений. Возвращена возможность вырезать и вставлять с использованием намерений.

Повышена стабильность приложений Android благодаря возможности изолировать зависимость от нестабильных поставщиков содержимого. Службы также можно изолировать, чтобы они были доступны только для тех действий, которые их запустили.

Добавлена поддержка обнаружения сетевых служб с использованием служб Bonjour, UPnP или многоадресных служб на основе DNS. Уведомления также усовершенствованы за счет возможностей форматирования текста, использования больших изображений и добавленных кнопок действий.

Наконец, в Android 4.1 добавлены несколько новых разрешений.

## <a name="requirements"></a>Требования

Для разработки приложений Xamarin.Android, использующих Jelly Bean, требуется установить Xamarin.Android 4.2.6 или более поздней версии и Android 4.1 (API уровня 16) с помощью Диспетчера SDK Android, как показано на приведенном ниже снимке экрана.

[![Выбор Android 4.1 в Диспетчере SDK Android](jelly-bean-images/image1.png)](jelly-bean-images/image1.png#lightbox)

## <a name="whats-new"></a>Новые возможности

### <a name="animations"></a>Анимации

Действия могут быть запущены с использованием анимаций масштабирования или настраиваемых анимаций с помощью класса `ActivityOptions`. Для поддержки этих анимаций предусмотрены приведенные ниже новые методы.

- `MakeScaleUpAnimation` — будет создана анимация, которая увеличивает масштаб окна действия, исходя из начальной позиции и размера на экране.
- `MakeThumbnailScaleUpAnimation` — будет создана анимация, которая увеличивает масштаб от эскиза изображения, исходя из указанной позиции на экране.
- `MakeCustomAnimation` — будет создана анимация на основе ресурсов в приложении. Одна анимация воспроизводится при открытии действия, а другая — при его остановке.

Новый класс `TimeAnimator` предоставляет интерфейс `TimeAnimator.ITimeListener`, который может уведомлять приложение каждый раз, когда в анимации изменяется кадр. Например, рассмотрим следующую реализацию `TimeAnimator.ITimeListener`:

```csharp
class MyTimeListener : Java.Lang.Object,  TimeAnimator.ITimeListener
{
    public void OnTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime)
    {
        Log.Debug("Activity1", "totalTime={0}, deltaTime={1}", totalTime, deltaTime);
    }
}
```

Теперь, чтобы использовать класс, создается экземпляр класса `TimeAnimator` и устанавливается прослушиватель:

```csharp
var animator = new TimeAnimator();
animator.SetTimeListener(new MyTimeListener());
animator.Start();
```

Когда экземпляр `TimeAnimator` запущен, он вызывает `ITimeAnimator.ITimeListener`, который затем регистрирует продолжительность времени работы средства анимации, а также время с момента последнего вызова метода.

### <a name="application-stack-navigation"></a>Навигация по стеку приложений

Android 4.1 отличается улучшенной навигацией по стеку приложений в сравнении с представленной в Android 3.0. Если указать свойство `ParentName` для `ActivityAttribute`, Android может открывать соответствующее родительское действие, когда пользователь нажмет кнопку [Вверх](https://developer.android.com/design/patterns/navigation.html#up-vs-back) на панели действий. Android будет создавать экземпляр действия, указанного свойством `ParentName`. Благодаря этому приложения могут сохранять иерархию действий, выполняющих заданную задачу.

Для большинства приложений настройка свойства `ParentName` для действия предоставляет достаточно информации для Android, чтобы обеспечивать правильное поведение при навигации по стеку приложений. Android будет синтезировать необходимый обратный стек, создавая ряд намерений для каждого родительского действия. Но стек приложений искусственный, поэтому у каждого искусственного действия не будет сохраненного состояния, которое было бы у естественного действия. Чтобы обеспечить сохранение состояния синтетического родительского действия, для действия можно переопределить метод `OnPrepareNavigationUpTaskStack`. Этот метод получает экземпляр `TaskStackBuilder`, содержащий коллекцию объектов намерений, которые Android будет использовать для создания обратного стека. Действие может изменить эти намерения так, чтобы при создании искусственного действия оно получало правильную информацию о состоянии.

Для более сложных сценариев есть новые методы класса Activity, которые могут использоваться для обработки поведения навигации при нажатии кнопки "Вверх" и создания обратного стека.

- `OnNavigateUp` — переопределив этот метод, можно задать выполнение настраиваемого действия при нажатии кнопки **Вверх**.
- `NavigateUpTo` — вызов этого метода приведет к тому, что приложение перейдет от текущего действия к действию, определенному заданным намерением.
- `ParentActivityIntent` — этот метод используется для получения намерения, которое запустит родительское действие текущего действия.
- `ShouldUpRecreateTask` — этот метод используется, чтобы создать запрос и определить, должен ли быть создан искусственный обратный стек для перехода к родительскому действию. Возвращает значение `true`, если искусственный стек должен быть создан. 
- `FinishAffinity` — вызов этого метода завершит текущее действие и все дочерние действия в текущем задании, если у них есть сходство по одному заданию.
- `OnCreateNavigateUpTaskStack` — этот метод переопределяется, когда необходимо полностью контролировать то, как создается искусственный стек.

### <a name="camera"></a>Камера

Новый интерфейс `Camera.IAutoFocusMoveCallback` позволяет определить, когда автофокус начал или прекратил движение. Пример этого нового интерфейса можно увидеть в следующем фрагменте кода:

```csharp
public class AutoFocusCallbackActivity : Activity, Camera.IAutoFocusCallback
{
    public void OnAutoFocus(bool success, Camera camera)
    {
        // camera is an instance of the camera service object.

        if (success)
        {
            // Auto focus was successful - do something here.
        }
        else
        {
            // Auto focus didn't happen for some reason - react to that here.
        }
    }
}
```

Новый класс `MediaActionSound` предоставляет набор API для создания звуков для различных мультимедийных действий. Есть несколько действий, которые могут произойти с камерой, и они определяются перечислением `Android.Media.MediaActionSoundType`:

- `MediaActionSoundType.FocusComplete` — этот звук воспроизводится, когда фокусировка завершена;
- `MediaActionSoundType.ShutterClick` — этот звук будет воспроизводиться после съемки неподвижного изображения;
- `MediaActionSoundType.StartVideoRecording` — этот звук используется для обозначения начала видеозаписи;
- `MediaActionSoundType.StopVideoRecording` — этот звук будет воспроизводиться для обозначения завершения видеозаписи.

Пример использования класса `MediaActionSound` можно увидеть в следующем фрагменте кода:

```csharp
var mediaActionPlayer = new MediaActionSound();

// Preload the sound for a shutter click.
mediaActionPlayer.Load(MediaActionSoundType.ShutterClick);
var button = FindViewById<Button>(Resource.Id.MyButton);

// Play the sound on a button click.
button.Click += (sender, args) => mediaActionPlayer.Play(MediaActionSoundType.ShutterClick);

// This releases the preloaded resources. Don’t make any calls on
// mediaActionPlayer after this.
mediaActionPlayer.Release();
```

### <a name="connectivity"></a>Подключение

#### <a name="android-beam"></a>Android Beam

Android Beam — это технология на основе NFC, которая позволяет двум устройствам Android взаимодействовать друг с другом. Android 4.1 обеспечивает улучшенную поддержку для передачи больших файлов. При использовании нового метода `NfcAdapter.SetBeamPushUris()` Android будет переключаться между альтернативными транспортными механизмами (такими как Bluetooth) для достижения быстрой скорости передачи.

#### <a name="network-services-discovery"></a>Обнаружение сетевых служб

Android 4.1 содержит новые API для обнаружения многоадресных служб на основе DNS.
Благодаря этому приложения могут обнаруживать по сети Wi-Fi другие устройства, такие как принтеры, камеры и мультимедийные устройства и подключаться к ним. Эти новые API находятся в пакете `Android.Net.Nsd`.

Чтобы создать службу, которую могут использовать другие службы, можно использовать класс `NsdServiceInfo`, создающий объект, который будет определять свойства службы. Затем этот объект предоставляется `NsdManager.RegisterService()`, а также реализации `NsdManager.ResolveListener`. Реализации `NsdManager.ResolveListener` используются для уведомления об успешной регистрации и отмены регистрации службы.

Для обнаружения служб в сети и реализации `Nsd.DiscoveryListener` передается `NsdManager.discoverServices()`.

#### <a name="network-usage"></a>Использование сети

С помощью нового метода `ConnectivityManager.IsActiveNetworkMetered` устройство может проверять, подключено ли оно к сети с лимитным тарифным планом. Этот метод можно использовать для управления использованием данных путем точного информирования пользователей о том, что операции с данными могут повлечь за собой большие расходы.

#### <a name="wifi-direct-service-discovery"></a>Обнаружение службы Wi-Fi Direct

С Android 4.0 представлен класс `WifiP2pManager` для поддержки *zeroconf*. Zeroconf (zero configuration networking, или сеть с нулевой конфигурацией) — это набор методов, с помощью которых устройства (компьютеры, принтеры, телефоны) могут подключаться к сетям автоматически, с участием сотрудников-операторов или применением специальных серверов конфигурации.

В Jelly Bean `WifiP2pManager` может обнаруживать устройства поблизости, используя *Bonjour* или *Upnp*. Bonjour — это реализация zeroconf от Apple. Upnp — это набор сетевых протоколов, который также поддерживает zeroconf. Для поддержки обнаружения службы Wi-Fi в `WiFiP2pManager` добавлены методы ниже.

- `AddLocalService()` — этот метод используется для объявления приложения в качестве службы через Wi-Fi для обнаружения одноранговыми узлами.
- `AddServiceRequest(`) — этот метод используется для отправки запроса на обнаружение службы к платформе. Он используется для инициализации обнаружения службы Wi-Fi.
- `SetDnsSdResponseListeners()` — этот метод предназначен для регистрации обратных вызовов, которые будут выполняться при получении ответа на запросы обнаружения от Bonjour.
- `SetUpnpServiceResponseListener()` — этот метод предназначен для регистрации обратных вызовов, которые будут выполняться при получении ответа на запросы обнаружения от Upnp.

### <a name="content-providers"></a>Поставщики содержимого

Класс `ContentResolver` получил новый метод `AcquireUnstableContentProvider`. С помощью этого метода приложение может приобретать "нестабильного" поставщика содержимого. Как правило, когда приложение приобретает поставщика содержимого и этот поставщик дает сбой, то же случается и с приложением. При вызове этого метода приложение будет работать без сбоев, если произойдет сбой поставщика содержимого. Вместо этого будет выдаваться исключение `Android.OS.DeadObjectionException` при вызовах поставщика содержимого, чтобы сообщить приложению, что поставщик содержимого не обнаружен. "Нестабильный" поставщик содержимого полезен при взаимодействии с поставщиками из других приложений — маловероятно, что ошибка в коде из другого приложения повлияет на другое приложение.

### <a name="copy-and-paste-with-intents"></a>Копирование и вставка с помощью намерений

Теперь класс `Intent` может содержать объект `ClipData`, связанный с ним с помощью свойства `Intent.ClipData`. Этот метод позволяет передавать с намерением дополнительные данные из буфера обмена. Экземпляр `ClipData` может содержать один или несколько `ClipData.Item`. Объекты `ClipData.Item` — это элементы следующих типов:

- **Text** — это любая строка текста, HTML или любая строка, формат которой поддерживается встроенными диапазонами стиля Android;
- **Intent** — это любой объект `Intent`;
- **Uri** — это может быть любой универсальный код ресурса (URI), например закладка HTTP или URI для поставщика содержимого.

### <a name="isolated-services"></a>Изолированные службы

Изолированная служба — это служба, которая работает по собственному специальному процессу и не имеет собственных разрешений. Единственный обмен данными со службой — это запуск службы и привязка к ней через API службы. Службу можно объявить как изолированную, установив свойство `IsolatedProcess="true"` в том `ServiceAttribute`, что оформляет класс службы.

### <a name="media"></a>Мультимедиа

Новый класс `Android.Media.MediaCodec` предоставляет API для низкоуровневых кодеков мультимедиа. Приложения могут выполнять запросы к системе, чтобы определить, какие низкоуровневые кодеки доступны на устройстве.

Для поддержки дополнительной предварительной обработки звука в полученной аудиозаписи добавлены новые приведенные ниже подклассы `Android.Media.Audiofx.AudioEffect`.

- `Android.Media.Audiofx.AcousticEchoCanceler` — этот класс используется для предварительной обработки звука, чтобы удалить сигнал с удаленной стороны из записанного аудиосигнала. Например, удаление эха из приложения голосовой связи.
- `Android.Media.Audiofx.AutomaticGainControl` — этот класс используется для нормализации полученного сигнала путем повышения или понижения уровня входного сигнала, чтобы выходной сигнал являлся постоянным.
- `Android.Media.Audiofx.NoiseSuppressor` — этот класс удалит фоновый шум из полученного сигнала.

Не все устройства будут поддерживать эти эффекты. Метод `AudioEffect.IsAvailable` должен вызываться приложением, чтобы проверить, поддерживается ли конкретный звуковой эффект на устройстве, на котором запущено приложение.

Класс `MediaPlayer` теперь поддерживает воспроизведение без пауз благодаря методу `SetNextMediaPlayer()`. Этот новый метод определяет следующий класс MediaPlayer, который должен запускаться, когда текущий проигрыватель мультимедиа завершает воспроизведение.

Приведенные ниже новые классы предоставляют стандартные механизмы и пользовательский интерфейс для выбора того, где воспроизводить мультимедиа.

- `MediaRouter` — благодаря этому классу приложения могут управлять маршрутизацией каналов мультимедиа с устройства на внешние динамики или другие устройства.
- `MediaRouterActionProvider` и `MediaRouteButton` — эти классы обеспечивают согласованность пользовательского интерфейса для выбора и воспроизведения мультимедиа.

### <a name="notifications"></a>Уведомления

Android 4.1 обеспечивает повышенные гибкость и контроль отображения уведомлений для приложений. Приложения теперь могут показывать пользователям большие и улучшенные уведомления. Новый метод `NotificationBuilder.SetStyle()` позволяет использовать один из трех новых приведенных ниже стилей для уведомлений.

- `Notification.BigPictureStyle` — это вспомогательный класс, который будет создавать уведомления, содержащие изображения. На следующем рисунке показан пример уведомления с большим изображением:

 [![Пример снимка экрана с уведомлением BigPictureStyle](jelly-bean-images/image2.png)](jelly-bean-images/image2.png#lightbox)

- `Notification.BigTextStyle` — это вспомогательный класс, который будет создавать уведомления, содержащие несколько строк текста, например сообщение электронной почты. Пример этого нового стиля уведомлений приведен на следующем снимке экрана:

 [![Пример снимка экрана с уведомлением BigTextStyle](jelly-bean-images/image3.png)](jelly-bean-images/image3.png#lightbox)

- `Notification.InboxStyle` — это вспомогательный класс, который будет создавать уведомления, содержащие список строк, например фрагменты из сообщения электронной почты, как показано на этом снимке экрана:

 [![Пример снимка экрана с уведомлением Notification.InboxStyle](jelly-bean-images/image4.png)](jelly-bean-images/image4.png#lightbox)

В нижней части сообщения уведомления можно добавить до двух кнопок действий, если для уведомления используется нормальный или увеличенный стиль.
Пример этого можно увидеть на следующем снимке экрана, где кнопки действий отображаются в нижней части уведомления:

 [![Пример снимка экрана с кнопками действий, показанными в нижней части сообщения уведомления](jelly-bean-images/image5.png)](jelly-bean-images/image5.png#lightbox)

Класс `Notification` получил новые константы, которые позволяют разработчику указать один из пяти уровней приоритета для уведомления. Их можно настроить в уведомлении, используя свойство `Priority`.

### <a name="permissions"></a>Разрешения

Добавлены приведенные ниже новые разрешения.

- `READ_EXTERNAL_STORAGE` — приложение требует доступ только для чтения к внешнему хранилищу. Сейчас у всех приложений есть доступ для чтения по умолчанию, но в будущих выпусках Android приложениям необходимо будет явно запрашивать доступ на чтение.
- `READ_USER_DICTIONARY` — предоставляет доступ на чтение к словарю пользователя.
- `READ_CALL_LOG` — позволяет приложению получать информацию о входящих и исходящих вызовах, считывая сведения журнала звонков.
- `WRITE_CALL_LOG` — позволяет приложению выполнять запись в журнал звонков на телефоне.
- `WRITE_USER_DICTIONARY` — позволяет приложению выполнять запись в словарь пользователя.

Самое важное изменение, которое вы заметите: `READ_EXTERNAL_STORAGE` — сейчас это разрешение автоматически предоставляется Android. В будущих версиях Android приложение будет запрашивать это разрешение, прежде чем его можно будет предоставить.

## <a name="summary"></a>Сводка

В этой статье представлены некоторые новые API, доступные в Android 4.1 (API уровня 16). В ней приведены сведения о некоторых изменениях анимации и анимации запуска действия, а также описаны новые API для сетевого обнаружения других устройств с использованием таких протоколов, как Bonjour или UPnP. Здесь также приведены сведения о других изменениях в API, таких как возможность вырезать и вставлять данные с помощью намерений, возможность использовать изолированные службы или "нестабильные" поставщики содержимого.

Кроме того, в этой статье представлены обновления уведомлений и рассмотрены некоторые новые разрешения, представленные в Android 4.1.

## <a name="related-links"></a>Связанные ссылки

- [Xamarin.Android — анимация во времени](https://docs.microsoft.com/samples/xamarin/monodroid-samples/platformfeatures-timeanimatorexample)
- [API Android 4.1](https://developer.android.com/about/versions/android-4.1.html)
- [Общие сведения о задачах и обратных стеках](https://developer.android.com/guide/components/tasks-and-back-stack.html)
- [Навигация с помощью кнопок "Назад" и "Вверх"](https://developer.android.com/design/patterns/navigation.html)
