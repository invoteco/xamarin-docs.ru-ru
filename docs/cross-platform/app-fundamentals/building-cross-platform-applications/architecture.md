---
title: Часть 2. Архитектура
description: В этом документе описываются шаблоны архитектуры, которые полезны для создания кроссплатформенных приложений. В нем обсуждаются типичные уровни приложений (уровень данных, уровень доступа к данным и т. д.) и распространенные шаблоны мобильных приложений (MVVM, MVC и т. д.).
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
author: conceptdev
ms.author: crdun
ms.date: 03/27/2017
ms.openlocfilehash: 7657985ce14633140adb0e63a9817ddd0e48841d
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70284572"
---
# <a name="part-2---architecture"></a>Часть 2. Архитектура

Ключевой принцип создания кроссплатформенных приложений — создание архитектуры, которая предоставляет возможности для максимизации общего кода, используемого несколькими платформами. Соблюдение следующих принципов объектно-ориентированного программирования помогает создавать приложение с хорошо продуманной архитектурой:

- **Инкапсуляция** — гарантирует, что классы и даже архитектурные уровни предоставляют только минимум API-интерфейса, который выполняет свои требуемые функции и скрывает подробности реализации. На уровне класса это означает, что объекты ведут себя как "черные ящики" и что коду-потребителю не требуется знать, как они выполняют свои задачи. На уровне архитектуры это означает реализацию шаблонов, таких как фасад, которые поощряют упрощение API, координирующих более сложные взаимодействия от имени кода в более абстрактных слоях. Это означает, что код UI (например) должен отвечать только за отображение экранов и принятие входных данных пользователя, никогда не взаимодействуя с базой данных напрямую. Аналогичным образом код обращения к данным должен выполнять только чтение и запись в базу данных, но никогда не должен взаимодействовать напрямую с кнопками или надписями.
- **Разделение обязанностей** — гарантирует, что каждый компонент (уровня и архитектуры, и класса) имеет понятную и четко определенную цель. Каждый компонент должен выполнять только свои определенные задачи и предоставлять функциональные возможности через интерфейс API, доступный для других классов.
- **Полиморфизм** — программирование интерфейса (или абстрактного класса), который поддерживает несколько реализаций. Это означает, что основной код может быть использован на различных платформах, но по-прежнему обеспечивает взаимодействие с их уникальными функциями.


Естественным результатом будет приложение, смоделированое на основе реальных или абстрактных сущностей с использованием отдельных логических уровней. Разделение кода на уровни упрощает понимание, тестирование и поддержку приложений. Рекомендуется, чтобы код в каждом уровне был отделен физически (либо в каталоги, либо даже в отдельные проекты для очень больших приложений), а также логически (с использованием пространства имен).

 <a name="Typical_Application_Layers" />


## <a name="typical-application-layers"></a>Стандартные уровни приложений

В этом документе и в конкретных примерах мы ссылаемся на следующие шесть уровней приложения:

- **Уровень данных** — долговременное хранение данных, вероятно, является базой данных SQLite, но может быть реализовано с помощью XML-файлов или любого другого подходящего механизма.
- **Уровень доступа к данным** — оболочка над уровнем данных, которая обеспечивает доступ к данным для создания, чтения, обновления, удаления (CRUD), не раскрывая особенностей реализации вызывающему объекту. Например, DAL может содержать инструкции SQL для запроса или обновления данных, но вызывающий код не должен знать об этом.
- **Бизнес-слой** (иногда называется уровнем бизнес-логики или BLL) — содержит определения бизнес-сущностей (модель) и бизнес-логику. Кандидат для шаблона Business Façade.
- **Уровень доступа к службе** — используется для доступа к службам в облаке: от сложных веб-служб (REST, JSON, WCF) до простого извлечения данных и изображений с удаленных серверов. Инкапсулирует поведение по сети и предоставляет простой API для использования на уровнях приложений и пользовательского интерфейса.
- **Уровень приложений** — код, который обычно принадлежит конкретной платформе (не кроссплатформенный), или код, зависящий от приложения (обычно не для многократного использования). Хороший способ проверить необходимость поместить код на уровне приложения или на уровне интерфейса — это определить, (а) имеет ли класс какие-либо фактически отображаемые элементы управления или (б) поддерживает ли он одновременное использование на множестве экранов или устройств (например, iPhone и iPad).
- **Уровень пользовательского интерфейса (UI)** — уровень взаимодействия с пользователем, содержит экраны, виджеты и контроллеры для управления ими.


Приложения не обязательно содержит все уровни — например, уровень доступа к службам не будет существовать в приложении, которое не осуществляет доступ к сетевым ресурсам. Очень простое приложение может объединить уровень данных и уровень доступа к данным, так как в них очень простые операции.

 <a name="Common_Mobile_Software_Patterns" />


## <a name="common-mobile-software-patterns"></a>Распространенные шаблоны мобильных приложений

Шаблоны — устоявшиеся способы решения распространенных проблем. Существует несколько основных шаблонов, которые рекомендуется знать для создания понятных и простых в обслуживании мобильных приложений.

- **Model, View, ViewModel (MVVM)** — шаблон Model-View-ViewModel популярен на платформах, поддерживающих привязку данных, например Xamarin.Forms. Он стал распространен благодаря SDK, содержащим XAML, например Windows Presentation Foundation (WPF) и Silverlight. В них ViewModel выступает в роли посредника между данными (моделью) и пользовательским интерфейсом (представлением) через привязку данных и команд.
- **Model, View, Controller  (MVC)** — типичный и часто недооцененный шаблон, MVC чаще всего используется при создании пользовательских интерфейсов. Он обеспечивает разделение фактического экрана интерфейса (представления), управляющего взаимодействием механизма (контроллера) и заполняющих его данных (модели). Модель по сути является совершенно необязательной частью, поэтому главными для понимания этого шаблона являются представление и контроллер. MVC — это популярный подход к приложениям iOS.
- Шаблон **Business фасадной** – Manager предоставляет упрощенную точку входа для сложной работы. Например, в приложении отслеживания задач у вас может быть класс `TaskManager` с методами `GetAllTasks()` , `GetTask(taskID)` , `SaveTask (task)` и т. д. Класс `TaskManager` предоставляет интерфейс (фасад) для внутренних операций сохранения и извлечения объектов задачи.
- **Singleton** — шаблон Singleton обеспечивает существование только одного экземпляра определенного объекта. Например, при использовании SQLite в мобильных приложениях вам будет нужно, чтобы был только один экземпляр базы данных. Singleton позволяет легко это гарантировать.
- **Provider** — шаблон, предложенный корпорацией Майкрософт (возможно, он похож на Strategy или базовое внедрение зависимостей) для поддержки многократного использования кода в приложениях Silverlight, WPF и WinForms. Общий код можно писать для интерфейса или абстрактного класса, а конкретные реализации платформы записываются и передаются при использовании кода.
- **Async** (не путать с ключевым словом Async) — используется в том случае, когда нужно выполнить длительную работу без задержки пользовательского интерфейса или текущих процессов. В простейшей форме шаблон Async описывает, что в случае выполнения длительных задач они должны быть вынесены в другой поток (или в аналогичные абстракции потока, например задачу), а текущий поток продолжает выполняться и ожидать ответа от фонового процесса, после чего обновляет интерфейс при возврате данных и состояния.


Каждый из шаблонов будет рассмотрен более подробно в обучающих примерах. Также там приведены примеры их практического использования. В Википедии есть более подробные описания шаблонов [MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel), [MVC](https://en.wikipedia.org/wiki/Model–view–controller), [Façade](https://en.wikipedia.org/wiki/Facade_pattern), [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern), [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern)и [Provider](https://en.wikipedia.org/wiki/Provider_model) (а также [шаблонов проектирования](https://en.wikipedia.org/wiki/Design_Patterns) в целом).
