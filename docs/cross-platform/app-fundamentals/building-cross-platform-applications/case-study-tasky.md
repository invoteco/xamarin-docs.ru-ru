---
title: Практический пример кроссплатформенного приложения. Tasky
description: В этом документе описывается, как пример приложения Tasky Portable разработано и создано как кросс платформенных мобильных приложений. В нем описывается приложения требования, интерфейс, модель данных, основные функциональные возможности, реализации и многое другое.
ms.prod: xamarin
ms.assetid: B581B2D0-9890-C383-C654-0B0E12DAD5A6
author: asb3993
ms.author: amburns
ms.date: 03/23/2017
ms.openlocfilehash: 15b4154ad6e95aabb5e88784660a93bb53c0b252
ms.sourcegitcommit: c1d85b2c62ad84c22bdee37874ad30128581bca6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/08/2019
ms.locfileid: "67650197"
---
# <a name="cross-platform-app-case-study-tasky"></a>Практический пример кроссплатформенного приложения. Tasky

*Tasky* *переносимой* — это простое приложение списка задач. В этом документе рассматривается, как оно разработано и создано, следуя указаниям из [создание кросс-платформенных приложений](~/cross-platform/app-fundamentals/building-cross-platform-applications/index.md) документа. Обсуждение рассматриваются следующие вопросы:

<a name="Design_Process" />

## <a name="design-process"></a>Процесс проектирования

Рекомендуется создать road-карты, необходимой для достижения, прежде чем приступить к кодированию. Это особенно верно для кросс платформенной разработки, где вы создаете функциональные возможности, будут предоставлены различными способами. Начиная с четкое представление о, что вы создаете экономит время и усилия в цикле разработки позже.

 <a name="Requirements" />

### <a name="requirements"></a>Требования

Первым шагом в разработке приложения — для определения необходимых компонентов. Это могут быть высокоуровневые цели или подробно описаны варианты использования. Tasky имеет простой функциональных требований:

 -  Просмотр списка задач
 -  Добавление, изменение и удаление задач
 -  Задать состояние задания на «Готово»

Рассмотрите возможность использования функций конкретных платформ.  Tasky преимущества географическое зонирование iOS или Windows Phone Live Tiles? Даже если вы не используете функций конкретных платформ, в первой версии, вы должны заранее спланировать убедитесь, что ваш бизнес и уровни данных можно учитывать их.

 <a name="User_Interface_Design" />

### <a name="user-interface-design"></a>Проектирование пользовательского интерфейса

Начните с высокоуровневую структуру, который может быть реализован на целевых платформах. Внимательно примечание содержится код платформы пользовательского интерфейса ограничения. Например `TabBarController` в iOS можно отобразить более пяти кнопок, тогда как эквивалент Windows Phone можно отобразить одной-четырех.
Рисование на экране процесс с помощью средства по своему усмотрению (бумаги работает).

 [![](case-study-tasky-images/taskydesign.png "Рисование на экране процесс с помощью инструмента на ваш Выбор бумаги works")](case-study-tasky-images/taskydesign.png#lightbox)

 <a name="Data_Model" />

### <a name="data-model"></a>Модель данных

Зная, какие данные нужно хранить поможет определить, какой механизм сохраняемости для использования. См. в разделе [доступ к данным кросс-платформенные](~/cross-platform/app-fundamentals/index.md) сведения о механизмы доступное хранилище и помощи в выборе между ними. Для этого проекта мы будем использовать для SQLite.NET.

Tasky должен храниться для каждого TaskItem три свойства:

 -  **Имя** — строка
 -  **Заметки о** — строка
 -  **Сделать** — логическое значение

 <a name="Core_Functionality" />

### <a name="core-functionality"></a>Основные функции

Рассмотрим API, пользовательский интерфейс будет необходимо использовать в соответствии с требованиями. Список задач требуются следующие функции:

 -   **Вывод списка всех задач** — для отображения основной экран список всех доступных задач
 -  **Получите одну задачу** — при касании строка задачи
 -  **Сохраните одну задачу** — при редактировании задачи
 -  **Удаление одной задачи** — при удалении задачи
 -  **Создайте пустую задачу** — при создании новой задачи

Чтобы обеспечить повторное использование кода, этот API, следует реализовать один раз *переносимой библиотеки классов*.

 <a name="Implementation" />

### <a name="implementation"></a>Реализация

После разработки приложения согласованный, рассмотрим, как его можно реализовать в виде межплатформенного приложения. Это станет архитектуры приложения. Следуя инструкциям в [создание кросс-платформенных приложений](~/cross-platform/app-fundamentals/building-cross-platform-applications/index.md) документом, код приложения должен быть неработающих вниз на следующие части:

 -   **Общий код** — распространенные проекта, содержит повторно готовый к применению код для сохранения данных задач; класс модели и API для управления сохранение и загрузку данных.
 -   **Код платформы** — проекты под конкретные платформы, которые реализуют собственный пользовательский Интерфейс для каждой операционной системы, используя общий код в качестве серверной части.

 [![](case-study-tasky-images/taskypro-architecture.png "Проекты под конкретные платформы реализации собственного пользовательского интерфейса для каждой операционной системы, используя общий код в качестве серверной части")](case-study-tasky-images/taskypro-architecture.png#lightbox)

В следующих разделах описываются эти две части.

 <a name="Common_(PCL)_Code" />

## <a name="common-pcl-code"></a>Общий код (PCL)

Tasky Portable использует стратегию переносимой библиотеки классов для совместного использования общего кода. См. в разделе [варианты совместного использования кода](~/cross-platform/app-fundamentals/code-sharing.md) документа описание параметры совместного использования кода.

Все общем коде, включая уровень доступа к данным, кода базы данных и контракты, помещается в проекте библиотеки.

Полный проект переносимой библиотеки Классов, показано ниже. Весь код в переносимой библиотеке совместим с каждой целевой платформы. При развертывании каждого собственное приложение будет ссылаться на эту библиотеку.

![](case-study-tasky-images/portable-project.png "При развертывании каждого собственное приложение ссылающиеся на эту библиотеку")

На следующей схеме классов показаны классы, сгруппированные по слоя. `SQLiteConnection` Класс представляет собой стандартный код из пакета Sqlite-NET. Остальные классы являются пользовательский код для Tasky. `TaskItemManager` И `TaskItem` классы представляют API, который предоставляется приложениями для конкретных платформ.

 [![](case-study-tasky-images/classdiagram-core.png "Классы TaskItemManager и TaskItem представляют API, который предоставляется приложениями для конкретных платформ")](case-study-tasky-images/classdiagram-core.png#lightbox)

Использование пространств имен с отдельными слоями, помогает управлять ссылки между каждого слоя. Проекты под конкретные платформы необходимо только включить `using` инструкции для бизнес-слой. Уровень доступа к данным и уровень данных должны быть инкапсулированы в API, который предоставляется командлетом `TaskItemManager` на бизнес-уровне.

 <a name="References" />

### <a name="references"></a>Ссылки

Переносимые библиотеки классов должны использоваться на различных платформах, каждая из которых различные уровни поддержки для платформы и механизмами инфраструктуры. Поэтому существуют ограничения, на которых можно использовать пакеты и библиотеки framework. Например, Xamarin.iOS поддерживает c# `dynamic` ключевое слово, поэтому переносимой библиотеке классов не можете использовать любой пакет, который зависит от динамического кода, несмотря на то, что такой код будет работать на устройстве Android. Visual Studio для Mac не позволяет добавлять несовместимые пакеты и ссылки, но необходимо помнить ограничения Чтобы избежать сюрпризов позже.

Примечание. Вы увидите, что проекты ссылаться на библиотеки framework, которые вы ранее не использовали. Эти ссылки являются частью шаблонов проектов Xamarin. При компиляции приложения процесс связывания приведет к удалению кода, на которые нет ссылок, поэтому, даже если `System.Xml` была ссылка на, он не войдет в итоговое приложение так, как мы не используем какие-либо функции Xml.

 <a name="Data_Layer_(DL)" />

### <a name="data-layer-dl"></a>Уровень данных (DL)

Уровень данных содержит код, который выполняет физическое хранилище данных — для базы данных, неструктурированные файлы или другой механизм. Уровень Tasky данных состоит из двух частей: SQLite-NET-library и пользовательский код, добавленный для привязывания его.

Tasky использует пакет nuget Sqlite-net (опубликованное Фрэнк Kreuger) для внедрения кода SQLite NET, которая предоставляет интерфейс для объектно-реляционного сопоставления (ORM) базы данных. `TaskItemDatabase` Класс наследует от `SQLiteConnection` и добавляет необходимые создание, чтение, обновление, методы и удаления (CRUD) для чтения и записи данных SQLite. Это реализация простого шаблона универсальных методов CRUD, можно повторно использовать в других проектах.

`TaskItemDatabase` Является одноэлементным множеством, гарантируя, что все доступа происходит относительно тот же экземпляр. Чтобы предотвратить одновременный доступ из нескольких потоков используется блокировка.

 <a name="SQLite_on_WIndows_Phone" />

#### <a name="sqlite-on-windows-phone"></a>SQLite для Windows Phone

IOS и Android, которые поставляются с SQLite как часть операционной системы Windows Phone не включает подсистему совместимой базы данных. Совместное использование кода на всех трех платформ Windows phone-машинный код версию SQLite является обязательным. См. в разделе [работа с локальной базой данных](~/xamarin-forms/data-cloud/data/databases.md) Дополнительные сведения о настройке проекта Windows Phone для Sqlite.

 <a name="Using_an_Interface_to_Generalize_Data_Access" />

#### <a name="using-an-interface-to-generalize-data-access"></a>С помощью интерфейса, чтобы подготовить к работе доступа к данным

Уровень данных зависит от `BL.Contracts.IBusinessIdentity` , чтобы его можно реализовать методы доступа к данным абстрактный, требующих первичный ключ. Любой класс бизнес-слой, который реализует интерфейс, можно сохранять на уровне данных.

Интерфейс определяет только целочисленное свойство в качестве первичного ключа:

```csharp
public interface IBusinessEntity {
    int ID { get; set; }
}
```

Базовый класс реализует интерфейс и добавляет атрибуты SQLite-NET, чтобы пометить его как первичный ключ с автоматическим приращением. Любой класс на бизнес-уровне, который реализует этот базовый класс могут затем сохраняться на уровне данных:

```csharp
public abstract class BusinessEntityBase : IBusinessEntity {
    public BusinessEntityBase () {}
    [PrimaryKey, AutoIncrement]
    public int ID { get; set; }
}
```

Пример универсальных методов на уровне данных, использующих интерфейс — это `GetItem<T>` метод:

```csharp
public T GetItem<T> (int id) where T : BL.Contracts.IBusinessEntity, new ()
{
    lock (locker) {
        return Table<T>().FirstOrDefault(x => x.ID == id);
    }
}
```

 <a name="Locking_to_prevent_Concurrent_Access" />

#### <a name="locking-to-prevent-concurrent-access"></a>Блокировки для предотвращения одновременного доступа

Объект [блокировки](https://msdn.microsoft.com/library/c5kehkcz(v=vs.100).aspx) реализован в пределах `TaskItemDatabase` класса, чтобы предотвратить одновременный доступ к базе данных. Это позволяет обеспечить сериализуется одновременный доступ из разных потоков (в противном случае компонент пользовательского интерфейса может попытаться прочитать базы данных в то же время он обновляется в фоновом потоке). Ниже показан пример реализации блокировки:

```csharp
static object locker = new object ();
public IEnumerable<T> GetItems<T> () where T : BL.Contracts.IBusinessEntity, new ()
{
    lock (locker) {
        return (from i in Table<T> () select i).ToList ();
    }
}
public T GetItem<T> (int id) where T : BL.Contracts.IBusinessEntity, new ()
{
    lock (locker) {
        return Table<T>().FirstOrDefault(x => x.ID == id);
    }
}
```

Большая часть кода уровня данных может использоваться повторно в других проектах. Код только относящиеся к приложению в слое- `CreateTable<TaskItem>` вызов в `TaskItemDatabase` конструктор.

 <a name="Data_Access_Layer_(DAL)" />

### <a name="data-access-layer-dal"></a>Уровень доступа к данным (DAL)

`TaskItemRepository` Класс инкапсулирует механизм хранения данных с помощью API со строгой типизацией, позволяющий `TaskItem` объектов должен быть создан, удален, получать и обновлять.

 <a name="Using_Conditional_Compilation" />

#### <a name="using-conditional-compilation"></a>С помощью условной компиляции

Класс использует условную компиляцию, чтобы задать расположение файла — это пример реализации платформы расхождения. Свойство, которое возвращает путь компилируется другой код на каждой платформе. Код и директивы компилятора платформы, показаны ниже:

```csharp
public static string DatabaseFilePath {
    get {
        var sqliteFilename = "TaskDB.db3";
#if SILVERLIGHT
        // Windows Phone expects a local path, not absolute
        var path = sqliteFilename;
#else
#if __ANDROID__
        // Just use whatever directory SpecialFolder.Personal returns
        string libraryPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal); ;
#else
        // we need to put in /Library/ on iOS5.1+ to meet Apple's iCloud terms
        // (they don't want non-user-generated data in Documents)
        string documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
        string libraryPath = Path.Combine (documentsPath, "..", "Library"); // Library folder
#endif
        var path = Path.Combine (libraryPath, sqliteFilename);
                #endif
                return path;
    }
}
```

В зависимости от платформы, результатом будет «<app
path>/Library/TaskDB.db3» для iOS, "<app
path>/Documents/TaskDB.db3» для Android или просто «TaskDB.db3» для Windows Phone.

### <a name="business-layer-bl"></a>Бизнес-слой (BL)

Бизнес-слой реализует классы моделей и интерфейс для управления ими.
В Tasky модели — это `TaskItem` класс и `TaskItemManager` реализует шаблон фасадом, предоставляют API-Интерфейс для управления `TaskItems`.

 <a name="Façade" />

#### <a name="faade"></a>Интерфейс

 `TaskItemManager` заключает в оболочку `DAL.TaskItemRepository` для предоставления Get, сохранения и удаления методов, которые будет ссылаться приложения и слои пользовательского интерфейса.

Бизнес-правила и логику помещается здесь при необходимости — например всех правил проверки, которые должны быть удовлетворены, прежде чем объект будет сохранен.

 <a name="API_for_Platform-Specific_Code" />

### <a name="api-for-platform-specific-code"></a>API для кода для конкретных платформ

После написания общий код пользовательского интерфейса должны быть построены для сбора и отображения данных, доступ к которым он предоставляет. `TaskItemManager` Класс реализует интерфейс шаблон для предоставления простой API для кода приложения для доступа к.

Код, написанный в каждом проекте платформы будут обычно быть тесно связан с собственным пакетом SDK для этого устройства и доступ только к общим кодом, с помощью API, определенный по `TaskItemManager`. Сюда входят методы и бизнеса класс он предоставляет, таких как `TaskItem`.

Образы не общей для платформ а в каждый проект добавляются независимо друг от друга. Это важно, так как каждая платформа обработки изображений по-разному, используя другие имена файлов, каталогов и способы их устранения.

В оставшихся разделах обсуждаются детали реализации платформы Tasky пользовательского интерфейса.

 <a name="iOS_App" />

## <a name="ios-app"></a>Приложение iOS

Существует лишь небольшое число классов, необходимый для реализации iOS Tasky приложения, с помощью общих проект переносимой библиотеки Классов для хранения и извлечения данных. Ниже приведен полный iOS проекта Xamarin.iOS:

 ![](case-study-tasky-images/taskyios-solution.png "Здесь показан проект iOS")

Классы показаны на этой схеме, сгруппированных в слои.

 [![](case-study-tasky-images/classdiagram-android.png "Классы, показаны на этой схеме, сгруппированных в слои")](case-study-tasky-images/classdiagram-android.png#lightbox)

 <a name="References" />

### <a name="references"></a>Ссылки

Приложения iOS ссылается на пакет SDK для библиотеки для конкретных платформ — например. Xamarin.iOS и MonoTouch.Dialog-1.

Он также должен ссылаться на `TaskyPortableLibrary` проект переносимой библиотеки Классов.
Ниже приведен список ссылок.

 ![](case-study-tasky-images/taskyios-references.png "Ниже приведен список ссылок")

Слой пользовательского интерфейса и уровня приложений, реализуются в этом проекте с помощью этих ссылок.

 <a name="Application_Layer_(AL)" />

### <a name="application-layer-al"></a>Уровень приложений (п.)

На уровне приложения содержит классы платформы, необходимый для привязки объектами, предоставляемыми переносимой библиотеки Классов пользовательского интерфейса. Приложение iOS конкретных имеет два класса обеспечивает отображение задач:

 -   **EditingSource** — этот класс используется для привязки к пользовательскому интерфейсу списки задач. Так как `MonoTouch.Dialog` был использован для списка задач, нам нужно реализовать этого вспомогательного объекта, чтобы включить функции прокрутки для удаления в `UITableView` . Проведите по экрану для удаления характерно для iOS, но не Android или Windows Phone, поэтому конкретного проекта iOS является единственным, который его реализует.
 -   **TaskDialog** — этот класс используется для привязки одну задачу в пользовательский интерфейс. Она использует `MonoTouch.Dialog` API отражения для создания «оболочки» `TaskItem` объекта с классом, который содержит правильные атрибуты, чтобы разрешить экран ввода правильно отформатировать.

`TaskDialog` Класс использует `MonoTouch.Dialog` атрибуты для создания экрана в зависимости от свойств класса. Класс выглядит следующим образом:

```csharp
public class TaskDialog {
    public TaskDialog (TaskItem task)
    {
        Name = task.Name;
        Notes = task.Notes;
        Done = task.Done;
    }
    [Entry("task name")]
    public string Name { get; set; }
    [Entry("other task info")]
    public string Notes { get; set; }
    [Entry("Done")]
    public bool Done { get; set; }
    [Section ("")]
    [OnTap ("SaveTask")]    // method in HomeScreen
    [Alignment (UITextAlignment.Center)]
    public string Save;
    [Section ("")]
    [OnTap ("DeleteTask")]  // method in HomeScreen
    [Alignment (UITextAlignment.Center)]
    public string Delete;
}
```

Обратите внимание, что `OnTap` атрибуты нуждаются в имени метода — должна существовать эти методы в классе где `MonoTouch.Dialog.BindingContext` создается (в этом случае `HomeScreen` классов, описанных в следующем разделе).

 <a name="User_Interface_Layer_(UI)" />

### <a name="user-interface-layer-ui"></a>Слой пользовательского интерфейса (UI)

Слой пользовательского интерфейса состоит из следующих классов:

1.   **AppDelegate** — содержит вызовы API внешнего вида для определения стиля шрифтов и цветов, используемых в приложении. Tasky представляет собой простое приложение, поэтому никакие другие задачи инициализации, работающих в `FinishedLaunching` .
2.   **Экраны** – подклассы `UIViewController` , которые определяют каждый экран и его поведение. Экраны пользовательского интерфейса с помощью классов уровня приложений и распространенных API связать вместе ( `TaskItemManager` ). В этом примере в коде создаются экраны, но они могут были разработаны с помощью конструктора Interface Builder или конструктор раскадровки.
3.   **Образы** — визуальные элементы являются важной частью каждого приложения. Tasky имеет изображения заставки экрана и значок, которые должны быть указаны в обычном режиме и разрешения Retina для iOS.

 <a name="Home_Screen" />

#### <a name="home-screen"></a>Начальный экран

На экране Главная `MonoTouch.Dialog` экран, отображающий список задач из базы данных SQLite. Он наследует от `DialogViewController` и реализует код, чтобы задать `Root` должен содержать коллекцию `TaskItem` объекты для отображения.

 [![](case-study-tasky-images/ios-taskylist.png "Он наследуется от DialogViewController и реализует код, чтобы задать корневой папке, чтобы содержать коллекцию объектов TaskItem для отображения")](case-study-tasky-images/ios-taskylist.png#lightbox)

Ниже приведены два основных метода, относящиеся к отображения и взаимодействия со списком задач.

1.   **PopulateTable** — использует бизнес-слой `TaskManager.GetTasks` метод для извлечения коллекции `TaskItem` объектов для отображения.
2.   **Выбранные** — когда строка затрагивается, отображает задачу на новом экране.

 <a name="Task_Details_Screen" />

#### <a name="task-details-screen"></a>Экран сведений задачи

Сведения о задаче — входной экран, который позволяет задачам удалены или изменены.

Использует tasky `MonoTouch.Dialog`по API отражения для отображения экрана, так что есть не `UIViewController` реализации. Вместо этого `HomeScreen` класс создает и отображает `DialogViewController` с помощью `TaskDialog` класс, от уровня приложения.

На этом снимке экрана показано пустой экран, демонстрирующий `Entry` атрибут задания текста водяного знака в **имя** и **заметки** поля:

 [![](case-study-tasky-images/ios-taskydetail.png "На этом снимке экрана показано пустой экран, демонстрирующий задания текста водяного знака в поля «имя» и «заметки о Entry-атрибут")](case-study-tasky-images/ios-taskydetail.png#lightbox)

Функциональные возможности **сведения о задаче** экрана (например, сохранение или удаление задачи), которые должны быть реализованы в `HomeScreen` класса, так как именно здесь `MonoTouch.Dialog.BindingContext` создается. Следующие `HomeScreen` методы поддерживают на экране сведения о задаче:

1.   **ShowTaskDetails** — создание `MonoTouch.Dialog.BindingContext` для отображения экрана. Он создает экран ввода, использование отражения для получения имен свойств и типов из `TaskDialog` класса. Дополнительные сведения, например текста водяного знака для полей ввода, реализуется с помощью атрибутов в свойствах.
2.   **SaveTask** — этот метод указывается в `TaskDialog` класса через `OnTap` атрибута. Он вызывается, когда **Сохранить** нажата и использует `MonoTouch.Dialog.BindingContext` для получения вводимых пользователем данных перед сохранением изменений с помощью `TaskItemManager` .
3.   **DeleteTask** — этот метод указывается в `TaskDialog` класса через `OnTap` атрибута. Она использует `TaskItemManager` предназначена для удаления данных, используя первичный ключ (свойство идентификатора).

 <a name="Android_App" />

## <a name="android-app"></a>Приложение Android

Полный проект Xamarin.Android показанные на рисунке ниже:

 ![](case-study-tasky-images/taskyandroid-solution.png "Приведенное ниже проект Android")

Схема классов с классами, сгруппированные по слоя:

 [![](case-study-tasky-images/classdiagram-android.png "На схеме классов, с классами, сгруппированные по слоя")](case-study-tasky-images/classdiagram-android.png#lightbox)

 <a name="References" />

### <a name="references"></a>Ссылки

Проект приложения Android должно ссылаться на сборку Xamarin.Android платформы, доступа к классам, из пакета SDK для Android.

Он также должен ссылаться на проект переносимой библиотеки Классов (например) TaskyPortableLibrary) для доступа к коду общих данных и бизнес-уровня.

 ![](case-study-tasky-images/taskyandroid-references.png "TaskyPortableLibrary для доступа к коду общих данных и бизнес-слой")

 <a name="Application_Layer_(AL)" />

### <a name="application-layer-al"></a>Уровень приложений (п.)

Подобно версию iOS, которую мы рассмотрели ранее, уровень приложения в Android версии содержит классы платформы, необходимый для привязки объектами, предоставляемыми ядер и пользовательского интерфейса.

 **TaskListAdapter** — для отображения списка<T> объектов, нам нужно реализовать адаптер для отображения пользовательских объектов в `ListView`. Адаптер определяет, какой макет используется для каждого элемента в списке — в этом случае код использует встроенные макета Android `SimpleListItemChecked`.

 <a name="User_Interface_(UI)" />

### <a name="user-interface-ui"></a>Пользовательский интерфейс (UI)

Слой пользовательского интерфейса приложения Android представляет собой сочетание кода и разметки XML.

 -   **Ресурсы и макет** — макеты экрана и строки ячейки проектирования, реализованы в виде файлов AXML. AXML может быть вручную записи или размещенным визуально с помощью конструктора пользовательского интерфейса Xamarin для Android.
 -   **Ресурсы/Drawable** — изображения (значки) и настраиваемой кнопки.
 -   **Экраны** – подклассы действия, которые определяют каждый экран и его поведение. Объединяет интерфейса с помощью классов уровня приложений и распространенных API (`TaskItemManager`).

 <a name="Home_Screen" />

#### <a name="home-screen"></a>Начальный экран

Начального экрана состоит из подкласса действия `HomeScreen` и `HomeScreen.axml` файл, который определяет макет (положение кнопки и список задач). Этот экран выглядит следующим образом:

 [![](case-study-tasky-images/android-taskylist.png "Этот экран выглядит следующим образом")](case-study-tasky-images/android-taskylist.png#lightbox)

Код начального экрана определяет обработчики для кнопки и выборе элементов в списке, а также заполнение списка в `OnResume` метод (так что он отражает изменения, внесенные на экране сведений задачи). Данные загружаются с помощью бизнес-слой `TaskItemManager` и `TaskListAdapter` из прикладного уровня.

 <a name="Task_Details_Screen" />

#### <a name="task-details-screen"></a>Экран сведений задачи

На экране сведений задач также состоит из `Activity` подкласс и файлом макета AXML. Макет определяет расположение элементов управления вводом и C# класс определяет поведение для загрузки и сохранения `TaskItem` объектов.

 [![](case-study-tasky-images/android-taskydetail.png "Этот класс определяет поведение для загрузки и сохранения объектов TaskItem")](case-study-tasky-images/android-taskydetail.png#lightbox)

Все ссылки на библиотеки PCL будут через `TaskItemManager` класса.

 <a name="Windows_Phone_App" />

## <a name="windows-phone-app"></a>Приложения Windows Phone
Полный проект Windows Phone:

 ![](case-study-tasky-images/taskywp7-solution.png "Приложения Windows Phone полный проект Windows Phone")

На следующей схеме представлен классы, сгруппированные в слои.

 [![](case-study-tasky-images/classdiagram-wp7.png "На этой схеме представляет классы, сгруппированные в слои")](case-study-tasky-images/classdiagram-wp7.png#lightbox)

 <a name="References" />

### <a name="references"></a>Ссылки

Проекта под конкретную платформу должна ссылаться на необходимые библиотеки для конкретных платформ (таких как `Microsoft.Phone` и `System.Windows`) для создания является приложением Windows Phone.

Он также должен ссылаться на проект переносимой библиотеки Классов (например) `TaskyPortableLibrary`) для использования `TaskItem` класса и базы данных.

 ![](case-study-tasky-images/taskywp7-references.png "TaskyPortableLibrary использовать класс TaskItem и базы данных")

 <a name="Application_Layer_(AL)" />

### <a name="application-layer-al"></a>Уровень приложений (п.)

Опять же как и в версии для iOS и Android, на уровне приложения состоит из элементов невизуальный, которые помогут выполнить привязку данных к пользовательскому интерфейсу.

 <a name="ViewModels" />

#### <a name="viewmodels"></a>Модели представлений

ViewModels перенос данных из библиотеки PCL ( `TaskItemManager`) и предоставляет их так, может быть поглощен привязка данных Silverlight и XAML. Это пример поведения для конкретных платформ (как описано в документе кросс-платформенных приложений).

 <a name="User_Interface_(UI)" />

### <a name="user-interface-ui"></a>Пользовательский интерфейс (UI)

XAML имеет уникальные возможности привязки данных, который может быть объявлен в разметке и сократить объем кода, необходимого для отображения объектов.

1.   **Страницы** – файлы XAML и их фонового кода определения пользовательского интерфейса и ссылки на модели ViewModel и проект переносимой библиотеки Классов для отображения и сбора данных.
2.   **Образы** — экран, фона и значок изображения заставки являются важнейшим элементом пользовательского интерфейса.

 <a name="MainPage" />

#### <a name="mainpage"></a>MainPage

Использует класс MainPage `TaskListViewModel` для отображения данных с помощью средства связывания с данными в XAML. Страницы `DataContext` присваивается модели представления, которое заполняется асинхронно. `{Binding}` Синтаксиса в XAML определяет способ отображения данных.

 <a name="TaskDetailsPage" />

#### <a name="taskdetailspage"></a>TaskDetailsPage

Каждая задача отображаются путем привязки `TaskViewModel` для XAML, определенных в TaskDetailsPage.xaml. Задача данные извлекаются с помощью `TaskItemManager` на бизнес-уровне.

 <a name="Results" />

## <a name="results"></a>Результаты

Получающиеся приложения вид на каждой платформе:

 <a name="iOS" />

#### <a name="ios"></a>iOS

Приложение использует iOS стандарт пользовательского интерфейса, например кнопка «Добавить» расположенный на панели навигации и встроенного **плюс (+)** значок. Он также использует значение по умолчанию `UINavigationController` «назад» и нажмите кнопку поведение поддерживает «считывание delete» в таблице.

 [![](case-study-tasky-images/ios-taskylist.png "Он также использует UINavigationController кнопки \"Назад\" по умолчанию и поддерживает проведите для удаления в таблице")](case-study-tasky-images/ios-taskylist.png#lightbox) [![](case-study-tasky-images/ios-taskylist.png "она также использует значение по умолчанию UINavigationController резервное поведение кнопки и поддерживает проведите для удаления в таблице")](case-study-tasky-images/ios-taskylist.png#lightbox)

 <a name="Android" />

#### <a name="android"></a>Android

Приложение Android использует встроенные элементы управления, включая встроенные макета для строк, которые требуют «tick» отображается. Помимо кнопки на экране возврата поддерживается назад работы оборудования или системы.

 [![](case-study-tasky-images/android-taskylist.png "Помимо кнопки на экране возврата поддерживается назад работы оборудования или системы")](case-study-tasky-images/android-taskylist.png#lightbox)[![](case-study-tasky-images/android-taskylist.png "назад работы оборудования или системы поддерживается в дополнение к инструкциям на экране Кнопка \"Назад\"")](case-study-tasky-images/android-taskylist.png#lightbox)

 <a name="Windows_Phone" />

#### <a name="windows-phone"></a>Windows Phone

Приложение Windows Phone использует стандартный макет, заполнение в нижней части экрана вместо панели навигации в верхней панели приложения.

 [![](case-study-tasky-images/wp-taskylist.png "Приложения Windows Phone использует стандартный макет, заполнение панели приложения в нижней части экрана, а не панели навигации в верхней")](case-study-tasky-images/wp-taskylist.png#lightbox) [![](case-study-tasky-images/wp-taskylist.png "приложения Windows Phone использует стандарт макет, заполнение панели приложения в нижней части экрана, а не панели навигации в верхней")](case-study-tasky-images/wp-taskylist.png#lightbox)

 <a name="Summary" />

## <a name="summary"></a>Сводка

Этот документ предоставляет подробное описание применения принципов разработки многоуровневого приложения для простого приложения для облегчения повторного использования кода три мобильных платформ: iOS, Android и Windows Phone.

Он процесс, используемый при создании уровни приложений были рассмотрены какие кода &amp; функциональность была реализована в каждом слое.

Код можно загрузить из [github](https://github.com/xamarin/mobile-samples/tree/master/TaskyPortable).

## <a name="related-links"></a>Связанные ссылки

- [Создание кросс-платформенных приложений (основной документ)](~/cross-platform/app-fundamentals/building-cross-platform-applications/index.md)
- [Tasky переносимого пример приложения (github)](https://github.com/xamarin/mobile-samples/tree/master/TaskyPortable)
