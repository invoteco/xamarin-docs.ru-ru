---
title: Часть 4. Работа с несколькими платформами
description: В этом документе описывается, как выполнять расхождение приложений на основе платформы или возможности. В нем рассматриваются размер экрана, метафоры навигации, касания и жесты, Push-уведомления и парадигмы интерфейса, такие как списки и вкладки.
ms.prod: xamarin
ms.assetid: BBE47BA8-78BC-6A2B-63BA-D1A45CB1D3A5
author: davidortinau
ms.author: daortin
ms.date: 03/23/2017
ms.openlocfilehash: c8b4dcbfbf65bc4059125404b0d20ed35fa31f29
ms.sourcegitcommit: ce4670de51e24116a944c778ee64585bd0aae0e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2020
ms.locfileid: "79088924"
---
# <a name="part-4---dealing-with-multiple-platforms"></a>Часть 4. Работа с несколькими платформами

## <a name="handling-platform-divergence-amp-features"></a>Обработка &amp; функций расхождения платформы

Расхождение — это не просто кросс-платформенная задача; устройства на одинаковой платформе имеют различные возможности (особенно разнообразные доступные устройства Android). Наиболее очевидный и базовый — это размер экрана, но другие атрибуты устройства могут различаться, и для них требуется приложение для проверки определенных возможностей и поведения по-разному в зависимости от их присутствия (или отсутствия).

Это означает, что все приложения должны работать с плавной замедлением функциональности или в другом случае представлять непривлекательный набор функций в наименьшей части. Глубокая интеграция Xamarin с собственными пакетами SDK для каждой платформы позволяет приложениям использовать преимущества функций платформы, поэтому имеет смысл проектировать приложения для использования этих функций.

Общие сведения о различиях в функциональности платформ см. в документации по возможностям платформы.

## <a name="examples-of-platform-divergence"></a>Примеры расхождения платформы

### <a name="fundamental-elements-that-exist-across-platforms"></a>Фундаментальные элементы, существующие на разных платформах

Существуют некоторые характеристики мобильных приложений, которые являются универсальными.
Это основные понятия более высокого уровня, которые обычно справедливы для всех устройств и поэтому могут быть основанными на проектировании приложения:

- Выбор компонентов с помощью вкладок или меню
- Списки данных и прокрутка
- Одиночные представления данных
- Изменение одиночных представлений данных
- Переход назад

При проектировании высокоуровневого потока экрана вы можете создать общий пользовательский интерфейс для этих концепций.

### <a name="platform-specific-attributes"></a>Атрибуты, зависящие от платформы

В дополнение к основным элементам, которые существуют на всех платформах, необходимо учитывать ключевые отличия платформы в структуре. Вам может потребоваться рассмотреть следующие различия (и написать код, предназначенный специально для управления):

- **Размеры экрана** . Некоторые платформы (например, iOS и более ранние Windows Phone версии) имеют стандартизированные размеры экрана, которые относительно просты в использовании. Устройства Android имеют большое разнообразие размеров экрана, что требует больше усилий для поддержки в приложении.
- **Метафоры навигации** — различаются на разных платформах (например, аппаратная кнопка "назад", панорамный элемент управления ИП и на платформах (Android 2 и 4, iPhone и iPad).
- **Клавиатуры** — некоторые устройства Android имеют физические клавиатуры, а другие — только программную клавиатуру. Код, определяющий, когда на экране скрывается экранная клавиатура, должен быть конфиденциальным для этих различий.
- **Касание и жесты** — поддержка операционной системы для распознавания жестов зависит от более ранних версий каждой операционной системы. Более ранние версии Android имеют очень ограниченную поддержку сенсорных операций, то есть для поддержки старых устройств может потребоваться отдельный код.
- **Push-уведомления** . на каждой платформе существуют различные возможности и реализации (например, Живые плитки в Windows).

### <a name="device-specific-features"></a>Функции для конкретных устройств

Определите, какие минимальные функции должны быть необходимы для приложения. или, если вы решите, какие дополнительные функции следует использовать на каждой платформе. Код будет необходим для обнаружения компонентов и отключения функциональных возможностей или вариантов предложения (например, альтернативой географического расположения может быть предоставление пользователю права на ввод расположения или выбор из схемы.

- **Камера** — функциональные возможности различаются на разных устройствах. на некоторых устройствах нет камеры, а у других есть как внешние, так и задние камеры. Некоторые камеры поддерживают запись видео.
- **Географическое расположение & Maps** : Поддержка расположения GPS или Wi-Fi отсутствует на всех устройствах. Приложениям также необходимо ориентироваться на различные уровни точности, поддерживаемые каждым методом.
- **Акселерометр, гироскопом и компас** — эти функции часто встречаются только в наборе устройств на каждой платформе, поэтому приложения почти всегда должны предоставлять резервную версию, если оборудование не поддерживается.
- **Twitter и Facebook** — только встроенные в iOS5 и IOS6 соответственно. В более ранних версиях и других платформах необходимо предоставить собственные функции проверки подлинности и интерфейс непосредственно с помощью API каждого из служб.
- Радиочастотная **связь ближнего действия (NFC)** — только на (некоторых) телефонах Android (во время записи).

## <a name="dealing-with-platform-divergence"></a>Работа с расхождением платформы

Существует два разных подхода к поддержке нескольких платформ из одной базы кода, каждая из которых имеет собственный набор преимуществ и недостатков.

- **Абстракция платформы** — шаблон бизнес-фасадной предоставляет унифицированный доступ на различных платформах и абстрагирует определенные реализации платформы в единый единый API.
- **Разные реализации** — вызов конкретных функций платформы через разные реализации через средства архитектуры, такие как интерфейсы и наследование или условная компиляция.

## <a name="platform-abstraction"></a>Абстракция платформы

### <a name="class-abstraction"></a>Абстракция класса

Использование либо интерфейсов, либо базовых классов, определенных в общем коде и реализованных или расширенных в проектах для конкретных платформ. Написание и расширение общего кода с помощью абстракций класса особенно подходит для переносимых библиотек классов, так как они имеют ограниченный набор доступных для них платформ и не могут содержать директивы компилятора для поддержки ветвей кода, зависящих от платформы.

#### <a name="interfaces"></a>Интерфейсы

Использование интерфейсов позволяет реализовать классы для конкретных платформ, которые по-прежнему можно передавать в общие библиотеки для использования преимуществ общего кода.

Интерфейс определяется в общем коде и передается в общую библиотеку в качестве параметра или свойства.

Приложения, зависящие от платформы, могут реализовать интерфейс и по-прежнему использовать преимущества общего кода для "обработки".

 **Преимущества**

Реализация может содержать код, зависящий от платформы, и даже ссылки на внешние библиотеки, относящиеся к платформе.

 **Недостатки**

Создание и передача реализаций в общий код. Если интерфейс используется в общем коде в полном объеме, он передается через несколько параметров метода или отрывается через цепочку вызовов. Если общий код использует множество различных интерфейсов, все они должны быть созданы и заданы в общем коде в любом месте.

#### <a name="inheritance"></a>Наследование

Общий код может реализовывать абстрактные или виртуальные классы, которые можно расширить в одном или нескольких проектах для конкретной платформы. Это похоже на использование интерфейсов, но с определенным поведением уже реализовано. Существует несколько точек зрения на то, лучше ли использовать интерфейсы или наследование. в частности, это C# обусловлено тем, что позволяет использовать только одиночное наследование, которое может определять способ разработки API. Используйте наследование с осторожностью.

Преимущества и недостатки интерфейсов применяются одинаково к наследованию, при этом дополнительное преимущество заключается в том, что базовый класс может содержать некоторый код реализации (например, всю независимую от платформы реализацию, которую можно дополнительно расширить).

## <a name="xamarinforms"></a>Xamarin.Forms

См. документацию по [Xamarin. Forms](~/get-started/index.yml) .

### <a name="other-cross-platform-libraries"></a>Другие межплатформенные библиотеки

Эти библиотеки также предлагают межплатформенные функции для C# разработчиков:

- [**Xamarin. Essentials**](~/essentials/index.md) — межплатформенные API для общих функций.
- [**SkiaSharp**](~/xamarin-forms/user-interface/graphics/skiasharp/index.md) — 2D-графика на разных платформах.

## <a name="conditional-compilation"></a>Условная компиляция

В некоторых ситуациях, когда общий код все еще должен работать на каждой платформе по-разному, возможно, доступ к классам или функциям, которые ведут себя иначе. Условная компиляция лучше подходит для проектов общих ресурсов, где один и тот же исходный файл упоминается в нескольких проектах, имеющих разные определенные символы.

Проекты Xamarin всегда определяют `__MOBILE__`, которые справедливы для проектов приложений iOS и Android (Обратите внимание на символы двойной подчеркивания перед этими символами).

```csharp
#if __MOBILE__
// Xamarin iOS or Android-specific code
#endif
```

#### <a name="ios"></a>iOS

Xamarin. iOS определяет `__IOS__`, которые можно использовать для обнаружения устройств iOS.

```csharp
#if __IOS__
// iOS-specific code
#endif
```

Существуют также символы, относящиеся к просмотру и ТЕЛЕВИЗОРу:

```csharp
#if __TVOS__
// tv-specific stuff
#endif

#if __WATCHOS__
// watch-specific stuff
#endif
```

#### <a name="android"></a>Android

Код, который должен быть скомпилирован только в приложения Xamarin. Android, может использовать следующие

```csharp
#if __ANDROID__
// Android-specific code
#endif
```

Каждая версия API также определяет новую директиву компилятора, поэтому код, подобный, позволяет добавлять функции, если целевые API предназначены для более новых версий. Каждый уровень API включает все символы нижнего уровня. Эта функция не очень полезна для поддержки нескольких платформ. обычно будет достаточно `__ANDROID__` символа.

```csharp
#if __ANDROID_11__
// code that should only run on Android 3.0 Honeycomb or newer
#endif
```

#### <a name="mac"></a>Mac

Xamarin. Mac определяет `__MACOS__`, которые можно использовать для компиляции только для macOS:

```csharp
#if __MACOS__
// macOS-specific code
#endif
```

#### <a name="universal-windows-platform-uwp"></a>Универсальная платформа Windows (UWP)

Используйте `WINDOWS_UWP`. Нет подчеркивания вокруг строки, подобной символам платформы Xamarin.

```csharp
#if WINDOWS_UWP
// UWP-specific code
#endif
```

#### <a name="using-conditional-compilation"></a>Использование условной компиляции

Простой пример использования условной компиляции — Задание расположения файла для файла базы данных SQLite. Три платформы имеют несколько различных требований для указания расположения файла:

- **iOS** — Apple предпочитает размещение данных, не являющихся пользователями, в определенном расположении (каталоге библиотеки), но для этого каталога отсутствует системная константа. Для создания правильного пути требуется код, зависящий от платформы.
- **Android** — системный путь, возвращаемый `Environment.SpecialFolder.Personal`, является приемлемым расположением для хранения файла базы данных.
- **Windows Phone** — механизм изолированного хранилища не позволяет указать полный путь, просто относительный путь и имя файла.
- **Универсальная платформа Windows** — использует `Windows.Storage` API.

В следующем коде используется условная компиляция, чтобы гарантировать правильность `DatabaseFilePath` для каждой платформы:

```csharp
public static string DatabaseFilePath
{
    get
    {
        var filename = "TodoDatabase.db3";
#if SILVERLIGHT
        // Windows Phone 8
        var path = filename;
#else

#if __ANDROID__
        string libraryPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal);
#else
#if __IOS__
        // we need to put in /Library/ on iOS5.1 to meet Apple's iCloud terms
        // (they don't want non-user-generated data in Documents)
        string documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
        string libraryPath = Path.Combine (documentsPath, "..", "Library");
#else
        // UWP
        string libraryPath = Windows.Storage.ApplicationData.Current.LocalFolder.Path;
#endif
#endif
        var path = Path.Combine(libraryPath, filename);
#endif
        return path;
    }
}
```

Результатом является класс, который можно построить и использовать на всех платформах, поместив файл базы данных SQLite в другое место на каждой платформе.
