---
ms.assetid: 1BB412D1-FC3D-4E69-8B01-B976A3DB6328
title: 'WPF и Xamarin. Forms: сходства & различия'
description: В этом документе сравнивается и противопоставляется WPF и Xamarin. Forms. В нем обсуждаются шаблоны элементов управления, XAML, инфраструктура привязки, шаблоны данных, ItemsControl, UserControl, Навигация и Навигация по URL-адресам.
author: davidortinau
ms.author: daortin
ms.date: 04/26/2017
ms.openlocfilehash: 798839457a418d457bac83e6e20397722423dbac
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73016490"
---
# <a name="wpf-vs-xamarinforms-similarities--differences"></a>WPF и Xamarin. Forms: сходства & различия

## <a name="control-templates"></a>Шаблоны элементов управления

WPF поддерживает концепцию *шаблонов элементов управления* , предоставляющих инструкции по визуализации для элемента управления (`Button`, `ListBox` и т. д.). Как упоминалось выше, Xamarin. Forms использует конкретные классы _отрисовки_ , которые взаимодействуют с собственной платформой (iOS, Android и т. д.) для визуализации элемента управления.

Однако Xamarin _. Forms имеет тип_ `ControlTemplate` — он используется для объектов `Page`. Он предоставляет определение для `Page`, которое обеспечивает единообразное содержимое, но позволяет пользователю страницы изменять цвета, шрифты и т. д. и даже добавлять элементы, чтобы сделать их уникальными для приложения.

В частности, это такие вещи, как диалоговые окна проверки подлинности, запросы и предоставление стандартизованных возможностей, но их внешний вид и поведение страницы могут быть настроены в приложении. В рамках этой поддержки используются многие знакомые элементы управления WPF с именами:

1. `ContentPage`
2. `ContentView`
3. `ContentPresenter`
4. `TemplateBinding`

Но важно помнить, что в Xamarin. Forms _не_ используются одинаковые цели. Дополнительные сведения об этой функции см. на [странице документации](~/xamarin-forms/app-fundamentals/templates/control-templates/index.md).

## <a name="xaml"></a>XAML

XAML используется в качестве языка декларативной разметки для WPF и Xamarin. Forms. В большинстве случаев синтаксис идентичен, а основное различие — это объекты, определенные или созданные графами XAML.

- Xamarin. Forms поддерживает [спецификацию XAML 2009](/dotnet/framework/xaml-services/xaml-2009-language-features/); Это упрощает определение таких данных, как `string`s, `int`s и т. д., а также определение универсальных типов и передачу аргументов в конструкторы.

- В настоящее время невозможно динамически загружать XAML, например WPF, с `XamlReader`. Тем не менее, можно получить те же базовые функции с [пакетом NuGet](https://www.nuget.org/packages/Xamarin.Forms.Dynamic/) .

### <a name="markup-extensions"></a>Расширения разметки

Xamarin. Forms поддерживает расширение XAML с помощью расширений разметки, подобно WPF. В этом окне есть те же основные стандартные блоки:

1. `{x:Array}`
2. `{Binding}`
3. `{DynamicResource}`
4. `{x:Null}`
5. `{x:Static}`
6. `{StaticResource}`
7. `{x:Type}`

Кроме того, он включает `{x:Reference}` из спецификации XAML 2009 и расширение разметки `{TemplateBinding}`, которое используется для специализированной версии `ControlTemplate`, поддерживаемой Xamarin. Forms.

> [!WARNING]
> Поддержка `ControlTemplate` не одинакова, даже если она имеет то же имя.

Xamarin. Forms поддерживает пользовательские расширения разметки, но реализация немного отличается. В WPF необходимо наследовать от `MarkupExtension` — абстрактного базового класса. В Xamarin. Forms, который заменяется интерфейсом `IMarkupExtension` или `IMarkupExtension<T>` который является более гибким.

Как и WPF, единственным необходимым методом является `ProvideValue` метод, который возвращает значение из расширения разметки.

## <a name="binding-infrastructure"></a>Инфраструктура привязки

Одним из основных концепций, которые переносятся, является инфраструктура привязки данных для подключения визуальных свойств к свойствам данных .NET. Это позволяет создавать архитектурные шаблоны, такие как MVVM. Базовая схема идентична — у вас есть связываемый базовый класс [bindableobject](xref:Xamarin.Forms.BindableObject), в WPF это класс [DependencyObject](xref:System.Windows.DependencyObject) . Этот базовый класс используется в качестве корневого предка для всех объектов, которые будут участвовать в качестве целевых объектов в привязке данных. Затем производные классы предоставляют объекты [биндаблепроперти](xref:Xamarin.Forms.BindableProperty) , которые действуют как резервное хранилище для значений свойств (они определены как объекты [DependencyProperty](xref:System.Windows.DependencyProperty) в WPF).

### <a name="defining-bindable-properties"></a>Определение свойств, допускающих привязку

Определение свойства, которое может быть привязано в Xamarin. Forms, аналогично WPF:

1. Объект должен быть производным от `BindableObject`.
2. Для определения резервного ключа хранилища для свойства должно быть открыто статическое поле типа `BindableProperty`, объявленное как.
3. Должна быть общедоступная оболочка свойств экземпляра, использующая `GetValue` и `SetValue` для получения и изменения значения свойств.

Полный пример см. в разделе [свойства, допускающие привязку в Xamarin. Forms](~/xamarin-forms/xaml/bindable-properties.md).

### <a name="attached-properties"></a>Вложенные свойства

Вложенные свойства являются подмножеством привязываемого свойства, и они работают так же, как и в WPF. Основное отличие состоит в том, что в этом случае оболочка свойств пропущен и заменяется набором статических методов Get/Set для класса-владельца. Дополнительные сведения см. [в разделе вложенные свойства в Xamarin. Forms](~/xamarin-forms/xaml/attached-properties.md) .

### <a name="using-the-binding-engine"></a>Использование механизма привязки

Процесс использования механизма привязки такой же, как и в WPF. Его можно использовать в коде программной части путем создания объекта `Binding`, привязанного к исходному объекту (любой тип .NET), и необязательного значения свойства (если пропущен, он рассматривает исходный объект как само свойство, как WPF). Затем можно использовать `SetBinding` на любом `BindableObject`, чтобы связать привязку с `BindableProperty`.

Также можно определить связь привязки в XAML с помощью `BindingExtension`. Он имеет те же базовые значения, что и расширение в WPF.

Поддержка и механизм привязки более похожи на реализацию Silverlight, чем WPF. Существует несколько отсутствующих функций, которые не были реализованы в Xamarin. Forms:

- В привязках отсутствует поддержка следующих функций:
  - биндингграупнаме
  - биндсдиректлитосаурце
  - IsAsync
  - MultiBinding
  - нотифйонсаурцеупдатед
  - нотифйонтаржетупдатед
  - нотифйонвалидатионеррор
  - UpdateSourceTrigger
  - упдатесаурцеексцептионфилтер
  - ValidatesOnDataErrors
  - ValidatesOnExceptions
  - Коллекция ValidationRules
  - XPath
  - XmlNamespaceManager

#### <a name="relativesource"></a>RelativeSource

Привязки `RelativeSource` не поддерживаются. В WPF они позволяют выполнять привязку к другим визуальным элементам, определенным в XAML. В Xamarin. Forms такая же возможность может быть достигнута с помощью расширения разметки `{x:Reference}`. Например, если у нас есть элемент управления с именем «Осерконтрол», имеющий свойство Text, можно выполнить привязку к нему следующим образом:

**WPF**

```xaml
Text={Binding RelativeSource={RelativeSource otherControl}, Path=Text}
```

**Xamarin.Forms**

```xaml
Text={Binding Source={x:Reference otherControl}, Path=Text}
```

Ту же возможность можно использовать для функции `{RelativeSource Self}`. Однако не поддерживается Поиск предков по типу (`{RelativeSource FindAncestor}`).

#### <a name="binding-context"></a>Контекст привязки

В WPF можно определить `DataContext` значение свойства, репрентс источник привязки по умолчанию. Если источник привязки не определен, используется значение этого свойства. Значение наследуется вниз по визуальному дереву, что позволяет определить его на более высоком уровне, а затем использовать в дочерних элементах.

В Xamarin. Forms Эта функция доступных, но имя свойства `BindingContext`.

#### <a name="value-converters"></a>преобразователи значений;

Преобразователи значений полностью поддерживаются в Xamarin. Forms, как и WPF. Используется та же форма интерфейса, но Xamarin. Forms имеет интерфейс, определенный в `Xamarin.Forms` пространстве имен.

### <a name="model-view-viewmodel"></a>Модель-представление-ViewModel

MVVM полностью поддерживается как WPF, так и Xamarin. Forms.

WPF включает встроенный `RoutedCommand`, который иногда используется; В Xamarin. Forms отсутствует встроенная поддержка команд за пределами определения интерфейса `ICommand`. Можно включить разнообразные платформы MVVM, чтобы добавить необходимые базовые классы для реализации MVVM.

#### <a name="inotifypropertychanged-and-inotifycollectionchanged"></a>INotifyPropertyChanged и INotifyCollectionChanged

Оба интерфейса поддерживаются в привязках Xamarin. Forms полностью. В отличие от многих платформ на основе XAML, уведомления об изменении свойств могут создаваться в фоновых потоках в Xamarin. Forms (так же, как WPF), а механизм привязки будет правильно переходить в поток пользовательского интерфейса.

Кроме того, обе среды поддерживают `SynchronziationContext` и `async` / `await` для обеспечения надлежащего маршалинга потоков. WPF включает класс `Dispatcher` для всех визуальных элементов, в Xamarin. Forms есть статический метод `Device.BeginInvokeOnMainThread` который также можно использовать (хотя `SynchronizationContext` является предпочтительным для кросс-платформенного программирования).

- Xamarin. Forms включает `ObservableCollection<T>`, который поддерживает уведомления об изменениях коллекции.
- Для включения межпотоковых обновлений для коллекции можно использовать `BindingBase.EnableCollectionSynchronization`. API немного отличается от вариации WPF, [Проверьте документацию на наличие сведений об использовании](xref:Xamarin.Forms.BindingBase.EnableCollectionSynchronization*).

## <a name="data-templates"></a>Шаблоны данных

Шаблоны данных поддерживаются в Xamarin. Forms для настройки отрисовки `ListView` строки (ячейки). В отличие от WPF, который может использовать `DataTemplate`s для любого элемента управления, ориентированного на содержимое, Xamarin. Forms в настоящее время использует их только для `ListView`. Определение шаблона может быть определено как встроенное (назначенное свойству `ItemTemplate`) или как ресурс в `ResourceDictionary`.

Кроме того, они не так гибкие, как аналоги WPF.

1. Корневой элемент `DataTemplate` _всегда_ должен быть `ViewCell`ным объектом.
2. Триггеры данных полностью поддерживаются в шаблоне данных, но должны включать свойство `DataType`, указывающее тип свойства, с которым связан триггер.
3. `DataTemplateSelector` также поддерживается, но является производным от `DataTemplate` и поэтому просто назначается непосредственно свойству `ItemTemplate` (VS.  `ItemTemplateSelector` в WPF).

## <a name="itemscontrol"></a>ItemsControl

В Xamarin. Forms нет встроенного эквивалента `ItemsControl`. но [для Xamarin. Forms доступен пользовательский](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Controls/ItemsControl.cs)элемент.

## <a name="user-controls"></a>Пользовательские элементы управления

В WPF `UserControl`s используются для предоставления раздела пользовательского интерфейса с соответствующим поведением. В Xamarin. Forms для той же цели используется `ContentView`. Поддерживаются привязка и включение в XAML.

## <a name="navigation"></a>Навигация

WPF содержит редко используемые `NavigationService`, которые можно использовать для предоставления функции навигации, похожей на браузер. В большинстве приложений это не потребовалось, но вместо этого использовались разные элементы `Window` или различные разделы окна для вывода данных.

На телефонных устройствах часто используется несколько _экранов_ , поэтому в Xamarin. Forms предусмотрена поддержка нескольких форм навигации:

| Стиль навигации | Тип страницы |
|--- |--- |
|На основе стека (принудительная или POP)|NavigationPage|
|Основной/подробности|MasterDetailPage|
|Вкладки|TabbedPage|
|Прокрутка влево/вправо|карауселвиев|

`NavigationPage` является наиболее распространенным подходом, и каждая страница имеет свойство `Navigation`, которое можно использовать для отправки или POP-страниц в стеке навигации. Это ближайший эквивалент `NavigationService`, найденный в WPF.

### <a name="url-navigation"></a>Навигация по URL-адресу

WPF — это технология, ориентированная на настольную систему, и может принимать параметры командной строки для направления поведения при запуске. Xamarin. Forms может использовать [углубленную компоновку URL-адресов](https://blog.xamarin.com/deep-link-content-with-xamarin-forms-url-navigation/) для перехода на страницу при запуске.
