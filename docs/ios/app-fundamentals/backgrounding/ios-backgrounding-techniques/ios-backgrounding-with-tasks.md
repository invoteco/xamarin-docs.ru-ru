---
title: Фоновая обработка в iOS с помощью задач
description: В этом документе описывается, как использовать фоновые задачи для выполнения длительных задач после размещения приложения в фоновом режиме.
ms.prod: xamarin
ms.assetid: 205D230E-C618-4D69-96EE-4B91D7819121
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 03/18/2017
ms.openlocfilehash: 7596f79119f28997cbcda6e7057e682edfd760b8
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70756349"
---
# <a name="ios-backgrounding-with-tasks"></a>Фоновая обработка в iOS с помощью задач

Самый простой способ выполнить фоновый режим в iOS — разбить требования к фоновому режиму на задачи и выполнить задачи в фоновом режиме. Задачи имеют ограниченный срок действия, и обычно получают около 600 секунд (10 минут) времени обработки после перемещения приложения в фоновый режим на iOS 6 и менее 10 минут в iOS 7 +.

Фоновые задачи можно разбить на три категории:

1. **Фоновые задачи** — вызываются в любом месте приложения, где имеется задача, которую вы не хотите прерывать, если приложение вводит фон.
1. **Задачи дидентербаккграунд** — вызываются во `DidEnterBackground` время выполнения метода жизненного цикла приложения, чтобы упростить очистку и сохранение состояния.
1. **Фоновая передача (iOS 7 +)** — особый тип фоновой задачи, используемой для передачи данных по сети в iOS 7. В отличие от обычных задач, фоновые передачи не имеют предварительно определенного предельного времени.

Безопасность в фоновом `DidEnterBackground` режиме и задачи можно использовать как в iOS 6, так и в iOS 7 с некоторыми незначительными отличиями. Рассмотрим эти два типа задач более подробно.

## <a name="creating-background-safe-tasks"></a>Создание безотносительной фоновых задач

Некоторые приложения содержат задачи, которые не должны прерываться системой iOS при изменении состояния приложения. Одним из способов защиты этих задач от прерывания является их регистрация в iOS в качестве длительно выполняемых задач. Этот шаблон можно использовать в любом месте приложения, где вы не хотите, чтобы задача была прервана, если пользователь поместил приложение в фоновом режиме. Отличным кандидатом для этого шаблона являются такие задачи, как отправка сведений о регистрации нового пользователя на сервер или проверка учетных данных.

В следующем фрагменте кода показано, как зарегистрировать задачу для выполнения в фоновом режиме.

```csharp
nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});

//runs on main or background thread
FinishLongRunningTask(taskID);

UIApplication.SharedApplication.EndBackgroundTask(taskID);
```

Процесс регистрации связывает задачу с уникальным идентификатором, `taskID`а затем заключает ее в соответствующие `BeginBackgroundTask` вызовы и `EndBackgroundTask` . Чтобы создать идентификатор, мы вызываем `BeginBackgroundTask` метод `UIApplication` для объекта, а затем запускаем долгосрочную задачу, обычно в новом потоке. После завершения задачи мы вызываем `EndBackgroundTask` и передаем тот же идентификатор. Это важно, так как iOS завершит работу приложения, если `BeginBackgroundTask` у вызова нет соответствующего `EndBackgroundTask`запроса.

> [!IMPORTANT]
> Фоновые задачи могут выполняться либо в основном потоке, либо в фоновом потоке в зависимости от потребностей приложения.

## <a name="performing-tasks-during-didenterbackground"></a>Выполнение задач во время Дидентербаккграунд

В дополнение к обеспечению долгосрочного обеспечения безопасности, можно использовать регистрацию для запуска задач при помещении приложения в фоновый режим. iOS предоставляет метод события в классе *AppDelegate* с именем `DidEnterBackground` , который может использоваться для сохранения состояния приложения, сохранения данных пользователя и шифрования конфиденциального содержимого до того, как приложение войдет в фоновый режим. Приложение имеет примерно пять секунд для возврата из этого метода, или оно будет завершено. Таким образом, задачи очистки, выполнение которых может занять более пяти секунд, могут быть вызваны внутри `DidEnterBackground` метода. Эти задачи должны вызываться в отдельном потоке.

Процесс практически идентичен процессу регистрации длительно выполняемой задачи. В следующем фрагменте кода это показано в действии:

```csharp
public override void DidEnterBackground (UIApplication application) {
  nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});
  new Task ( () => {
    DoWork();
    UIApplication.SharedApplication.EndBackgroundTask(taskID);
  }).Start();
}
```

Начнем с переопределения `DidEnterBackground` метода `AppDelegate`в, где мы регистрируем задачу с помощью `BeginBackgroundTask` , как мы делали в предыдущем примере. Затем мы порожден новый поток и выполним выполнение нашей длительной задачи. Обратите внимание `EndBackgroundTask` , что теперь вызов выполняется в долгосрочной задаче, `DidEnterBackground` так как метод уже будет возвращен.

> [!IMPORTANT]
> iOS использует [механизм наблюдения](https://developer.apple.com/library/ios/qa/qa1693/_index.html) , чтобы обеспечить реагирование пользовательского интерфейса приложения. Приложение, которое тратит слишком много времени `DidEnterBackground` , перестанет отвечать в пользовательском интерфейсе. Запуск задач в фоновом режиме позволяет `DidEnterBackground` своевременно возвращаться, сохраняя скорость реагирования пользовательского интерфейса и предотвращая прерывание работы устройства наблюдения.

## <a name="handling-background-task-time-limits"></a>Обработка ограничений времени для фоновых задач

iOS накладывает ограничения на длительность выполнения фоновой задачи, а если `EndBackgroundTask` вызов не выполняется в течение выделенного времени, приложение будет завершено. Отслеживая оставшееся время в фоновом режиме и использующих обработчики срока действия, можно избежать завершения работы приложения iOS.

### <a name="accessing-background-time-remaining"></a>Доступ к оставшееся время в фоновом режиме

Если приложение с зарегистрированными задачами перемещается в фоновый режим, для выполнения зарегистрированных задач потребуется около 600 секунд. Мы можем проверить, сколько времени задача должна завершиться с помощью свойства `BackgroundTimeRemaining` `UIApplication` static класса. Следующий код даст нам время в секундах, которое осталось в фоновой задаче:

```csharp
double timeRemaining = UIApplication.SharedApplication.BackgroundTimeRemaining;
```

### <a name="avoiding-app-termination-with-expiration-handlers"></a>Предотвращение завершения приложений с помощью обработчиков срока действия

Помимо предоставления доступа `BackgroundTimeRemaining` к свойству, iOS предоставляет некорректный способ обработки истечения срока действия в фоновом режиме через **обработчик срока действия**. Это необязательный блок кода, который будет выполнен, когда истечет время, выделенное для задачи. Код в обработчике истечения `EndBackgroundTask` срока действия вызывает и передает идентификатор задачи, что означает, что приложение хорошо работает и не может завершить работу приложения iOS, даже если задача завершается неоднократно. `EndBackgroundTask`должен вызываться в обработчике срока действия, а также в нормальном процессе выполнения. 

Обработчик истечения срока действия выражается в виде анонимной функции с помощью лямбда-выражения, как показано ниже:

```csharp
Task.Factory.StartNew( () => {

    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask(() => {
        Console.WriteLine("Exhausted time");
        UIApplication.SharedApplication.EndBackgroundTask(taskId); 
    });
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.BackgroundTimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});
```

Хотя обработчики срока действия не требуются для выполнения кода, следует всегда использовать обработчик срока действия с фоновой задачей.

 <a name="background_tasks_in_iOS_7" />

## <a name="background-tasks-in-ios-7"></a>Фоновые задачи в iOS 7 +

Крупнейшим изменением в iOS 7 в отношении фоновых задач является отличие от реализации задач, но при их запуске.

Вспомним, что до iOS 7 задача, выполняемая в фоновом режиме, составила 600 секунд. Одна из причин этого ограничения заключается в том, что задача, выполняемая в фоновом режиме, будет удерживать устройство в спящий режим в течение выполнения задачи:

 [![](ios-backgrounding-with-tasks-images/ios6.png "График задачи, которая сохраняет приложение в спящем режиме до 7")](ios-backgrounding-with-tasks-images/ios6.png#lightbox)

Фоновая обработка iOS 7 оптимизирована для более длительного времени работы от аккумулятора. В iOS 7 фоновый режим становится уступающей: вместо того чтобы поддерживать устройство в спящем режиме, задачи учитывают, когда устройство переходит в режим сна, а также выполняют обработку блоков, когда устройство выходит из спящего режима для обработки телефонных звонков, уведомлений, входящих сообщений электронной почты и других распространенные прерывания. На следующей схеме представлено представление о том, как может быть нарушена задача:

 [![](ios-backgrounding-with-tasks-images/ios7.png "График задачи, разбитой на блоки после iOS 7")](ios-backgrounding-with-tasks-images/ios7.png#lightbox)

Так как время выполнения задачи не превышает непрерывности, задачи, выполняющие передачу по сети, должны обрабатываться по-разному в iOS 7. Разработчикам рекомендуется использовать `NSURlSession` API для управления сетевыми передачами. В следующем разделе приводятся общие сведения о переносе в фоновом режиме.

 <a name="background-transfers" />

## <a name="background-transfers"></a>Фоновые передачи

Основой фоновой передачи данных в iOS 7 является новый `NSURLSession` API. `NSURLSession`позволяет создавать задачи для:

1. Переносите содержимое через прерывания сети и устройства.
1. Отправка и скачивание больших файлов ( *служба фоновой передачи* ).

Давайте подробнее рассмотрим, как это работает.

### <a name="nsurlsession-api"></a>API NSURLSession

 `NSURLSession`— мощный API для передачи содержимого по сети. Он предоставляет набор средств для обработки перемещения данных с помощью сетевых прерываний и изменений в состояниях приложений.

`NSURLSession` API-интерфейс создает один или несколько сеансов, которые, в свою очередь, порождают задачи для блоков списка выбора связанных данных по сети. Задачи выполняются асинхронно для быстрого и надежного обмена данными. Поскольку `NSURLSession` является асинхронным, для каждого сеанса требуется блок обработчика завершения, чтобы система и приложение могли получить сведения о завершении процесса перемещения.

Чтобы выполнить передачу по сети, допустимую как в предварительных, так и после iOS 7, проверьте, доступен ли `NSURLSession` объект для передачи в очередь, и используйте обычную фоновую задачу для выполнения переноса, если это не так:

```csharp
if ([NSURLSession class]) {
  // Create a background session and enqueue transfers
}
else {
  // Start a background task and transfer directly
  // Do NOT make calls to update the UI here!
}
```

> [!IMPORTANT]
> Избегайте вызовов для обновления пользовательского интерфейса из фона в коде, совместимом с iOS 6, так как iOS 6 не поддерживает фоновое обновление пользовательского интерфейса и завершит работу приложения.

`NSURLSession` API-интерфейс содержит обширный набор функций для обработки проверки подлинности, управления неудачными передачами и отчетов на стороне клиента, но не на стороне сервера. Она помогает организовать перерывы во время выполнения задач, появившиеся в iOS 7, а также обеспечивает быструю и надежную передачу больших файлов. В следующем разделе рассматривается эта вторая функция.

### <a name="background-transfer-service"></a>Служба фоновой пересылки

До iOS 7 Загрузка или скачивание файлов в фоновом режиме была ненадежной. Фоновые задачи получают ограниченное время, но время, необходимое для перемещения файла, зависит от сети и размера файла. В iOS 7 можно использовать `NSURLSession` для успешной отправки и загрузки больших файлов. Конкретный `NSURLSession` тип сеанса, обрабатывающий передачу данных по сети для больших файлов в фоновом режиме, называется *службой фоновой передачи*.

Передачи, инициированные с помощью службы фоновой передачи, управляются операционной системой и предоставляют интерфейсы API для управления проверкой подлинности и ошибками. Так как передачи не привязаны к произвольному ограничению времени, их можно использовать для отправки или скачивания больших файлов, автоматического обновления содержимого в фоновом режиме и выполнения других операций. Дополнительные сведения о реализации службы см. в этом [пошаговом руководстве по переносу в фоновом режиме](~/ios/app-fundamentals/backgrounding/ios-backgrounding-walkthroughs/background-transfer-walkthrough.md) .

Служба фоновой отправки часто объединяется с фоновым получением или удаленными уведомлениями, чтобы помочь приложениям обновлять содержимое в фоновом режиме. В следующих двух разделах мы рассмотрим концепцию регистрации целых приложений для выполнения в фоновом режиме на устройствах iOS 6 и iOS 7.
