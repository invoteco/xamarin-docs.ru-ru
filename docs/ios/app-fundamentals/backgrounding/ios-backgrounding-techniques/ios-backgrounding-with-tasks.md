---
title: Фоновая обработка в iOS с помощью задач
description: В этом документе описывается, как использовать фоновые задачи для выполнения длительных задач после размещения приложения в фоновом режиме.
ms.prod: xamarin
ms.assetid: 205D230E-C618-4D69-96EE-4B91D7819121
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/18/2017
ms.openlocfilehash: f39ab83e00db1abd6508d26a9280fb708e681445
ms.sourcegitcommit: eca3b01098dba004d367292c8b0d74b58c4e1206
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/13/2020
ms.locfileid: "79305795"
---
# <a name="ios-backgrounding-with-tasks"></a>Фоновая обработка в iOS с помощью задач

Самый простой способ выполнить фоновый режим в iOS — разбить требования к фоновому режиму на задачи и выполнить задачи в фоновом режиме. Задачи имеют ограниченный срок действия, и обычно получают около 600 секунд (10 минут) времени обработки после перемещения приложения в фоновый режим на iOS 6 и менее 10 минут в iOS 7 +.

Фоновые задачи можно разбить на три категории:

1. **Фоновые задачи** — вызываются в любом месте приложения, где имеется задача, которую вы не хотите прерывать, если приложение вводит фон.
1. **Задачи дидентербаккграунд** — вызываются во время `DidEnterBackground` метода жизненного цикла приложения для упрощения очистки и сохранения состояния.
1. **Фоновая передача (iOS 7 +)** — особый тип фоновой задачи, используемой для передачи данных по сети в iOS 7. В отличие от обычных задач, фоновые передачи не имеют предварительно определенного предельного времени.

Критические и `DidEnterBackground` задачи можно использовать в iOS 6 и iOS 7 с некоторыми незначительными отличиями. Рассмотрим эти два типа задач более подробно.

## <a name="creating-background-safe-tasks"></a>Создание безотносительной фоновых задач

Некоторые приложения содержат задачи, которые не должны прерываться системой iOS при изменении состояния приложения. Одним из способов защиты этих задач от прерывания является их регистрация в iOS в качестве длительно выполняемых задач. Этот шаблон можно использовать в любом месте приложения, где вы не хотите, чтобы задача была прервана, если пользователь поместил приложение в фоновом режиме. Отличным кандидатом для этого шаблона являются такие задачи, как отправка сведений о регистрации нового пользователя на сервер или проверка учетных данных.

В следующем фрагменте кода показано, как зарегистрировать задачу для выполнения в фоновом режиме.

```csharp
nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});

//runs on main or background thread
FinishLongRunningTask(taskID);

UIApplication.SharedApplication.EndBackgroundTask(taskID);
```

Процесс регистрации связывает задачу с уникальным идентификатором, `taskID`, а затем заключает ее в соответствующие вызовы `BeginBackgroundTask` и `EndBackgroundTask`. Чтобы создать идентификатор, необходимо вызвать метод `BeginBackgroundTask` для объекта `UIApplication`, а затем запустить долгосрочную задачу, обычно в новом потоке. После завершения задачи мы вызываем `EndBackgroundTask` и передаем тот же идентификатор. Это важно, так как iOS завершит работу приложения, если `BeginBackgroundTask` вызов не имеет соответствующего `EndBackgroundTask`.

> [!IMPORTANT]
> Фоновые задачи могут выполняться либо в основном потоке, либо в фоновом потоке в зависимости от потребностей приложения.

## <a name="performing-tasks-during-didenterbackground"></a>Выполнение задач во время Дидентербаккграунд

В дополнение к обеспечению долгосрочного обеспечения безопасности, можно использовать регистрацию для запуска задач при помещении приложения в фоновый режим. iOS предоставляет метод события в классе *AppDelegate* с именем `DidEnterBackground`, который можно использовать для сохранения состояния приложения, сохранения данных пользователя и шифрования конфиденциального содержимого до того, как приложение войдет в фон. Приложение имеет примерно пять секунд для возврата из этого метода, или оно будет завершено. Таким образом, задачи очистки, выполнение которых может занять более пяти секунд, могут быть вызваны внутри метода `DidEnterBackground`. Эти задачи должны вызываться в отдельном потоке.

Процесс практически идентичен процессу регистрации длительно выполняемой задачи. В следующем фрагменте кода это показано в действии:

```csharp
public override void DidEnterBackground (UIApplication application) {
  nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});
  new Task ( () => {
    DoWork();
    UIApplication.SharedApplication.EndBackgroundTask(taskID);
  }).Start();
}
```

Начнем с переопределения метода `DidEnterBackground` в `AppDelegate`, где мы регистрируем задачу с помощью `BeginBackgroundTask`, как мы делали в предыдущем примере. Затем мы порожден новый поток и выполним выполнение нашей длительной задачи. Обратите внимание, что `EndBackgroundTask` вызов теперь выполняется из длительной задачи, так как метод `DidEnterBackground` будет уже возвращен.

> [!IMPORTANT]
> iOS использует [механизм наблюдения](https://developer.apple.com/library/ios/qa/qa1693/_index.html) , чтобы обеспечить реагирование пользовательского интерфейса приложения. Приложение, которое тратит слишком много времени на `DidEnterBackground`, перестанет отвечать в пользовательском интерфейсе. Запуск задач в фоновом режиме позволяет `DidEnterBackground` своевременно возвращать, сохраняя скорость реагирования пользовательского интерфейса и предотвращая прерывание работы устройства наблюдения.

## <a name="handling-background-task-time-limits"></a>Обработка ограничений времени для фоновых задач

iOS накладывает ограничения на длительность выполнения фоновой задачи, а если `EndBackgroundTask` вызов не выполняется в течение отведенного времени, приложение будет завершено. Отслеживая оставшееся время в фоновом режиме и использующих обработчики срока действия, можно избежать завершения работы приложения iOS.

### <a name="accessing-background-time-remaining"></a>Доступ к оставшееся время в фоновом режиме

Если приложение с зарегистрированными задачами перемещается в фоновый режим, для выполнения зарегистрированных задач потребуется около 600 секунд. Можно проверить, сколько времени должна выполнить задача, используя статическое свойство `BackgroundTimeRemaining` класса `UIApplication`. Следующий код даст нам время в секундах, которое осталось в фоновой задаче:

```csharp
double timeRemaining = UIApplication.SharedApplication.BackgroundTimeRemaining;
```

### <a name="avoiding-app-termination-with-expiration-handlers"></a>Предотвращение завершения приложений с помощью обработчиков срока действия

Помимо предоставления доступа к свойству `BackgroundTimeRemaining`, iOS предоставляет некорректный способ обработки истечения срока действия в фоновом режиме через **обработчик срока действия**. Это необязательный блок кода, который будет выполнен, когда истечет время, выделенное для задачи. Код в обработчике срока действия вызывает `EndBackgroundTask` и передает идентификатор задачи, что означает, что приложение хорошо работает и не может завершить работу приложения iOS, даже если задача завершается неоднократно. `EndBackgroundTask` должны вызываться в обработчике срока действия, а также в нормальном процессе выполнения. 

Обработчик истечения срока действия выражается в виде анонимной функции с помощью лямбда-выражения, как показано ниже:

```csharp
Task.Factory.StartNew( () => {

    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask(() => {
        Console.WriteLine("Exhausted time");
        UIApplication.SharedApplication.EndBackgroundTask(taskId); 
    });
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.BackgroundTimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});
```

Хотя обработчики срока действия не требуются для выполнения кода, следует всегда использовать обработчик срока действия с фоновой задачей.

 <a name="background_tasks_in_iOS_7" />

## <a name="background-tasks-in-ios-7"></a>Фоновые задачи в iOS 7 +

Крупнейшим изменением в iOS 7 в отношении фоновых задач является отличие от реализации задач, но при их запуске.

Вспомним, что до iOS 7 задача, выполняемая в фоновом режиме, составила 600 секунд. Одна из причин этого ограничения заключается в том, что задача, выполняемая в фоновом режиме, будет удерживать устройство в спящий режим в течение выполнения задачи:

 [![](ios-backgrounding-with-tasks-images/ios6.png "Graph of the task keeping the app awake pre-iOS 7")](ios-backgrounding-with-tasks-images/ios6.png#lightbox)

Фоновая обработка iOS 7 оптимизирована для более длительного времени работы от аккумулятора. В iOS 7 фоновый режим становится уступающей: вместо того чтобы поддерживать устройство в спящем режиме, задачи учитывают, когда устройство переходит в режим сна, а также выполняют обработку блоков, когда устройство выходит из спящего режима для обработки телефонных звонков, уведомлений, входящих сообщений электронной почты и других распространенные прерывания. На следующей схеме представлено представление о том, как может быть нарушена задача:

 [![](ios-backgrounding-with-tasks-images/ios7.png "Graph of the task being broken into chunks post-iOS 7")](ios-backgrounding-with-tasks-images/ios7.png#lightbox)

Так как время выполнения задачи не превышает непрерывности, задачи, выполняющие передачу по сети, должны обрабатываться по-разному в iOS 7. Разработчикам рекомендуется использовать API `NSURlSession` для управления передачей данных по сети. В следующем разделе приводятся общие сведения о переносе в фоновом режиме.

 <a name="background-transfers" />

## <a name="background-transfers"></a>Фоновые передачи

Основой фоновой передачи данных в iOS 7 является новый API `NSURLSession`. `NSURLSession` позволяет нам создавать задачи для:

1. Переносите содержимое через прерывания сети и устройства.
1. Отправка и скачивание больших файлов ( *служба фоновой передачи* ).

Давайте подробнее рассмотрим, как это работает.

### <a name="nsurlsession-api"></a>API NSURLSession

 `NSURLSession` — мощный API для передачи содержимого по сети. Он предоставляет набор средств для обработки перемещения данных с помощью сетевых прерываний и изменений в состояниях приложений.

`NSURLSession` API создает один или несколько сеансов, что, в свою очередь, приводит к порождению задач к блокам-спискам связанных данных по сети. Задачи выполняются асинхронно для быстрого и надежного обмена данными. Поскольку `NSURLSession` является асинхронным, для каждого сеанса требуется блок обработчика завершения, чтобы система и приложение могли получить сведения о завершении процесса перемещения.

Чтобы выполнить передачу по сети, допустимую как в предварительных, так и после iOS 7, проверьте, доступен ли `NSURLSession` для передачи в очередь, и используйте обычную фоновую задачу для выполнения переноса, если это не так:

```csharp
if ([NSURLSession class]) {
  // Create a background session and enqueue transfers
}
else {
  // Start a background task and transfer directly
  // Do NOT make calls to update the UI here!
}
```

> [!IMPORTANT]
> Избегайте вызовов для обновления пользовательского интерфейса из фона в коде, совместимом с iOS 6, так как iOS 6 не поддерживает фоновое обновление пользовательского интерфейса и завершит работу приложения.

`NSURLSession` API включает широкий набор функций для обработки проверки подлинности, управления неудачными передачами и отчетов на стороне клиента, но не на стороне сервера. Она помогает организовать перерывы во время выполнения задач, появившиеся в iOS 7, а также обеспечивает быструю и надежную передачу больших файлов. В следующем разделе рассматривается эта вторая функция.

### <a name="background-transfer-service"></a>Служба фоновой пересылки

До iOS 7 Загрузка или скачивание файлов в фоновом режиме была ненадежной. Фоновые задачи получают ограниченное время, но время, необходимое для перемещения файла, зависит от сети и размера файла. В iOS 7 можно использовать `NSURLSession` для успешной отправки и загрузки больших файлов. Конкретный тип сеанса `NSURLSession`, обрабатывающий сетевые передачи больших файлов в фоновом режиме, называется *службой фоновой передачи*.

Передачи, инициированные с помощью службы фоновой передачи, управляются операционной системой и предоставляют интерфейсы API для управления проверкой подлинности и ошибками. Так как передачи не привязаны к произвольному ограничению времени, их можно использовать для отправки или скачивания больших файлов, автоматического обновления содержимого в фоновом режиме и выполнения других операций. Дополнительные сведения о реализации службы см. в этом [пошаговом руководстве по переносу в фоновом режиме](~/ios/app-fundamentals/backgrounding/ios-backgrounding-walkthroughs/background-transfer-walkthrough.md) .

Служба фоновой отправки часто объединяется с фоновым получением или удаленными уведомлениями, чтобы помочь приложениям обновлять содержимое в фоновом режиме. В следующих двух разделах мы рассмотрим концепцию регистрации целых приложений для выполнения в фоновом режиме на устройствах iOS 6 и iOS 7.
