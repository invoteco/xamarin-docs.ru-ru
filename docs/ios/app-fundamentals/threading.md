---
title: Создание потоков в Xamarin. iOS
description: В этом документе описывается использование API-интерфейсов System. Threading в приложении Xamarin. iOS. В нем обсуждается Библиотека параллельных задач, создание приложений, реагирующих на запросы, и сборка мусора.
ms.prod: xamarin
ms.assetid: 50BCAF3B-1020-DDC1-0339-7028985AAC72
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 06/05/2017
ms.openlocfilehash: 1c9282c790aa5436667b37e1861a96afffcaa668
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73009435"
---
# <a name="threading-in-xamarinios"></a>Создание потоков в Xamarin. iOS

Среда выполнения Xamarin. iOS предоставляет разработчикам доступ к API-интерфейсам потоковой передачи .NET, как явно, при использовании потоков (`System.Threading.Thread, System.Threading.ThreadPool`), так и неявно при использовании шаблонов асинхронных делегатов или методов BeginXXX, а также полный спектр интерфейсов API, поддерживающих эту задачу. Параллельная библиотека.

Xamarin настоятельно рекомендует использовать [библиотеку параллельных задач](https://msdn.microsoft.com/library/dd460717.aspx) (TPL) для создания приложений по нескольким причинам:

- Планировщик TPL по умолчанию делегирует выполнение задачи пулу потоков, который, в свою очередь, динамически увеличит количество потоков, необходимых для выполнения процесса, а также избежать ситуации, когда слишком много потоков приконкурирует к бесконечному времени ЦП. 
- Проще подумать об операциях с точки зрения задач TPL. Вы можете легко управлять ими, запланировать их, выполнять сериализацию выполнения или запускать множество параллельно с обширным набором интерфейсов API. 
- Это основа для программирования с использованием новых C# расширений языка Async. 

Пул потоков будет медленно увеличивать количество потоков по мере необходимости в зависимости от количества ядер ЦП, доступных в системе, загрузки системы и требований приложения. Этот пул потоков можно использовать либо путем вызова методов в `System.Threading.ThreadPool`, либо с помощью `System.Threading.Tasks.TaskScheduler` по умолчанию (части *параллельных платформ*).

Обычно разработчики используют потоки, когда им нужно создавать реагирующие приложения, и им не нужно блокировать основной цикл выполнения пользовательского интерфейса.

 <a name="Developing_Responsive_Applications" />

## <a name="developing-responsive-applications"></a>Разработка приложений для реагирования

Доступ к элементам пользовательского интерфейса должен быть ограничен тем же потоком, который выполняет основной цикл для вашего приложения. Если вы хотите внести изменения в основной пользовательский интерфейс из потока, следует поставить код в очередь с помощью [нсобжект. инвокеонмаинсреад](xref:Foundation.NSObject)следующим образом:

```csharp
MyThreadedRoutine ()  
{  
    var result = DoComputation ();  

    // we want to update an object that is managed by the main
    // thread; To do so, we need to ensure that we only access
    // this from the main thread:

    InvokeOnMainThread (delegate {  
        label.Text = "The result is: " + result;  
    });
}
```

Приведенный выше код вызывается внутри делегата в контексте основного потока, не вызывая каких либо состояний гонки, которые могут привести к сбою приложения.

 <a name="Threading_and_Garbage_Collection" />

## <a name="threading-and-garbage-collection"></a>Работа с потоками и сборка мусора

В процессе выполнения среда выполнения цели-C создаст и освободит объекты. Если объекты помечены для "автоматического выпуска", среда выполнения цели-C освобождает эти объекты в текущем `NSAutoReleasePool`потока. Xamarin. iOS создает один пул `NSAutoRelease` для каждого потока из `System.Threading.ThreadPool` и для основного потока. Это расширение охватывает все потоки, созданные с помощью TaskScheduler по умолчанию в System. Threading. Tasks.

При создании собственных потоков с помощью `System.Threading` необходимо предоставить собственный пул `NSAutoRelease`, чтобы предотвратить утечку данных. Для этого просто заключите поток в следующую часть кода:

```csharp
void MyThreadStart (object arg)
{
   using (var ns = new NSAutoReleasePool ()){
      // Your code goes here.
   }
}
```

Примечание. Поскольку Xamarin. iOS 5,2 вам не нужно предоставлять собственный `NSAutoReleasePool`, так как он предоставляется автоматически.

## <a name="related-links"></a>Связанные ссылки

- [Работа с потоком пользовательского интерфейса](~/ios/user-interface/ios-ui/ui-thread.md)
