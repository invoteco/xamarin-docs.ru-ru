---
title: Разработка API Xamarin. iOS
description: Принципы, которые использовались для проектирования интерфейсов API Xamarin. iOS и их отношение к цели-C.
ms.prod: xamarin
ms.assetid: 322D2724-AF27-6FFE-BD21-AA1CFE8C0545
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/21/2017
ms.openlocfilehash: ab56332617fece8e80429f82000880012bf85b41
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73022405"
---
# <a name="xamarinios-api-design"></a>Разработка API Xamarin. iOS

В дополнение к основным библиотекам базовых классов, которые являются частью Mono, [Xamarin. iOS](~/ios/index.yml) поставляется с привязками для различных интерфейсов API iOS, позволяя разработчикам создавать собственные приложения iOS с Mono.

В ядре Xamarin. iOS существует механизм взаимодействия, связывающий C# мир с миром цели-C, а также привязки для интерфейсов API на основе iOS c, таких как Кореграфикс и [OpenGL ES](#opengles).

Среда выполнения нижнего уровня для взаимодействия с кодом цели-C находится в [Односенсорном. обжкрунтиме](#objcruntime). Поверх этого, предоставляются привязки для [Foundation](#foundation), Корефаундатион и [UIKit](#uikit) .

## <a name="design-principles"></a>Принципы разработки

Это некоторые принципы разработки для привязок Xamarin. iOS (они также применяются к Xamarin. Mac, привязки Mono для цели-C на macOS):

- Следуйте [рекомендациям по проектированию платформы](https://docs.microsoft.com/dotnet/standard/design-guidelines)
- Разрешить разработчикам подклассировать классы цели-C:

  - Наследование от существующего класса
  - Вызов базового конструктора для создания цепочки
  - Переопределяющие методы должны выполняться с C#помощью системы переопределения
  - Подклассы должны работать со C# стандартными конструкциями

- Не предоставляйте разработчикам доступ к селекторам цели-C
- Предоставление механизма вызова произвольных библиотек цели-C
- Простое и сложное назначение задач с заданием на c
- Предоставление свойств цели-C в C# качестве свойств
- Предоставление строго типизированного API:

  - Повышение безопасности типов
  - Уменьшение ошибок времени выполнения
  - Получение IntelliSense интегрированной среды разработки для возвращаемых типов
  - Разрешает всплывающую документацию интегрированной среды разработки

- Рекомендуем исследовать API в интегрированной среде разработки:

  - Например, вместо предоставления слабо типизированного массива следующим образом:

    ```objc
    NSArray *getViews
    ```

    Предоставьте строгий тип следующим образом:

    ```csharp
    NSView [] Views { get; set; }
    ```

    Это дает Visual Studio для Mac возможность автоматического завершения при просмотре API, делает все операции `System.Array` доступными для возвращенного значения и позволяет возвращаемому значению участвовать в LINQ.

- Собственные C# типы:

  - [`NSString` преобразуется в `string`](~/ios/internals/api-design/nsstring.md)
  - Включите `int` и `uint` параметры, которые должны быть перечислены C# в перечислениях C# и перечисления с помощью атрибутов`[Flags]`
  - Вместо `NSArray` объектов, не зависящих от типа, предоставляйте массивы как строго типизированные массивы.
  - Для событий и уведомлений Предоставьте пользователям возможность выбора между:

    - Строго типизированная версия по умолчанию
    - Слабо типизированная версия для расширенных вариантов использования

- Поддержка шаблона делегата цели-C:

  - C#Система событий
  - Предоставление C# делегатам (лямбда-выражения, анонимные методы и`System.Delegate`) в API цели на языке C в качестве блоков

### <a name="assemblies"></a>Сборки

Xamarin. iOS включает несколько сборок, образующих *профиль Xamarin. iOS*. Дополнительные сведения см. на странице [сборок](~/cross-platform/internals/available-assemblies.md) .

### <a name="major-namespaces"></a>Основные пространства имен

#### <a name="objcruntime"></a>обжкрунтиме

Пространство имен [обжкрунтиме](xref:ObjCRuntime) позволяет разработчикам связывать мировые соединения C# и цели-C.
Это новая привязка, разработанная специально для iOS, на основе опыта Cocoa # и GTK #.

#### <a name="foundation"></a>Базовый

Пространство имен [Foundation](xref:Foundation) предоставляет базовые типы данных, предназначенные для взаимодействия с платформой объектив-c Foundation, которая является частью iOS и является основой объектно-ориентированного программирования в целевом C.

Зеркала Xamarin. iOS в C# иерархии классов из цели-C. Например, базовый класс цели-C [нсобжект](https://developer.apple.com/iphone/library/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html) можно использовать из C# Via [Foundation. нсобжект](xref:Foundation.NSObject).

Хотя это пространство имен предоставляет привязки для базовых типов цели-C, в некоторых случаях мы сопоставили базовые типы с типами .NET. Пример:

- Вместо того чтобы работать с [NSString](https://developer.apple.com/iphone/library/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/Reference/NSString.html) и [нсаррай](https://developer.apple.com/library/ios/#documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html), среда выполнения предоставляет их C#в виде [строк](xref:System.String)и строго типизированных [массивов](xref:System.Array)по всему API.

- Здесь представлены различные вспомогательные API, позволяющие разработчикам привязывать сторонние API-интерфейсы цели, другие API iOS или API, которые в настоящее время не привязаны к Xamarin. iOS.

Дополнительные сведения о привязках API см. в разделе [генератор привязок Xamarin. iOS](~/cross-platform/macios/binding/binding-types-reference.md) .

##### <a name="nsobject"></a>нсобжект

Тип [нсобжект](xref:Foundation.NSObject) является основой для всех привязок цели-C. Типы Xamarin. iOS отражают два класса типов из интерфейсов API Кокоатауч для iOS: типы C (обычно называются типами Корефаундатион) и типы цели-C (все они являются производными от класса Нсобжект).

Для каждого типа, который отражает неуправляемый тип, можно получить собственный объект через свойство [Handle](xref:Foundation.NSObject.Handle) .

Пока моно предоставляет сбор мусора для всех объектов, `Foundation.NSObject` реализует интерфейс [System. IDisposable](xref:System.IDisposable) . Это означает, что можно явным образом освободить ресурсы любых заданных Нсобжект, не дожидаясь запуска сборщика мусора. Это важно при использовании интенсивного Нсобжектс, например Уиимажес, который может содержать указатели на большие блоки данных.

Если тип должен выполнять детерминированное завершение, переопределите [метод нсобжект. Dispose (bool)](xref:Foundation.NSObject.Dispose(System.Boolean)) , чтобы параметр Dispose был "bool disposing", а если задано значение "true", это означает, что метод Dispose вызывается, так как пользователь явно вызывает Dispose () для объекта. Если значение равно false, это означает, что метод Dispose (bool disposing) вызывается из метода завершения в потоке метода завершения.

##### <a name="categories"></a>Категории

Начиная с Xamarin. iOS 8,10 можно создавать категории цели-C из C#.

Для этого используется атрибут `Category`, указывающий тип для расширения в качестве аргумента атрибута. В следующем примере показано, как экземпляр расширяет NSString.

```csharp
[Category (typeof (NSString))]
```

Каждый метод категории использует стандартный механизм экспорта методов в цели-C с помощью атрибута `Export`:

```csharp
[Export ("today")]
public static string Today ()
{
    return "Today";
}
```

Все управляемые методы расширения должны быть статическими, но можно создать методы экземпляра цели-C с помощью стандартного синтаксиса для методов расширения в C#:

```csharp
[Export ("toUpper")]
public static string ToUpper (this NSString self)
{
    return self.ToString ().ToUpper ();
}
```

первым аргументом метода расширения будет экземпляр, на котором был вызван метод.

Полный пример:

```csharp
[Category (typeof (NSString))]
public static class MyStringCategory
{
    [Export ("toUpper")]
    static string ToUpper (this NSString self)
    {
        return self.ToString ().ToUpper ();
    }
}
```

В этом примере будет добавлен собственный метод экземпляра toUpper в класс NSString, который можно вызвать из цели-C.

```csharp
[Category (typeof (UIViewController))]
public static class MyViewControllerCategory
{
    [Export ("shouldAutoRotate")]
    static bool GlobalRotate ()
    {
        return true;
    }
}
```

Одним из сценариев, в которых это полезно, является Добавление метода ко всему набору классов в базе кода. Например, все экземпляры `UIViewController` будут сообщать о том, что их можно повернуть:

```csharp
[Category (typeof (UINavigationController))]
class Rotation_IOS6 {
      [Export ("shouldAutorotate:")]
      static bool ShouldAutoRotate (this UINavigationController self)
      {
          return true;
      }
}
```

##### <a name="preserveattribute"></a>пресервеаттрибуте

Пресервеаттрибуте — это настраиваемый атрибут, который используется для указания mtouch — средства развертывания Xamarin. iOS — для сохранения типа или члена типа на этапе, когда приложение обрабатывается для уменьшения его размера.

Все члены, которые не имеют статических ссылок из приложения, подлежат удалению. Таким образом, этот атрибут используется для маркировки элементов, на которые нет статических ссылок, но которые по-прежнему нужны приложению.

Например, если вы динамически создаете экземпляры типов, для них нужно сохранять в коде конструктор по умолчанию. Если используется XML-сериализация, нужно сохранять свойства типов.

Этот атрибут можно применить для любого члена типа или для типа в целом. Если необходимо сохранить весь тип, можно использовать синтаксис [preserve (AllMembers = true)] для типа.

#### <a name="uikit"></a>UIKit

Пространство имен [UIKit](xref:UIKit) содержит сопоставление "один к одному" всем КОМПОНЕНТАМ пользовательского интерфейса, которые составляют кокоатауч в форме C# классов. API был изменен для соблюдения соглашений, используемых в C# языке.

C#для распространенных операций предоставляются делегаты. Дополнительные сведения см. в разделе [делегаты](#delegates) .

#### <a name="opengles"></a>Приложение OpenGLes

Для OpenGL мы распространяем [измененную версию](xref:OpenTK) API [опентк](http://www.opentk.com/) , объектно-ориентированную привязку к OpenGL, которая была изменена для использования типов данных и структур кореграфикс, а также предоставляет доступ только к функциональным возможностям, доступным в iOS.

Функции OpenGL 1,1 доступны через [тип ES11.GL](xref:OpenTK.Graphics.ES11.GL).

Функции OpenGL 2,0 доступны через [тип ES20.GL](xref:OpenTK.Graphics.ES20.GL).

Функции OpenGL 3,0 доступны через [тип ES30.GL](xref:OpenTK.Graphics.ES30.GL).

### <a name="binding-design"></a>Разработка привязки

Xamarin. iOS не просто является привязкой к базовой платформе цели-C. Она расширяет систему типов .NET и систему диспетчеризации, чтобы улучшить смешивание C# и цель-C.

Так же, как P/Invoke — это удобное средство для вызова собственных библиотек в Windows и Linux или как поддержку IJW для COM-взаимодействия в Windows, Xamarin. iOS расширяет среду выполнения для поддержки привязки C# объектов к объектам цели-C.

Обсуждение в следующих нескольких разделах не является обязательным для пользователей, создающих приложения Xamarin. iOS, но поможет разработчикам понять, как выполняются вещи и поможет им при создании более сложных приложений.

#### <a name="types"></a>Типы

Там, где это было C# понятно, для C# Вселенной предоставляются типы, а не низкоуровневые типы.  Это означает, что [API использует C# тип String вместо NSString](~/ios/internals/api-design/nsstring.md) и использует строго типизированные C# массивы вместо предоставления нсаррай.

Как правило, в структуре Xamarin. iOS и Xamarin. Mac базовый объект `NSArray` не предоставляется. Вместо этого среда выполнения автоматически преобразует `NSArray`s в строго типизированные массивы некоторых `NSObject` класса. Таким образом, Xamarin. iOS не предоставляет слабо типизированный метод, такой как "аналитические", для возврата Нсаррай:

```csharp
NSArray GetViews ();
```

Вместо этого привязка предоставляет строго типизированное возвращаемое значение следующим образом:

```csharp
UIView [] GetViews ();
```

Существует несколько методов, предоставляемых в `NSArray`, для угловых случаев, когда может потребоваться использовать `NSArray` напрямую, но их использование не рекомендуется в привязке API.

Кроме того, в **Classic API** вместо предоставления `CGRect`, `CGPoint` и `CGSize` из API-интерфейса кореграфикс мы заменили реализации `System.Drawing` `RectangleF`, `PointF` и `SizeF`, так как они помогут разработчикам сохранить существующий код OpenGL, использующий Опентк. При использовании нового 64-разрядного **Unified API**следует использовать API кореграфикс.

#### <a name="inheritance"></a>Наследование

Структура API Xamarin. iOS позволяет разработчикам расширять собственные типы "цель-C" точно так же, как они расширяют C# тип, используя ключевое слово "override" в производном классе, а также привязывать к базовой реализации с помощью "Base" C# This.

Такая схема позволяет разработчикам избегать использования селекторов цели-C в рамках процесса разработки, так как вся система цели-C уже заключена в библиотеки Xamarin. iOS.

#### <a name="types-and-interface-builder"></a>Типы и Interface Builder

При создании классов .NET, являющихся экземплярами типов, созданных Interface Builder, необходимо предоставить конструктор, принимающий один параметр `IntPtr`.
Это необходимо для привязки экземпляра управляемого объекта к неуправляемому объекту.
Код состоит из одной строки, как показано ниже.

```csharp
public partial class void MyView : UIView {
   // This is the constructor that you need to add.
   public MyView (IntPtr handle) : base (handle) {}
}
```

#### <a name="delegates"></a>Делегаты

Цель-C и C# разные значения для делегата слова на каждом языке.

В мире цели-C и в документации, где вы найдете в Интернете сведения о Кокоатауч, делегат обычно является экземпляром класса, который будет отвечать на набор методов. Это очень похоже на C# интерфейс, в отличие от того, что методы не всегда являются обязательными.

Эти делегаты играют важную роль в UIKit и других интерфейсах API Кокоатауч. Они используются для выполнения различных задач:

- Для предоставления уведомлений коду (аналогично доставке событий в C# или GTK +).
- Для реализации моделей для элементов управления визуализации данных.
- Чтобы обеспечить поведение элемента управления.

Шаблон программирования предназначен для того, чтобы было максимально сокращать создание производных классов для изменения поведения элемента управления. Это решение сходно с тем, какие другие наборы графических элементов были выполнены в течение нескольких лет: сигналы GTK, слоты Qt, события WinForms, события WPF/Silverlight и т. д. Чтобы избежать использования сотен интерфейсов (по одному для каждого действия) или необходимости разработчиков реализовывать слишком много ненужных методов, цель-C поддерживает необязательные определения методов. Это отличается от C# интерфейсов, требующих реализации всех методов.

В классах цели-C вы увидите, что классы, использующие этот шаблон программирования, предоставляют свойство, обычно именуемое `delegate`, которое требуется для реализации обязательных частей интерфейса и нуля или более дополнительных частей.

В Xamarin. iOS три взаимоисключающих механизма привязки к этим делегатам:

1. [События Via](#via-events).
2. [Строго типизировано с помощью свойства `Delegate`](#strongly-typed-via-a-delegate-property)
3. [Слабо типизировано с помощью свойства `WeakDelegate`](#loosely-typed-via-the-weakdelegate-property)

Например, рассмотрим класс [уивебвиев](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebView_Class/Reference/Reference.html) . Он отправляется в экземпляр [уивебвиевделегате](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html) , который назначается свойству [делегата](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebView_Class/Reference/Reference.html#//apple_ref/occ/instp/UIWebView/delegate) .

##### <a name="via-events"></a>События Via

Для многих типов Xamarin. iOS автоматически создает соответствующий делегат, который будет перенаправлять `UIWebViewDelegate`ные вызовы на C# события. Для `UIWebView`

- Метод [вебвиевдидстартлоад](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIWebViewDelegate/webViewDidStartLoad:) сопоставлен с событием [уивебвиев. лоадстартед](xref:UIKit.UIWebView.LoadStarted) .
- Метод [вебвиевдидфинишлоад](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIWebViewDelegate/webViewDidFinishLoad:) сопоставлен с событием [уивебвиев. лоадфинишед](xref:UIKit.UIWebView.LoadFinished) .
- Метод [webView: дидфаиллоадвисеррор](https://developer.apple.com/iphone/library/documentation/UIKit/Reference/UIWebViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIWebViewDelegate/webView:didFailLoadWithError:) сопоставлен с событием [уивебвиев. лоадеррор](xref:UIKit.UIWebView.LoadError) .

Например, эта простая программа записывает время начала и окончания при загрузке веб-представления:

```csharp
DateTime startTime, endTime;
var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.LoadStarted += (o, e) => startTime = DateTime.Now;
web.LoadFinished += (o, e) => endTime = DateTime.Now;
```

##### <a name="via-properties"></a>Свойства Via

События полезны при наличии нескольких подписчиков на одно событие. Кроме того, события ограничиваются только тем случаям, когда в коде нет возвращаемого значения.

Для случаев, когда предполагается, что код возвращает значение, мы выбрали вместо него свойства. Это означает, что в объекте можно задать только один метод в определенный момент времени.

Например, этот механизм можно использовать для закрытия клавиатуры на экране обработчика для `UITextField`:

```csharp
void SetupTextField (UITextField tf)
{
    tf.ShouldReturn = delegate (textfield) {
        textfield.ResignFirstResponder ();
        return true;
    }
}
```

Свойство `ShouldReturn` `UITextField`в этом случае принимает в качестве аргумента делегат, возвращающий логическое значение, и определяет, должно ли поле TextField выполнять действие с нажатой кнопкой возврата. В нашем методе возвращается *значение true* для вызывающего объекта, но мы также удалим клавиатуру с экрана (это происходит, когда объект textfield вызывает `ResignFirstResponder`).

##### <a name="strongly-typed-via-a-delegate-property"></a>Строго типизировано через свойство делегата

Если вы предпочитаете не использовать события, можно предоставить собственный подкласс [уивебвиевделегате](xref:UIKit.UIWebViewDelegate) и назначить его свойству [уивебвиев. Delegate](xref:UIKit.UIWebView.Delegate) . После назначения Уивебвиев. Delegate механизм диспетчеризации событий Уивебвиев больше не будет работать, а методы Уивебвиевделегате будут вызываться при возникновении соответствующих событий.

Например, этот простой тип записывает время, затрачиваемое на загрузку веб-представления:

```csharp
class Notifier : UIWebViewDelegate  {
    DateTime startTime, endTime;

    public override LoadStarted (UIWebView webview)
    {
        startTime = DateTime.Now;
    }

    public override LoadingFinished (UIWebView webView)
    {
        endTime= DateTime.Now;
    }
}
```

Приведенный выше код используется в коде следующим образом:

```csharp
var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.Delegate = new Notifier ();
```

Приведенный выше компонент создаст Уивебвиевер и сообщит ему отправить сообщение экземпляру уведомления, классу, который мы создали для реагирования на сообщения.

Этот шаблон также используется для управления поведением определенных элементов управления, например в Уивебвиев случае свойство [уивебвиев. шаулдстартлоад](xref:UIKit.UIWebView.ShouldStartLoad) позволяет экземпляру `UIWebView` управлять тем, будет ли `UIWebView` загружать страницу.

Шаблон также используется для предоставления данных по запросу для нескольких элементов управления. Например, элемент управления [уитаблевиев](xref:UIKit.UITableView) является мощным элементом управления для отрисовки таблиц, и как внешний вид, так и содержимое управляются экземпляром [уитаблевиевдатасаурце](xref:UIKit.UITableViewDataSource)

### <a name="loosely-typed-via-the-weakdelegate-property"></a>Слабо типизировано с помощью свойства Веакделегате

Помимо строго типизированного свойства, существует также ненадежный типизированный делегат, позволяющий разработчику при необходимости привязывать вещи по-разному.
Везде, где строго типизированное `Delegate` свойство предоставляется в привязке Xamarin. iOS, также предоставляется соответствующее свойство `WeakDelegate`.

При использовании `WeakDelegate`вы несете ответственность за правильное определение класса с помощью атрибута [Export](xref:Foundation.ExportAttribute) для указания селектора. Пример:

```csharp
class Notifier : NSObject  {
    DateTime startTime, endTime;

    [Export ("webViewDidStartLoad:")]
    public void LoadStarted (UIWebView webview)
    {
        startTime = DateTime.Now;
    }

    [Export ("webViewDidFinishLoad:")]
    public void LoadingFinished (UIWebView webView)
    {
        endTime= DateTime.Now;
    }
}

[...]

var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.WeakDelegate = new Notifier ();
```

Обратите внимание, что после присвоения свойства `WeakDelegate` свойство `Delegate` не будет использоваться. Кроме того, при реализации метода в унаследованном базовом классе, который вы хотите применить к [Export], необходимо сделать его открытым методом.

## <a name="mapping-of-the-objective-c-delegate-pattern-to-c"></a>Сопоставление шаблона делегата цели-C с\#ом C

При просмотре образцов цели-C, которые выглядят следующим образом:

```objc
foo.delegate = [[SomethingDelegate] alloc] init]
```

Это указывает языку создать и сконструировать экземпляр класса "Сомесингделегате" и присвоить значение свойству делегата в переменной foo. Этот механизм поддерживается Xamarin. iOS и C# имеет следующий синтаксис:

```csharp
foo.Delegate = new SomethingDelegate ();
```

В Xamarin. iOS мы предоставили строго типизированные классы, соответствующие классам делегата цели-C. Чтобы использовать их, нужно будет подклассировать и переопределять методы, определенные в реализации Xamarin. iOS. Дополнительные сведения о том, как они работают, см. в разделе "модели" ниже.

### <a name="mapping-delegates-to-c"></a>Сопоставление делегатов C\#

UIKit в целом использует делегаты цели-C в двух формах.

Первая форма предоставляет интерфейс модели компонента. Например, в качестве механизма предоставления данных по запросу для представления, например средства хранения данных для представления списка.  В таких случаях следует всегда создавать экземпляр соответствующего класса и присваивать ему переменную.

В следующем примере мы предоставляем `UIPickerView` с реализацией для модели, которая использует строки:

```csharp
public class SampleTitleModel : UIPickerViewTitleModel {

    public override string TitleForRow (UIPickerView picker, nint row, nint component)
    {
        return String.Format ("At {0} {1}", row, component);
    }
}

[...]

pickerView.Model = new MyPickerModel ();
```

Вторая форма — предоставление уведомлений о событиях. В таких случаях, несмотря на то, что мы по-прежнему предоставляем API в форме, описанной выше C# , мы также предоставляем события, которые проще всего использовать для быстрых операций и интегрированы с анонимными C#делегатами и лямбда-выражениями в.

Например, можно подписываться на `UIAccelerometer` события:

```csharp
UIAccelerometer.SharedAccelerometer.Acceleration += (sender, args) => {
   UIAcceleration acc = args.Acceleration;
   Console.WriteLine ("Time={0} at {1},{2},{3}", acc.Time, acc.X, acc.Y, acc.Z);
}
```

Доступны два варианта, где они имеют смысл, но в качестве программиста необходимо выбрать одно или другое. Если вы создаете собственный экземпляр строго типизированного ответчика или делегата и назначаете его C# , события не будут работать. При использовании C# событий методы в классе ответчика или делегата никогда не вызываются.

Предыдущий пример, который использовался `UIWebView`, можно записать C# с помощью 3,0 лямбда-выражений следующим образом:

```csharp
var web = new UIWebView (new CGRect (0, 0, 200, 200));
web.LoadStarted += () => { startTime = DateTime.Now; }
web.LoadFinished += () => { endTime = DateTime.Now; }
```

#### <a name="responding-to-events"></a>Реагирование на события

В коде цели-C иногда обработчики событий для нескольких элементов управления и поставщиков информации для нескольких элементов управления будут размещаться в одном и том же классе. Это возможно, поскольку классы реагируют на сообщения, и пока классы реагируют на сообщения, можно связывать объекты друг с другом.

Как уже было сказано выше, Xamarin. iOS поддерживает C# как модель программирования на основе событий, так и шаблон делегата цели-C, где можно создать новый класс, реализующий делегат, и переопределить нужные методы.

Кроме того, можно реализовать шаблон цели-C, когда отвечающие на несколько различных операций размещаются в одном экземпляре класса. Для этого вам потребуется использовать низкоуровневые функции привязки Xamarin. iOS.

Например, если вы хотите, чтобы ваш класс отвечал на `UITextFieldDelegate.textFieldShouldClear`: Message и `UIWebViewDelegate.webViewDidStartLoad`: в том же экземпляре класса необходимо использовать объявление атрибута [Export]:

```csharp
public class MyCallbacks : NSObject {
    [Export ("textFieldShouldClear:"]
    public bool should_we_clear (UITextField tf)
    {
        return true;
    }

    [Export ("webViewDidStartLoad:")]
    public void OnWebViewStart (UIWebView view)
    {
        Console.WriteLine ("Loading started");
    }
}
```

C# Имена методов не важны; все, что имеет значение, — это строки, передаваемые в атрибут [Export].

При использовании этого стиля программирования убедитесь, что C# параметры соответствуют реальным типам, которые будет передавать ядро среды выполнения.

#### <a name="models"></a>Модели

В средствах хранения UIKit или в ответчиках, реализованных с помощью вспомогательных классов, они обычно упоминаются в коде цели-C как делегаты и реализуются как протоколы.

Протоколы цели-C подобны интерфейсам, но поддерживают необязательные методы, то есть не все методы должны быть реализованы, чтобы протокол работал.

Существует два способа реализации модели. Можно либо реализовать его вручную, либо использовать существующие строго типизированные определения.

Механизм вручную необходим при попытке реализовать класс, который не привязан к Xamarin. iOS. Это очень просто:

- Пометка класса для регистрации в среде выполнения
- Примените атрибут [Export] с фактическим именем селектора для каждого метода, который требуется переопределить.
- Создайте экземпляр класса и передайте его.

Например, в следующем примере реализуется только один из необязательных методов в определении протокола Уиаппликатионделегате:

```csharp
public class MyAppController : NSObject {
        [Export ("applicationDidFinishLaunching:")]
        public void FinishedLaunching (UIApplication app)
        {
                SetupWindow ();
        }
}
```

Имя селектора цели-C ("Аппликатиондидфинишлаунчинг:") объявляется с атрибутом экспорта, а класс регистрируется с помощью атрибута `[Register]`.

Xamarin. iOS предоставляет строго типизированные объявления, готовые к использованию, которые не нуждаются в ручной привязке. Для поддержки этой модели программирования среда выполнения Xamarin. iOS поддерживает атрибут [Model] в объявлении класса. Это информирует среду выполнения о том, что не следует подключать все методы класса, если только методы не реализованы явным образом.

Это означает, что в UIKit классы, представляющие протокол с дополнительными методами, пишутся следующим образом:

```csharp
[Model]
public class SomeViewModel : NSObject {
    [Export ("someMethod:")]
    public virtual int SomeMethod (TheView view) {
       throw new ModelNotImplementedException ();
    }
    ...
}
```

Если необходимо реализовать модель, которая реализует лишь некоторые из методов, достаточно переопределять интересующие вас методы и игнорировать другие методы. Среда выполнения будет подключать только перезаписанные методы, а не исходные методы в мир цели-C.

Эквивалентом предыдущего образца вручную является:

```csharp
public class AppController : UIApplicationDelegate {
    public override void FinishedLaunching (UIApplication uia)
    {
     ...
    }
}
```

Преимущество заключается в том, что нет необходимости изучать файлы заголовков цели-C, чтобы найти селектор, типы аргументов или сопоставление с C#, а также получить intellisense из Visual Studio для Mac и строгих типов.

#### <a name="xib-outlets-and-c"></a>XIBные розетки и\# C

> [!IMPORTANT]
> В этом разделе объясняется интеграция интегрированной среды разработки с средами при использовании файлов XIB. При использовании Xamarin Designer для iOS все это заменяется путем ввода имени в разделе **Identity > Name** в разделе Properties в интегрированной среде разработки, как показано ниже.
>
> [![](images/designeroutlet.png "Entering an item Name in the iOS Designer")](images/designeroutlet.png#lightbox)
>
>Дополнительные сведения о конструкторе iOS см. в документе [Введение в конструктор iOS](~/ios/user-interface/designer/introduction.md#how-it-works) .

Это небольшое описание того, как можно интегрировать возможности C# и предоставляется для опытных пользователей Xamarin. iOS. При использовании Visual Studio для Mac сопоставление выполняется автоматически в фоновом режиме с помощью созданного кода в полете.

При проектировании пользовательского интерфейса с помощью Interface Builder вы разрабатываете только внешний вид приложения и устанавливаете некоторые подключения по умолчанию. Если требуется программная выборка информации, изменение поведения элемента управления во время выполнения или изменение элемента управления во время выполнения, необходимо привязать некоторые элементы управления к управляемому коду.

Это выполняется в несколько шагов.

1. Добавьте **объявление розетки** в **владельца файла**.
1. Подключите свой элемент управления к **владельцу файла**.
1. Сохраните пользовательский интерфейс и подключения в файле XIB/NIB.
1. Загрузите файл NIB во время выполнения.
1. Доступ к переменной розетки.

Шаги (от 1) до (3) описаны в документации Apple по созданию интерфейсов с помощью Interface Builder.

При использовании Xamarin. iOS приложению потребуется создать класс, производный от UIViewController. Он реализуется следующим образом:

```csharp
public class MyViewController : UIViewController {
    public MyViewController (string nibName, NSBundle bundle) : base (nibName, bundle)
    {
        // You can have as many arguments as you want, but you need to call
        // the base constructor with the provided nibName and bundle.
    }
}
```

Затем, чтобы загрузить ViewController из файла NIB, сделайте следующее:

```csharp
var controller = new MyViewController ("HelloWorld", NSBundle.MainBundle, this);
```

При этом пользовательский интерфейс загружается из NIB. Теперь, чтобы получить доступ к розеткам, необходимо сообщить среде выполнения о необходимости доступа к ним. Для этого классу `UIViewController` необходимо объявить свойства и добавить к ним заметки с помощью атрибута [Connect]. Пример:

```csharp
[Connect]
UITextField UserName {
    get {
        return (UITextField) GetNativeField ("UserName");
    }
    set {
        SetNativeField ("UserName", value);
    }
}
```

Реализация свойства — это тот, который фактически извлекает и сохраняет значение для самого собственного типа.

При использовании Visual Studio для Mac и Интерфацебуилдер не нужно беспокоиться об этом. Visual Studio для Mac автоматически отражает все объявленные розетки с кодом в разделяемом классе, который компилируется как часть проекта.

#### <a name="selectors"></a>Селекторы

Основной концепцией программирования на языке C являются селекторы. Часто приходится использовать API, требующие передачи селектора, или предполагает, что ваш код будет отвечать на селектор.

Создание новых селекторов в C# очень просто. Вы просто создаете новый экземпляр класса`ObjCRuntime.Selector`и используете результат в любом месте API, которому он требуется. Пример:

```csharp
var selector_add = new Selector ("add:plus:");
```

Для C# метода, отвечающего на вызов селектора, он должен наследовать от типа`NSObject`и C# метод должен быть снабжен именем селектора с помощью атрибута `[Export]`. Пример:

```csharp
public class MyMath : NSObject {
    [Export ("add:plus:")]
    int Add (int first, int second)
    {
         return first + second;
    }
}
```

Обратите внимание, что имена селекторов **должны** точно совпадать, включая все промежуточные и конечные двоеточия (":"), если они есть.

#### <a name="nsobject-constructors"></a>Конструкторы Нсобжект

Большинство классов в Xamarin. iOS, производных от `NSObject`, будут предоставлять конструкторы, относящиеся к функциональным возможностям объекта, но они также будут предоставлять различные конструкторы, которые не являются очевидными.

Конструкторы используются следующим образом:

```csharp
public Foo (IntPtr handle)
```

Этот конструктор используется для создания экземпляра класса, когда среда выполнения должна сопоставлять ваш класс с неуправляемым классом. Это происходит при загрузке файла XIB/NIB.  На этом этапе среда выполнения цели-C создаст объект в неуправляемом мире, и этот конструктор будет вызван для инициализации управляемой стороны.

Как правило, все, что нужно сделать, — это вызвать базовый конструктор с параметром Handle, а в теле — выполнить необходимую инициализацию.

```csharp
public Foo ()
```

Это конструктор по умолчанию для класса, а в классах, предоставляемых Xamarin. iOS, инициализирует класс Foundation. Нсобжект и все классы в между, а в конце привязывает его к методу цели-C `init` класса.

```csharp
public Foo (NSObjectFlag x)
```

Этот конструктор используется для инициализации экземпляра, но запрещает коду вызывать метод цели-C "Init" в конце. Обычно используется, если вы уже зарегистрировались для инициализации (при использовании `[Export]` в конструкторе) или если вы уже выполнили инициализацию с помощью другого среднего значения.

```csharp
public Foo (NSCoder coder)
```

Этот конструктор предоставляется для случаев, когда объект инициализируется из экземпляра Нскодинг. Дополнительные сведения см. в статье [по программированию архивов и сериализации](https://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/Archiving/index.html#//apple_ref/doc/uid/10000047i) для Apple.

#### <a name="exceptions"></a>Исключения

Структура API Xamarin. iOS не вызывает исключения цели-C как C# исключения. Проект применяет, что ни одна из них не будет отправлена в мир цели-C на первом месте и что все исключения, которые должны быть созданы, создаются привязкой, прежде чем недопустимые данные будут переданы в мир цели-C.

#### <a name="notifications"></a>Уведомления

В iOS и OS X разработчики могут подписываться на уведомления, которые рассылаются базовой платформой. Это делается с помощью метода `NSNotificationCenter.DefaultCenter.AddObserver`. Метод `AddObserver` принимает два параметра: одно из них — уведомление, на которое вы хотите подписываться; другой — метод, который вызывается при возникновении уведомления.

В Xamarin. iOS и Xamarin. Mac ключи для различных уведомлений размещаются в классе, который запускает уведомления. Например, уведомления, созданные `UIMenuController`, размещаются в виде свойств `static NSString` в классах `UIMenuController`, которые оканчиваются именем Notification.

### <a name="memory-management"></a>Управление памятью

Xamarin. iOS имеет сборщик мусора, который потребует освобождения ресурсов, когда они больше не используются. Помимо сборщика мусора, все объекты, производные от `NSObject`, реализуют интерфейс `System.IDisposable`.

#### <a name="nsobject-and-idisposable"></a>Нсобжект и IDisposable

Предоставление доступа к интерфейсу `IDisposable` является удобным способом помочь разработчикам в освобождении объектов, которые могут инкапсулировать большие блоки памяти (например, `UIImage` может выглядеть как просто указатель безобидным, но можно указать на изображение в 2 МБ) и другие важные и ограниченные ресурсы (например, буфер декодирования видео).

Нсобжект реализует интерфейс IDisposable, а также [шаблон удаления .NET](https://msdn.microsoft.com/library/fs2xkftw.aspx). Это позволяет разработчикам, Нсобжект подкласс, переопределять поведение Dispose и освобождать свои ресурсы по запросу. Например, рассмотрим этот контроллер представления, который поддерживает несколько образов:

```csharp
class MenuViewController : UIViewController {
    UIImage breakfast, lunch, dinner;
    [...]
    public override void Dispose (bool disposing)
    {
        if (disposing){
             if (breakfast != null) breakfast.Dispose (); breakfast = null;
             if (lunch != null) lunch.Dispose (); lunch = null;
             if (dinner != null) dinner.Dispose (); dinner = null;
        }
        base.Dispose (disposing)
    }
}
```

Когда управляемый объект удаляется, он больше не используется. Возможно, у вас по-прежнему есть ссылка на объекты, но объект предназначен для всех целей и недопустимы в этой точке. Некоторые API-интерфейсы .NET гарантируют это, вызывая ObjectDisposedException при попытке получить доступ к любым методам удаленного объекта, например:

```csharp
var image = UIImage.FromFile ("demo.png");
image.Dispose ();
image.XXX = false;  // this at this point is an invalid operation
```

Даже если вы по-прежнему можете получить доступ к переменной "Image", она действительно является недопустимой ссылкой и больше не указывает на объект цели-C, который удерживал изображение.

Но удаление объекта в C# не означает, что объект будет обязательно уничтожен. Все, что C# вы сделаете, — освободить ссылку на объект. Возможно, среда Cocoa сохранила ссылку для использования в качестве собственной. Например, если задать изображение для свойства изображения Уиимажевиев, а затем удалить образ, базовый Уиимажевиев получил собственную ссылку и сохранит ссылку на этот объект, пока не завершит его использование.

#### <a name="when-to-call-dispose"></a>Когда следует вызывать Dispose

Метод Dispose следует вызывать, если требуется Mono при получении объекта. Возможный вариант использования заключается в том, что Mono не знает о том, что Нсобжект на самом деле содержит ссылку на важный ресурс, например память, или информационный пул. В таких случаях следует вызывать Dispose для немедленного освобождения ссылки на память вместо того, чтобы ждать, пока Mono выполняет цикл сборки мусора.

На внутреннем уровне, когда Mono создает [ссылки C# NSString из строк](~/ios/internals/api-design/nsstring.md), они немедленно удалят их, чтобы сократить объем работы, которую должен выполнить сборщик мусора. Чем меньше объектов для работы с ними работать, тем быстрее будет выполняться сборщик мусора.

#### <a name="when-to-keep-references-to-objects"></a>Когда следует размещать ссылки на объекты

Одним из побочных эффектов автоматического управления памятью является то, что сборщик мусора будет избавиться от неиспользуемых объектов, если на них нет ссылок. Это иногда может иметь неудивительное побочные эффекты, например, если вы создаете локальную переменную для размещения контроллера представления верхнего уровня или окна верхнего уровня, а затем помещаете эти данные в начало.

Если вы не сохраняете ссылку в статических переменных или переменные экземпляра для объектов, моно будет вызывать для них метод Dispose (), и они будут освобождать ссылку на объект. Так как это может быть единственная необработанная ссылка, среда выполнения цели-C уничтожает объект.

## <a name="related-links"></a>Связанные ссылки

- [Привязка полей](~/cross-platform/macios/binding/objective-c-libraries.md#Binding_Fields)
