---
title: Регистратор типов для Xamarin. iOS
description: В этом документе описывается регистратор типов Xamarin. iOS, который делает C# классы доступными для среды выполнения цели-C.
ms.prod: xamarin
ms.assetid: 610A0834-1141-4D09-A05E-B7ADF99462C5
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 08/29/2018
ms.openlocfilehash: c761290f43d780b2eafcf416fb9edf1e069f65c3
ms.sourcegitcommit: c9651cad80c2865bc628349d30e82721c01ddb4a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2019
ms.locfileid: "70226033"
---
# <a name="type-registrar-for-xamarinios"></a>Регистратор типов для Xamarin. iOS

В этом документе описывается система регистрации типов, используемая Xamarin. iOS.

## <a name="registration-of-managed-classes-and-methods"></a>Регистрация управляемых классов и методов

Во время запуска Xamarin. iOS будет регистрировать:

- Классы с атрибутом [[Register]](xref:Foundation.RegisterAttribute) в качестве классов цели-C.
- Классы с атрибутом [[Category]](xref:ObjCRuntime.CategoryAttribute) в качестве категорий цели-C.
- Интерфейсы с атрибутом [[Protocol]](xref:Foundation.ProtocolAttribute) в качестве протоколов цели-C.
- Члены с [[Export]](xref:Foundation.ExportAttribute), что позволяет цели-C получить доступ к ним.

Например, рассмотрим управляемый `Main` метод, распространенный в приложениях Xamarin. iOS:

```csharp
UIApplication.Main (args, null, "AppDelegate");
```

Этот код указывает среде выполнения цели-C использовать тип, вызываемый `AppDelegate` как класс делегата приложения. Чтобы среда выполнения цели-C могла создать экземпляр C# `AppDelegate` класса, этот класс должен быть зарегистрирован.

Xamarin. iOS выполняет регистрацию автоматически, во время выполнения (динамическая регистрация) или в момент компиляции (статическая регистрация).

Динамическая регистрация использует отражение при запуске, чтобы найти все классы и методы для регистрации, передав их в среду выполнения цели-C. Динамическая регистрация используется по умолчанию для сборок симуляторов.

Статическая регистрация во время компиляции проверяет сборки, используемые приложением. Он определяет классы и методы для регистрации в цели-C и создает карту, которая внедряется в двоичный файл.
Затем при запуске он регистрирует карту в среде выполнения цели-C. Для сборок устройств используется статическая регистрация.

### <a name="categories"></a>Категории

Начиная с Xamarin. iOS 8,10, можно создавать категории цели-C с помощью C# синтаксиса.

Чтобы создать категорию, используйте `[Category]` атрибут и укажите тип для расширения. Например, следующий код расширяет `NSString`:

```csharp
[Category (typeof (NSString))]
```

Каждый из методов категории имеет `[Export]` атрибут, делая его доступным для среды выполнения цели-C:

```csharp
[Export ("today")]
public static string Today ()
{
    return "Today";
}
```

Все управляемые методы расширения должны быть статическими, но можно создать методы экземпляра цели-C с помощью стандартного C# синтаксиса для методов расширения:

```csharp
[Export ("toUpper")]
public static string ToUpper (this NSString self)
{
    return self.ToString ().ToUpper ();
}
```

Первым аргументом метода расширения является экземпляр, для которого был вызван метод:

```csharp
[Category (typeof (NSString))]
public static class MyStringCategory
{
    [Export ("toUpper")]
    static string ToUpper (this NSString self)
    {
        return self.ToString ().ToUpper ();
    }
 }
 ```

В этом примере в `toUpper` `NSString` класс будет добавлен собственный метод экземпляра. Этот метод может быть вызван из цели-C:

```csharp
[Category (typeof (UIViewController))]
public static class MyViewControllerCategory
{
    [Export ("shouldAutoRotate")]
    static bool GlobalRotate ()
    {
        return true;
    }
}
```

### <a name="protocols"></a>Протоколы

Начиная с Xamarin. iOS 8,10, интерфейсы с `[Protocol]` атрибутом будут экспортированы в цель-C в качестве протоколов:

```csharp
[Protocol ("MyProtocol")]
interface IMyProtocol
{
    [Export ("method")]
    void Method ();
}

class MyClass : IMyProtocol
{
    void Method ()
    {
    }
}
```

Этот код экспортирует `IMyProtocol` в цель-C как протокол с именем `MyProtocol` и класс с именем `MyClass` , который реализует протокол.

## <a name="new-registration-system"></a>Новая система регистрации

Начиная с стабильной версии 6.2.6 и бета-версии 6.3.4 мы добавили новый статический регистратор. В версии 7.2.1 новый регистратор был создан по умолчанию.

Эта новая система регистрации предоставляет следующие новые возможности:

- Обнаружение ошибок программиста во время компиляции:
  - Два класса регистрируются с одним и тем же именем.
  - Несколько экспортированных методов отвечают на один и тот же селектор
- Удаление неиспользуемого машинного кода:
  - Новая система регистрации будет добавлять надежные ссылки на код, используемый в статических библиотеках, позволяя собственному компоновщику удалять неиспользуемый машинный код из результирующего двоичного файла. В примерах привязок Xamarin большинство приложений становятся по крайней мере 300 тыс меньше.

- Поддержка универсальных подклассов `NSObject`; дополнительные сведения см. в разделе [универсальные шаблоны нсобжект](~/ios/internals/api-design/nsobject-generics.md) . Кроме того, Новая система регистрации будет перехватывать неподдерживаемые универсальные конструкции, которые ранее вызывали бы случайное поведение во время выполнения.

### <a name="errors-caught-by-the-new-registrar"></a>Ошибки, перехваченные новым регистратором

Ниже приведены некоторые примеры ошибок, перехваченных новым регистратором.

- Экспорт одного и того же селектора несколько раз в одном классе:

  ```csharp
  [Register]
  class MyDemo : NSObject
  {
      [Export ("foo:")]
      void Foo (NSString str);
      [Export ("foo:")]
      void Foo (string str)
  }
  ```

- Экспорт более одного управляемого класса с одним и тем же именем цели-C:

  ```csharp
  [Register ("Class")]
  class MyClass : NSObject {}

  [Register ("Class")]
  class YourClass : NSObject {}
  ```

- Экспорт универсальных методов:

  ```csharp
  [Register]
  class MyDemo : NSObject
  {
      [Export ("foo")]
      void Foo<T> () {}
  }
  ```

### <a name="limitations-of-the-new-registrar"></a>Ограничения нового регистратора

Ниже приведены некоторые моменты, которые следует учитывать при создании регистратора.

- Для работы с новой системой регистрации необходимо обновить некоторые сторонние библиотеки. Дополнительные сведения см. в разделе [необходимые изменения](#required-modifications) ниже.

- Краткосрочная недостатком является также то, что Clang необходимо использовать, если используется платформа Accounts (это связано с тем, что заголовок **Accounts. h** может быть скомпилирован только с помощью Clang). Добавьте `--compiler:clang` к дополнительным аргументам mtouch, чтобы использовать Clang, если вы используете Xcode 4,6 или более раннюю версию (Xamarin. IOS автоматически выберет Clang в Xcode 5,0 или более поздней версии).

- Если используется Xcode 4,6 (или более ранняя версия), необходимо выбрать GCC/G + +, если имена экспортируемых типов содержат символы, отличные от ASCII (это обусловлено тем, что в версии Clang, поставляемой с Xcode 4,6, не поддерживаются символы, не входящие в набор ASCII, в идентификаторах в коде цели-C). Добавьте `--compiler:gcc` дополнительные аргументы mtouch для использования GCC.

## <a name="selecting-a-registrar"></a>Выбор регистратора

Вы можете выбрать другого регистратора, добавив один из следующих параметров в дополнительные аргументы mtouch в параметрах **сборки iOS** проекта:

- `--registrar:static`— по умолчанию для сборок устройств
- `--registrar:dynamic`— по умолчанию для сборок симуляторов

> [!NOTE]
> Classic API Xamarin поддерживал другие параметры, такие как `--registrar:legacystatic` и `--registrar:legacydynamic`. Однако эти параметры не поддерживаются Unified API.

## <a name="shortcomings-in-the-old-registration-system"></a>Недостатки старой системы регистрации

Старая система регистрации имеет следующие недостатки.

- Не существовала (собственная) статичная ссылка на классы и методы цели-C в собственных библиотеках сторонних разработчиков, которая означала, что не удалось попросить собственного компоновщика удалить машинный код стороннего разработчика, который не использовался в действительности (так как все будет удалено). Это причина того `-force_load libNative.a` , что каждой привязке от сторонних разработчиков приходилось делать (или эквивалент `ForceLoad=true` в `[LinkWith]` атрибуте).
- Можно экспортировать два управляемых типа с одним и тем же именем цели-C без предупреждения. Редкий сценарий состоит в том, что в `AppDelegate` них есть два класса в разных пространствах имен. Во время выполнения он будет полностью случайным, который был выбран (на самом деле он изменялся между запусками приложения, которые еще не были перестроены, что сделано для очень замешательство и неприятного процесса отладки).
- Можно экспортировать два метода с одинаковой сигнатурой цели-C. Еще раз, один из которых был бы вызван из цели-C, был случайным (но эта проблема была не так распространена, как и Предыдущая), в основном потому, что единственный способ действительно вызвать эту ошибку — переопределить несчастливый управляемый метод).
- Набор экспортированных методов был слегка различим между динамическими и статическими сборками.
- Он не работает должным образом при экспорте универсальных классов (Точная универсальная реализация, выполняемая во время выполнения, будет случайной, что приведет к неопределенному поведению).

<a name="required-modifications" />

## <a name="new-registrar-required-changes-to-bindings"></a>Новый регистратор: необходимые изменения для привязок

В этом разделе описаны изменения привязок, которые необходимо выполнить для работы с новым регистратором.

### <a name="protocols-must-have-the-protocol-attribute"></a>Протоколы должны иметь атрибут [Protocol]

Теперь протоколы должны иметь `[Protocol]` атрибут. Если этого не сделать, будет вычислена собственная ошибка компоновщика, например:

```console
Undefined symbols for architecture i386: "_OBJC_CLASS_$_ProtocolName", referenced from: ...
```

### <a name="selectors-must-have-a-valid-number-of-parameters"></a>Селекторы должны иметь допустимое число параметров

Все селекторы должны правильно указывать количество параметров. Ранее эти ошибки были пропущены и могут вызвать проблемы среды выполнения.

Вкратце, количество двоеточий должно соответствовать числу параметров:

- Нет параметров:`foo`
- Один параметр:`foo:`
- Два параметра:`foo:parameterName2:`

Ниже приведены неправильные варианты использования.

```csharp
// Invalid: export takes no arguments, but function expects one
[Export ("apply")]
void Apply (NSObject target);

// Invalid: exported as taking an argument, but the managed version does not have one:
[Export ("display:")]
void Display ();
```

### <a name="use-isvariadic-parameter-in-export"></a>Использование параметра Исвариадик в Export

Функции Variadic должны использовать `IsVariadic` аргумент `[Export]` для атрибута:

```csharp
[Export ("variadicMethod:", IsVariadic = true)]
void VariadicMethod (NSObject first, IntPtr subsequent);
```

### <a name="must-link-to-existing-symbols"></a>Необходимо связать с существующими символами

Невозможно привязать классы, которые не существуют в собственной библиотеке.
Если класс был удален из библиотеки машинного кода или переименован в нее, обязательно обновите привязки для соответствия.
