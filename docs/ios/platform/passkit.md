---
title: PassKit в Xamarin. iOS
description: Приложение "Бумажник" позволяет пользователям iOS хранить цифровые передачи на своих устройствах. PassKit Framework позволяет разработчикам взаимодействовать с методами программным способом.
ms.prod: xamarin
ms.assetid: 74B9973B-C1E8-B727-3F6D-59C1F98BAB3A
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 06/13/2018
ms.openlocfilehash: 150a4e3c1deafbabea892d5adb786374c3d97d12
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70769581"
---
# <a name="passkit-in-xamarinios"></a>PassKit в Xamarin. iOS

Приложение для iOS позволяет пользователям хранить цифровые проходы на своих устройствах.
Эти этапы создаются продавцами и отправляются клиенту по электронной почте, URL-адресам или по собственному приложению iOS. Эти этапы могут представлять различные вещи, от билетов фильмов до карточек постоянных клиентов для передачи на этапы. PassKit Framework позволяет разработчикам взаимодействовать с методами программным способом.

В этом документе описывается бумажник и использование API PassKit с Xamarin. iOS.

 [![](passkit-images/image1.png "Бумажник хранит и упорядочивает все этапы на телефоне.")](passkit-images/image1.png#lightbox)

## <a name="requirements"></a>Требования

Для функций PassKit, обсуждаемых в этом документе, требуется iOS 6 и Xcode 4,5, а также Xamarin. iOS 6,0.

## <a name="introduction"></a>Вступление

Ключевой проблемой, решаемой PassKit, является распространение и управление штрихкодами. Ниже приведены некоторые реальные примеры использования штрихкодов в настоящее время.

- **Приобретение билетов фильмов в Интернете** — клиенты обычно отправляют по электронной почте штрихкод, представляющий свои билеты. Этот штрихкод выводится и записывается в кинотеатр, чтобы просканировать запись.
- **Карты по программе лояльности** . клиенты содержат несколько различных карточек, относящихся к магазину, в бумажнике или роняет для просмотра и сканирования при покупке товаров.
- **Купоны** — купоны распределяются по электронной почте, как печатные веб-страницы, через леттербоксес и в виде штрихкодов в газетах и журналах. Клиенты переносят их в магазин для сканирования, чтобы получать товары, Услуги или скидки в обратном виде.
- **Передача на доску** — аналогично приобретению билета фильма.

PassKit предлагает альтернативу для каждого из этих сценариев:

- **Билеты фильмов** — после покупки клиент добавляет новый билет события (по электронной почте или через ссылку на веб-сайт). По мере приближения к фильмам этот этап будет автоматически отображаться на экране блокировки в виде напоминания, а при поступлении в кинотеатр он легко извлекается и отображается в бумажнике для сканирования.
- **Карты постоянного клиента** — а не (или в дополнение к), которые предоставляют физическую карту, могут выдавать проблемы (по электронной почте или после входа веб-сайта) на этап карты магазина. Магазин может предоставлять дополнительные функции, такие как обновление баланса учетной записи при передаче через push-уведомления, а также использование служб географического расположения. Этот проход может автоматически появиться на экране блокировки, когда клиент находится ближе к месту хранения.
- **Купоны — можно** легко создавать собственные функции с уникальными характеристиками для отслеживания и распространения по электронной почте или через связи веб-сайтов. Загруженные купоны могут автоматически отображаться на экране блокировки, когда пользователь находится ближе к определенному месту, и (или) на заданную дату (например, когда приближается дата истечения срока действия). Так как купоны хранятся на телефоне пользователя, они всегда полезны и не перемещаются. Купоны могут рекомендовать клиентам скачивать сопутствующие приложения, так как ссылки на App Store можно включить в проход, увеличивая уровень участия с клиентом.
- **Передача на доску** — после возврата в оперативный режим клиент получит свой проход по электронной почте или через ссылку. Вспомогательное приложение, предоставляемое поставщиком транспорта, может включать в себя процесс возврата, а также позволяет клиенту выполнять дополнительные функции, такие как выбор места или еды. Поставщик транспорта может использовать push-уведомления для обновления передачи, если транспорт откладывается или отменяется. Так как время, проводимое на доску, будет отображаться на экране блокировки в виде напоминания и предоставить быстрый доступ к успеху.

По сути, PassKit предоставляет простой и удобный способ хранения и вывода штрихкодов на устройстве iOS. Благодаря дополнительным сведениям о времени и расположении блокировки на экране, Push-уведомления и сопутствующие приложения интегрируются в основу для очень сложных служб продаж, билетов и выставления счетов.

## <a name="passkit-ecosystem"></a>Экосистема PassKit

PassKit — не просто API в Кокоатауч, он является частью более крупной экосистемы приложений, данных и служб, которые упрощают безопасный общий доступ и управление штрихкодами и другими данными. На этой высокоуровневой схеме показаны различные сущности, которые могут быть задействованы при создании и использовании проходов:

 [![](passkit-images/image2.png "На этой высокоуровневой схеме показаны сущности, участвующие в создании и использовании проходов.")](passkit-images/image2.png#lightbox)

Каждая часть экосистемы имеет четко определенную роль:

- **Бумажник** — встроенное приложение Apple для iOS, которое хранит и отображает передаваемые приложения. Это единственное место, которое передается для использования в реальном мире (IE отображается штрихкод, а также все локализованные данные на этом этапе).
- **Сопутствующие приложения** — приложения iOS 6, созданные с помощью Pass providers для расширения функциональных возможностей находящихся в них данных, таких как добавление ценности в карточку магазина, изменение места на входе в систему или другая функция для конкретного бизнеса. Для успешного использования сопутствующих приложений не требуется.
- **Ваш сервер** — безопасный сервер, на котором можно создавать и подписываться для распространения. Ваше вспомогательное приложение может подключаться к серверу для создания новых проходов или запроса обновлений для существующих проходов. При необходимости можно реализовать API веб-службы, который будет вызываться с помощью бумажника для передачи обновлений.
- **Серверы APNs** — сервер может уведомлять об изменениях в бумажнике на заданном устройстве с помощью APNs. Отправка уведомления в бумажник, который затем свяжется с сервером для получения сведений об изменении. Сопутствующим приложениям не требуется реализовывать APN для этой функции (они могут прослушивать `PKPassLibraryDidChangeNotification` ).
- **Приложения** для управления каналом — приложения, которые не управляют передачей напрямую (например, сопутствующие приложения), но которые могут улучшить свою служебную программу, распознающие их и добавив в бумажник. Почтовые клиенты, обозреватели социальных сетей и другие приложения для объединения данных могут столкнуться с вложениями или связями.

Вся экосистема выглядит сложной, поэтому стоит отметить, что некоторые компоненты являются необязательными и гораздо более простые реализации PassKit.

## <a name="what-is-a-pass"></a>Что такое Pass?

Проход — это коллекция данных, представляющих билет, купон или карточку. Оно может быть предназначено для отдельного использования отдельным пользователем (и, следовательно, содержит такие сведения, как номер рейса и выделение места на нем), или может использоваться несколькими маркерами использования, которые могут совместно использоваться любым количеством пользователей (например, купоном скидки). Подробное описание доступно в документе Apple [о Pass Files](https://developer.apple.com/library/prerelease/ios/#documentation/UserExperience/Reference/PassKit_Bundle/Chapters/Introduction.html) .

### <a name="types"></a>Типы

Сейчас пять поддерживаемых типов, которые могут различаться в приложении бумажника макетом и верхним краями прохода:

- **Билет события** — небольшие пользовательская полукруглаяные отрезки.
- **Проход на доске** — на стороне можно указать значок транспорта (например, шина, обучение, самолет.
- **Карточка магазина** — округление вверх, например кредитная или дебетовая карта.
- **Купон** — перфорированный в верхней части.
- **Универсальный** — то же, что и карточка магазина, округляется сверху.

На этом снимке экрана показаны пять типов Pass (в порядке: купон, универсальный, карта магазина, проход на доске и билет события):

 [![](passkit-images/image3.png "На этом снимке экрана показаны пять типов Pass.")](passkit-images/image3.png#lightbox)

### <a name="file-structure"></a>Структура файла

Транзитный файл на самом деле является ZIP-архивом с расширением **пкпасс** , содержащим определенные файлы JSON (обязательные), разнообразные файлы изображений (необязательно), а также локализованные строки (также необязательно).

- **Pass. JSON** — обязательный. Содержит все сведения для прохода.
- **manifest. JSON** — обязательный. Содержит хэши SHA1 для каждого файла в проходе, за исключением файла сигнатуры и этого файла (manifest. JSON).
- **подпись** — обязательное. Создается путем подписи `manifest.json` файла сертификатом, созданным на портале подготовки iOS.
- **Logo. png** — необязательно.
- **Background. png** — необязательный.
- **Icon. png** — необязательный.
- **Локализуемые строковые файлы** — необязательно.

Структура каталогов передаваемого файла показана ниже (содержимое ZIP-архива):

 [![](passkit-images/image4.png "Структура каталогов транзитного файла показана здесь")](passkit-images/image4.png#lightbox)

### <a name="passjson"></a>Pass. JSON

JSON — это формат, так как на сервере обычно выполняются проходы — это означает, что код поколения не зависит от платформы на сервере. Ниже приведены три ключевых фрагмента информации в каждом проходе.

- **теамидентифиер** — ссылки на все этапы, создаваемые в учетной записи магазина приложений. Это значение отображается на портале подготовки iOS.
- **пасстипеидентифиер** — регистрация на портале подготовки для объединения групп (если вы создаете более одного типа). Например, кафе может создать тип прохода карты магазина, чтобы позволить своим клиентам получать кредиты по программе лояльности, а также отдельный тип Pass для создания и распространения купонов на скидку. Тот же магазин кофе может даже хранить мероприятия в реальном времени и выдавать заявки на получение билетов на события.
- **SerialNumber** — уникальная строка в этом `passTypeidentifier` объекте. Значение является непрозрачным для бумажника, но важно для отслеживания конкретных проходов при взаимодействии с сервером.

В каждом проходе каждого прохода имеется большое количество других ключей JSON, пример которых показан ниже:

``` 
{
   "passTypeIdentifier":"com.xamarin.passkitdoc.banana",  //Type Identifier (iOS Provisioning Portal)
   "formatVersion":1,                                     //Always 1 (for now)
   "organizationName":"Xamarin",                          //The name which appears on push notifications
   "serialNumber":"12345436XYZ",                          //A number for you to identify this pass
   "teamIdentifier":"XXXAAA1234",                         //Your Team ID
   "description":"Xamarin Demo",                          //
   "foregroundColor":"rgb(54,80,255)",                    //color of the data text (note the syntax)
   "backgroundColor":"rgb(209,255,247)",                  //color of the background
   "labelColor":"rgb(255,15,15)",                         //color of label text and icons
   "logoText":"Banana ",                                  //Text that appears next to logo on top
   "barcode":{                                            //Specification of the barcode (optional)
      "format":"PKBarcodeFormatQR",                       //Format can be QR, Text, Aztec, PDF417
      "message":"FREE-BANANA",                            //What to encode in barcode
      "messageEncoding":"iso-8859-1"                      //Encoding of the message
   },
   "relevantDate":"2012-09-15T15:15Z",                    //When to show pass on screen. ISO8601 formatted.
  /* The following fields are specific to which type of pass. The name of this object specifies the type, e.g., boardingPass below implies this is a boarding pass. Other options include storeCard, generic, coupon, and eventTicket */
   "boardingPass":{
/*headerFields, primaryFields, secondaryFields, and auxiliaryFields are arrays of field object. Each field has a key, label, and value*/
      "headerFields":[          //Header fields appear next to logoText
         {
            "key":"h1-label",   //Must be unique. Used by iOS apps to get the data.
            "label":"H1-label", //Label of the field
            "value":"H1"        //The actual data in the field
         },
         {
            "key":"h2-label",
            "label":"H2-label",
            "value":"H2"
         }
      ],
      "primaryFields":[       //Appearance differs based on pass type
         {
            "key":"p1-label",
            "label":"P1-label",
            "value":"P1"
         }
      ],
      "secondaryFields":[     //Typically appear below primaryFields
         {
            "key":"s1-label",
            "label":"S1-label",
            "value":"S1"
         }
      ],
      "auxiliaryFields":[    //Appear below secondary fields
         {
            "key":"a1-label",
            "label":"A1-label",
            "value":"A1"
         }
      ],
      "transitType":"PKTransitTypeAir"  //Only present in boradingPass type. Value can
                                        //Air, Bus, Boat, or Train. Impacts the picture
                                        //that shows in the middle of the pass.
   }
}
```

### <a name="barcodes"></a>Штрихкоды

Поддерживаются только двумерные форматы: PDF417, Азтек, QR. Заявки Apple, которые не входят в набор штрихкодов для сканирования на экране с подсветкой телефона.

Альтернативный текст, отображаемый под штрихкодом, является необязательным — некоторые продавцы хотят иметь возможность считывать и вводить вручную.

Наиболее распространенная кодировка ISO-8859-1 — Проверка того, какая кодировка используется системами сканирования, которые будут считывать ваши этапы.

### <a name="relevancy-lock-screen"></a>Релевантность (экран блокировки)

Существует два типа данных, которые могут привести к отображению передачи на экране блокировки:

 **Location**

Можно указать до 10 расположений в Pass, например, хранить данные о частом посещении клиента или о расположении рекламы или аэропорта. Клиент может задать эти расположения с помощью вспомогательного приложения, или поставщик может определить их на основе данных об использовании (если они собраны с разрешением клиента).

Когда передача отображается на экране блокировки, вычисляется ограждение, так что когда пользователь покидает область, этот проход скрыт от экрана блокировки. Чтобы предотвратить нарушение, радиус привязан к стилю передачи.

 **Дата и время**

В Pass можно указать только одно значение даты и времени. Дата и время используются для активации напоминаний на экране блокировки для проходов по доске и билетов на события.

Можно обновить с помощью Push или через API PassKit, чтобы дата и время могли быть обновлены в случае использования билета с несколькими случаями (например, билет сезона в режим театра или спортивных сложных).

### <a name="localization"></a>Локализация

Преобразование передачи на несколько языков аналогично локализации приложения iOS — создание каталогов на языке с `.lproj` расширением и размещение локализованных элементов внутри. Переводы текста должны вводиться в `pass.strings` файл, а локализованные изображения должны иметь то же имя, что и образ, заменяющий в корне Pass.

## <a name="security"></a>Безопасность

Проходы подписываются с помощью частного сертификата, созданного на портале подготовки iOS. Ниже приведены действия для подписания прохода.

1. Вычислите хэш SHA1 для каждого файла в транзитном каталоге (не включайте `manifest.json` файл или `signature` , ни один из которых не должен существовать на этом этапе).
1. Напишите `manifest.json` в виде списка ключей и значений JSON каждого имени файла с его хэшем.
1. Используйте сертификат, чтобы подписать `manifest.json` файл и записать результат в файл с именем. `signature`
1. Заархивируйте все содержимое и присвойте полученному файлу `.pkpass` расширение файла.

Так как ваш закрытый ключ необходим для подписания прохода, этот процесс следует выполнять только на защищенном сервере, который контролируется. НЕ распространяйте ключи для попыток и создания проходов в приложении.

## <a name="configuration-and-setup"></a>Настройка и настройка

В этом разделе содержатся инструкции по настройке данных подготовки и созданию первого прохода.

### <a name="provisioning-passkit"></a>Подготовка PassKit

Чтобы передать возможность войти в App Store, она должна быть связана с учетной записью разработчика. Для этого требуется выполнить два действия:

1. Этот проход должен быть зарегистрирован с использованием уникального идентификатора, который называется ИДЕНТИФИКАТОРом типа Pass.
1. Чтобы подписать проход с помощью цифровой подписи разработчика, необходимо создать действительный сертификат.

Чтобы создать идентификатор типа Pass, выполните следующие действия.

#### <a name="create-a-pass-type-id"></a>Создание идентификатора типа прохода

Первым шагом является Настройка идентификатора типа Pass для каждого поддерживаемого _типа_ передачи. Идентификатор передачи (или идентификатор типа передачи) создает уникальный идентификатор для прохода. Мы будем использовать этот идентификатор для связи передачи с учетной записью разработчика с помощью сертификата.

1. В [разделе Сертификаты, идентификаторы и профили на портале подготовки iOS](https://developer.apple.com/account/overview.action)перейдите в раздел **идентификаторы** и выберите **тип передачи идентификаторов** . Затем нажмите кнопку, чтобы создать новый тип передачи: **+** [![](passkit-images/passid.png "Создать новый тип передачи")](passkit-images/passid.png#lightbox)

2. Введите **Описание** (имя) и **идентификатор** (уникальную строку) для прохода. Обратите внимание, что все идентификаторы типа Pass должны `pass.` начинаться со строки в `pass.com.xamarin.coupon.banana` этом примере используется: [![](passkit-images/register.png "Введите описание и идентификатор")](passkit-images/register.png#lightbox)

3. Подтвердите идентификатор Pass, нажав кнопку **Register (зарегистрировать** ).

#### <a name="generate-a-certificate"></a>Создание сертификата

Чтобы создать новый сертификат для этого идентификатора типа передачи, выполните следующие действия.

1. Выберите только что созданный идентификатор прохода из списка и нажмите кнопку **изменить** . [![](passkit-images/pass-done.png "Выберите новый идентификатор Pass из списка")](passkit-images/pass-done.png#lightbox)

    Затем выберите **создать сертификат...** :

    [![](passkit-images/cert-dist.png "Выберите создать сертификат.")](passkit-images/cert-dist.png#lightbox)

2. Выполните действия, чтобы создать запрос подписи сертификата (CSR).
  
3. Нажмите кнопку **продолжить** на портале разработчика и отправьте CSR, чтобы создать сертификат.

4. Скачайте сертификат и дважды щелкните его, чтобы установить его в цепочке ключей.

Теперь, когда мы создали сертификат для этого идентификатора типа Pass, в следующем разделе описано, как создать проход вручную.

Дополнительные сведения о подготовке для бумажника см. в руководстве по [работе с возможностями](~/ios/deploy-test/provisioning/capabilities/wallet-capabilities.md) .

### <a name="create-a-pass-manually"></a>Создание прохода вручную

Теперь, когда мы создали тип Pass, можно вручную создать проход для тестирования на симуляторе или устройстве. Шаги по созданию прохода:

- Создайте каталог, содержащий файлы Pass.
- Создайте файл Pass. JSON, содержащий все необходимые данные.
- Включить изображения в папку (при необходимости).
- Вычислите хэши SHA1 для каждого файла в папке и запишите в файл manifest. JSON.
- Подпишите manifest. JSON с скачанным файлом Certificate. p12.
- Заархивировать содержимое каталога и переименовать его с расширением. пкпасс.

В [образце кода](https://docs.microsoft.com/samples/xamarin/ios-samples/passkit) для этой статьи есть некоторые исходные файлы, которые можно использовать для создания прохода. Используйте файлы в `CouponBanana.raw` каталоге каталога креатеапассмануалли. Имеются следующие файлы:

 [![](passkit-images/image18.png "Эти файлы существуют")](passkit-images/image18.png#lightbox)

Откройте Pass. JSON и измените JSON. Необходимо по крайней мере обновить `passTypeIdentifier` и `teamIdentifer` , чтобы соответствовать вашей учетной записи разработчика Apple.

```csharp
"passTypeIdentifier" : "pass.com.xamarin.coupon.banana",
"teamIdentifier" : "?????????",
```

Затем необходимо вычислить хэши для каждого файла и создать `manifest.json` файл. По завершении он будет выглядеть примерно следующим образом:

```csharp
{
  "icon@2x.png" : "30806547dcc6ee084a90210e2dc042d5d7d92a41",
  "icon.png" : "87e9ffb203beb2cce5de76113f8e9503aeab6ecc",
  "pass.json" : "c83cd1441c17ecc6c5911bae530d54500f57d9eb",
  "logo.png" : "b3cd8a488b0674ef4e7d941d5edbb4b5b0e6823f",
  "logo@2x.png" : "3ccd214765507f9eab7244acc54cc4ac733baf87"
}
```

Затем необходимо создать подпись для этого файла с помощью сертификата (P12-файла), созданного для этого идентификатора типа Pass.

#### <a name="signing-on-a-mac"></a>Вход на компьютер Mac

Загрузите **материалы о поддержке начального значения бумажника** на сайте [загрузки Apple](https://developer.apple.com/downloads/index.action?name=Passbook) . `signpass` Используйте средство, чтобы превратить папку в проход (при этом будут также вычислены хэши SHA1 и заархивировать выходные данные в пкпасс-файл).

#### <a name="testing"></a>Тестирование

Если вы изучите выходные данные этих средств (задав для файла имя. zip, а затем открыли его), вы увидите следующие файлы (Обратите внимание на добавление `manifest.json` файлов и `signature` ):

 [![](passkit-images/image19.png "Проверка выходных данных этих средств")](passkit-images/image19.png#lightbox)

После подписания ZIP-файла и его переименования (например, в `BananaCoupon.pkpass`) вы можете перетащить его в симулятор, чтобы протестировать, или отправить его самому себе для получения на реальном устройстве. Вы увидите экран, чтобы **Добавить** этот проход, как показано ниже.

 [![](passkit-images/image20.png "Добавление экрана Pass")](passkit-images/image20.png#lightbox)

Обычно процесс выполняется автоматически на сервере, однако создание вручную может быть вариантом для малых предприятий, которые используют только те купоны, для которых не требуется поддержка внутренних серверов.

## <a name="wallet"></a>Wallet

Бумажник — Центральная часть экосистемы PassKit. На этом снимке экрана показан пустой бумажник, а также показано, как выглядит список пройденных и отдельных проходов:

 [![](passkit-images/image21.png "На этом снимке экрана показан пустой бумажник, а также показано, как выглядит список пройденных и отдельных проходов")](passkit-images/image21.png#lightbox)

К функциям бумажника относятся:

- Это единственное место, которое передается при сканировании с помощью штрихкода.
- Пользователь может изменять параметры обновлений. Если параметр включен, Push-уведомления могут активировать обновления данных в ходе передачи.
- Пользователь может включить или отключить интеграцию с экраном блокировки. Если этот параметр включен, передача на экран блокировки автоматически отображается на основе соответствующих данных о времени и расположении, внедренных в проход.
- Обратная сторона прохода поддерживает опрашивающую-to-Refresh, если в Pass JSON указан URL-адрес Web-Server-.
- Сопутствующие приложения можно открыть (или скачать), если идентификатор приложения указан в Pass JSON.
- Проходы можно удалить (с помощью милыеного разбирает анимацию).

## <a name="adding-passes-into-wallet"></a>Добавление проходов в бумажник

Передача можно добавить в бумажник следующими способами:

- **Приложения** для передачи данных — они не управляют передачей напрямую, они просто загружают файлы и предоставляют пользователю возможность добавить их в бумажник. 

- **Сопутствующие приложения** — они пишутся поставщиками для распространения проходов и предлагают дополнительные функции для их просмотра или редактирования. Приложения Xamarin. iOS имеют полный доступ к API PassKit для создания и обработки проходов. Затем можно добавить в бумажник, `PKAddPassesViewController`используя. Этот процесс подробно описан в разделе " **сопутствующие приложения** " этого документа.

### <a name="conduit-applications"></a>Приложения для передачи

Приложения для передачи данных — это промежуточные приложения, которые могут проходить от имени пользователя и должны быть запрограммированы для распознавания их типа содержимого и предоставления функциональных возможностей для добавления в бумажник. Примеры приложений для многопрограммной передачи:

- **Почта** — распознает вложение как проход.
- **Safari** — распознает тип содержимого Pass при нажатии ссылки на транзитный URL-адрес.
- **Другие пользовательские приложения** — любое приложение, которое получает вложения или открытые ссылки (клиенты социальных сетей, средства чтения почты и т. д.).

На этом снимке экрана показано, как **почта** в iOS 6 распознает вложенное вложение и (при его наличии) предложение **Добавить** его в бумажник.

 [![](passkit-images/image22.png "На этом снимке экрана показано, как почта в iOS 6 распознает вложенное вложение")](passkit-images/image22.png#lightbox)

 [![](passkit-images/image23.png "На этом снимке экрана показано, как почта предлагает добавить вложенное вложение в бумажник.")](passkit-images/image23.png#lightbox)

Если вы создаете приложение, которое может быть каналом передачи, его можно распознать следующим образом:

- **Расширение файла** —. пкпасс
- **Тип MIME** — application/vnd. Apple. пкпасс
- **UTI** — com. Apple. пкпасс

Основной операцией приложения-получателя является получение файла Pass и вызов PassKit `PKAddPassesViewController` , чтобы предоставить пользователю возможность добавить передачу в бумажник. Реализация этого контроллера представления рассматривается в следующем разделе **сопутствующих приложений**.

Приложения для передачи не обязательно должны быть подготовлены для определенного идентификатора типа Pass таким же образом, как и сопутствующие приложения.

## <a name="companion-applications"></a>Сопутствующие приложения

Сопутствующее приложение предоставляет дополнительные функциональные возможности для работы с передачами, включая создание прохода, обновление сведений, связанных с проходом, и иным образом управляет передачей, связанными с приложением.

Сопутствующие приложения не должны пытаться дублировать функции бумажника. Они не предназначены для показа прохождения проверки.

В этом оставшейся части этого раздела описывается создание базового сопутствующего приложения, взаимодействующего с PassKit.

### <a name="provisioning"></a>Подготовка

Поскольку бумажник — это технология хранения, приложение необходимо подготовить отдельно и не может использовать профиль подготовки группы или идентификатор приложения с подстановочными знаками. Сведения о создании уникального идентификатора приложения и профиля подготовки для приложения бумажника см. в руководстве по [работе с возможностями](~/ios/deploy-test/provisioning/capabilities/wallet-capabilities.md) .

### <a name="entitlements"></a>Прав

Файл прав **. plist** должен быть добавлен во все последние проекты Xamarin. iOS. Чтобы добавить новый файл прав. plist, выполните действия, описанные в руководстве по [работе с](~/ios/deploy-test/provisioning/entitlements.md) назначениями.

Чтобы задать права, выполните следующие действия.

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

Дважды щелкните файл прав **. plist** в панель решения, чтобы открыть редактор прав. plist:

![](passkit-images/image31.png "Права. редактор плст")

В разделе "Бумажник" выберите параметр **включить бумажник** .

![](passkit-images/image32.png "Включить право на бумажник")

Параметр по умолчанию для приложения разрешает все типы Pass. Однако можно ограничить приложение и разрешить только подмножество типов проходов команды. Чтобы включить этот параметр, установите флажок **Разрешить подмножество типов проходов команды** и введите идентификатор типа прохода подмножества, которое вы хотите разрешить.

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

Дважды щелкните файл прав **. plist** , чтобы открыть исходный XML-файл.

Чтобы добавить право на бумажник, задайте `Passbook Identifiers` для **Свойства** значение в раскрывающемся списке, который автоматически установит **тип** `Array`. Затем задайте строковое **значение** `$(TeamIdentifierPrefix)*`:

![](passkit-images/image33.png "Включить право на бумажник")

Это позволит вашему приложение работать со всеми типами карт. Чтобы ограничить приложение и разрешить только подмножество типов проходов команды, задайте строковое значение следующим образом:

`$(TeamIdentifierPrefix)pass.$(CFBundleIdentifier)`

Где `pass.$(CFBundleIdentifier)` — это идентификатор передачи, который был создан [выше](~/ios/platform/passkit.md)

-----

### <a name="debugging"></a>Отладка

Если у вас возникли проблемы при развертывании приложения, убедитесь, что вы используете правильный **профиль подготовки** и `Entitlements.plist` выбрано в качестве файла **настраиваемых** прав в параметрах **подписи пакета iPhone** .

При возникновении этой ошибки при развертывании:

```csharp
Installation failed: Your code signing/provisioning profiles are not correctly configured (error: 0xe8008016)
```

в этом `pass-type-identifiers` случае массив прав неверен (или не соответствует **профилю подготовки**). Проверьте правильность идентификаторов типа Pass и идентификатора команды.

## <a name="classes"></a>Классы

Для доступа к передачам приложения доступны следующие классы PassKit:

- **Пкпасс** — экземпляр прохода.
- **Пкпасслибрари** — предоставляет API для доступа к проходам на устройстве.
- **Пкаддпассесвиевконтроллер** — используется для показа пользователя, который должен сохранять пользователь в бумажнике.
- **Пкаддпассесвиевконтроллерделегате** — разработчики Xamarin. iOS

## <a name="example"></a>Пример

См. Проект Пасслибрари в [образце кода](https://docs.microsoft.com/samples/xamarin/ios-samples/passkit) для этой статьи. В нем демонстрируются следующие общие функции, которые потребуются в приложении-компаньоне бумажника:

### <a name="check-that-wallet-is-available"></a>Проверка доступности бумажника

Бумажник недоступен на iPad, поэтому приложения должны проверить, прежде чем пытаться получить доступ к функциям PassKit.

```csharp
if (PKPassLibrary.IsAvailable) {
    // create an instance and do stuff...
}
```

### <a name="creating-a-pass-library-instance"></a>Создание экземпляра Pass-Library

Библиотека PassKit не является singleton, приложения должны создавать и хранить и использовать экземпляр для доступа к API PassKit.

```csharp
if (PKPassLibrary.IsAvailable) {
    library = new PKPassLibrary ();
    // do stuff...
}
```

### <a name="get-a-list-of-passes"></a>Получение списка проходов

Приложения могут запрашивать список проходов из библиотеки. Этот список автоматически фильтруется по PassKit, чтобы можно было видеть только те проходы, которые были созданы с помощью идентификатора команды и указаны в ваших правах.

```csharp
var passes = library.GetPasses ();  // returns PKPass[]
```

Обратите внимание, что симулятор не фильтрует список возвращаемых проходов, поэтому этот метод всегда должен быть протестирован на реальных устройствах. Этот список можно отобразить в Уитаблевиев. После добавления двух купонов [пример приложения](https://docs.microsoft.com/samples/xamarin/ios-samples/passkit) выглядит следующим образом:

 [![](passkit-images/image29.png "Пример приложения выглядит следующим образом после добавления двух купонов")](passkit-images/image29.png#lightbox)

### <a name="displaying-passes"></a>Отображение проходов

Ограниченный набор сведений можно использовать для подготовки к просмотру проходов в сопутствующих приложениях.

Выберите из этого набора стандартных свойств, чтобы отображать списки проходов, как это делается в примере кода.

```csharp
string passInfo =
                "Desc:" + pass.LocalizedDescription
                + "\nOrg:" + pass.OrganizationName
                + "\nID:" + pass.PassTypeIdentifier
                + "\nDate:" + pass.RelevantDate
                + "\nWSUrl:" + pass.WebServiceUrl
                + "\n#" + pass.SerialNumber
                + "\nPassUrl:" + pass.PassUrl;
```

Эта строка отображается как предупреждение в [примере](https://docs.microsoft.com/samples/xamarin/ios-samples/passkit):

 [![](passkit-images/image30.png "Выбранный купон оповещение в образце")](passkit-images/image30.png#lightbox)

Можно также использовать `LocalizedValueForFieldKey()` метод для получения данных из полей в разрабатываемых вами обработах (так как вы узнаете, какие поля должны присутствовать). В примере кода это не показано.

### <a name="loading-a-pass-from-a-file"></a>Загрузка передачи из файла

Так как проход можно добавить только в бумажник с разрешением пользователя, необходимо предоставить контроллер представления, чтобы позволить им принять решение. Этот код используется при нажатии кнопки **Добавить** в примере для загрузки предварительно созданного этапа, внедренного в приложение (необходимо заменить его на подписанный):

```csharp
NSData nsdata;
using ( FileStream oStream = File.Open (newFilePath, FileMode.Open ) ) {
        nsdata = NSData.FromStream ( oStream );
}
var err = new NSError(new NSString("42"), -42);
var newPass = new PKPass(nsdata,out err);
var pkapvc = new PKAddPassesViewController(newPass);
NavigationController.PresentModalViewController (pkapvc, true);
```

Этот проход представлен с помощью параметров **Add** и **Cancel** :

 [![](passkit-images/image20.png "Передача, представленная с помощью параметров Add и Cancel")](passkit-images/image20.png#lightbox)

### <a name="replace-an-existing-pass"></a>Замена существующего прохода

При замене существующего прохода не требуется разрешение пользователя, но если такой проход еще не существует, он завершится ошибкой.

```csharp
if (library.Contains (newPass)) {
     library.Replace (newPass);
}
```

### <a name="editing-a-pass"></a>Изменение прохода

Пкпасс не является изменяемым, поэтому нельзя обновить объекты Pass в коде. Чтобы изменить данные в Pass, приложение должно иметь доступ к веб-серверу, который может поддерживать запись и создавать новый файл Pass с обновленными значениями, которые приложение может скачать.

Создание файла Pass должно выполняться на сервере, так как они должны быть подписаны сертификатом, который должен храниться в частном и безопасном месте.

После создания обновленного файла Pass используйте `Replace` метод, чтобы перезаписать старые данные на устройстве.

### <a name="display-a-pass-for-scanning"></a>Отображение прохода для сканирования

Как отмечалось ранее, только бумажник может отображать проход для сканирования. Проход можно отобразить с помощью `OpenUrl` метода, как показано ниже.

 `UIApplication.SharedApplication.OpenUrl (p.PassUrl);`

### <a name="receiving-notifications-of-changes"></a>Получение уведомлений об изменениях

Приложения могут прослушивать изменения, вносимые в библиотеку Pass с помощью `PKPassLibraryDidChangeNotification`. Изменения могут быть вызваны уведомлениями, запускающими обновления в фоновом режиме, поэтому рекомендуется прослушивать их в приложении.

```csharp
noteCenter = NSNotificationCenter.DefaultCenter.AddObserver (PKPassLibrary.DidChangeNotification, (not) => {
    BeginInvokeOnMainThread (() => {
        new UIAlertView("Pass Library Changed", "Notification Received", null, "OK", null).Show();
        // refresh the list
        var passlist = library.GetPasses ();
        table.Source = new TableSource (passlist, library);
        table.ReloadData ();
    });
}, library);  // IMPORTANT: must pass the library in
```

При регистрации для уведомления важно передать экземпляр библиотеки, так как Пкпасслибрари не является singleton.

## <a name="server-processing"></a>Обработка на сервере

Подробное обсуждение создания серверного приложения для поддержки PassKit выходит за рамки этой вводной статьи.

См. раздел [DotNet-расчетной книжки](https://github.com/tomasmcguinness/dotnet-passbook) с открытым исходным C# кодом на стороне сервера.

## <a name="push-notifications"></a>Push-уведомления

Подробное обсуждение использования push-уведомлений для этапов обновления выходит за рамки этой вводной статьи.

Для реагирования на веб-запросы из бумажника, когда требуются обновления, необходимо реализовать API, подобный ОСТАВШИМся компанией Apple.

Дополнительные сведения см. в статье об [обновлении передовых](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/Updating.html#//apple_ref/doc/uid/TP40012195-CH5-SW1) руководств компании Apple.

## <a name="summary"></a>Сводка

В этой статье представлено описание некоторых причин, по которым она полезна и описывает различные части, которые необходимо реализовать для полноценного решения PassKit. В нем описаны шаги, необходимые для настройки учетной записи разработчика Apple на создание проходов, процесс выполнения прохода вручную, а также доступ к интерфейсам API PassKit из приложения Xamarin. iOS.

## <a name="related-links"></a>Связанные ссылки

- [Бумажник для разработчиков](https://developer.apple.com/wallet/)
- [Пример PassKit](https://docs.microsoft.com/samples/xamarin/ios-samples/passkit)
- [Руководством для разработчиков бумажника](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/index.html#//apple_ref/doc/uid/TP40012195-CH1-SW1)
- [Платформы — Apple Pay и бумажник (видео ВВДК)](https://developer.apple.com/videos/frameworks/apple-pay-and-wallet)
- [Справочник по PassKit Framework](https://developer.apple.com/library/prerelease/ios/#documentation/UserExperience/Reference/PassKit_Framework/_index.html)
- [Справочник по веб-службе расчетной книжки](https://developer.apple.com/library/prerelease/ios/#documentation/PassKit/Reference/PassKit_WebService/WebService.html)
- [О Pass Files](https://developer.apple.com/library/prerelease/ios/#documentation/UserExperience/Reference/PassKit_Bundle/Chapters/Introduction.html)
- [DotNet-расчетной книжки](https://github.com/tomasmcguinness/dotnet-passbook)— библиотека с открытым исходным кодом для создания пакетов бумажника для iOS
- [Введение в iOS 6](~/ios/platform/introduction-to-ios6/index.md)
