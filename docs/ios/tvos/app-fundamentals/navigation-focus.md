---
title: Работа с tvOS навигацией и фокусом в Xamarin
description: В этой статье рассматривается понятие фокуса и его использование для представления и управления навигацией в приложении Xamarin. tvOS.
ms.prod: xamarin
ms.assetid: DD72E95F-AE9B-47D2-B132-5FA5FBD8026E
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/16/2017
ms.openlocfilehash: 3c754acc3502d7aa2c47264e734187ffe060c029
ms.sourcegitcommit: eedc6032eb5328115cb0d99ca9c8de48be40b6fa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/07/2020
ms.locfileid: "78915772"
---
# <a name="working-with-tvos-navigation-and-focus-in-xamarin"></a>Работа с tvOS навигацией и фокусом в Xamarin

_В этой статье рассматривается понятие фокуса и его использование для представления и управления навигацией в приложении Xamarin. tvOS._

В этой статье рассматривается понятие [фокуса](#Focus-and-Selection) и его использование для управления [навигацией](#Navigation) в пользовательском интерфейсе приложения Xamarin. tvOS. Мы рассмотрим, как встроенные элементы управления навигацией tvOS используют фокус, выделение и выделение, чтобы обеспечить навигацию по пользовательскому интерфейсу приложения Xamarin. tvOS.

[![](navigation-focus-images/intro01.png "tvOS apps User Interface Navigation")](navigation-focus-images/intro01.png#lightbox)

Далее мы рассмотрим, как можно использовать [фокусировки](#Focus-and-Parallax) и *многослойные изображения* , чтобы дать визуальные подсказки для текущего состояния навигации конечному пользователю.

Наконец, мы рассмотрим работу с [фокусом](#Working-with-Focus), [обновлениями](#Working-with-Focus-Updates)фокуса, [направляющими фокуса](#Working-with-Focus-Guides), [сосредоточиться на коллекциях](#Working-with-Focus-in-Collections) и [включить фокусировки](#enabling-parallax) для представлений изображений в приложениях Xamarin. tvOS.

<a name="Navigation" />

## <a name="navigation"></a>Навигация

Пользователи приложения Xamarin. tvOS не будут взаимодействовать с интерфейсом напрямую, как с iOS, где они наследуют образы на экране устройства, но косвенно из комнаты, использующей [Удаленный Siri](~/ios/tvos/platform/remote-bluetooth.md#The-Siri-Remote). Это необходимо учитывать при проектировании пользовательского интерфейса приложения, чтобы он обходился естественным образом, но не оставался в процессе работы с Apple TV.

Успешное приложение tvOS реализует навигацию таким образом, чтобы она поддерживала назначение приложения и структуру данных, которые он представляет, не обращая внимание на саму навигацию. Разработайте навигацию так, чтобы она была естественным и знакомой, не выполняя никаких проблем с пользовательским интерфейсом или рисованием пользователей.

[![](navigation-focus-images/nav01.png "The tvOS settings app")](navigation-focus-images/nav01.png#lightbox)

При использовании Apple TV пользователь обычно переходит по набору экранов с накоплением, каждый из которых представляет определенный набор содержимого. В свою очередь, каждый новый экран может привести к одному или нескольким вложенным экранам содержимого с помощью стандартных элементов управления пользовательского интерфейса, таких как [кнопки](~/ios/tvos/user-interface/buttons.md), [панели вкладок](~/ios/tvos/user-interface/tab-bars.md), таблицы, [представления коллекций](~/ios/tvos/user-interface/collection-views.md) или [разделенные представления](~/ios/tvos/user-interface/split-views.md).

При каждом новом экране данных пользователь переходит на более глубокий взгляд в этот стек экранов. С помощью кнопки **меню** в Siri Remote можно перемещаться назад по стеку, чтобы вернуться к предыдущему экрану или главному меню.

При проектировании навигации для приложения tvOS компания Apple рекомендует учитывать следующее:

- **Разметка навигации для быстрого и простого поиска содержимого** в приложении с минимальным числом касаний, щелчков и пропусков. Упростите навигацию и упорядочивайте содержимое с минимальным количеством экранов.
- **Создавайте жидкий интерфейс с помощью сенсорного ввода** . Убедитесь, что пользователь может перемещаться между _фокусами_ с минимальными трениями, используя наименьшее число возможных жестов.
- **Разработка с учетом внимания** . Поскольку пользователь взаимодействует с содержимым в комнате, ему нужно переместить фокус на элемент пользовательского интерфейса, прежде чем взаимодействовать с ним с помощью Siri Remote. Пользователи будут разочарованы с приложением, если для них требуется слишком много жестов для достижения своих целей.
- **Обеспечить обратную навигацию с помощью кнопки меню** — создание простого и привычного интерфейса, позволяющего пользователям перемещаться назад с помощью кнопки **меню** удаленного Siri. Нажатие кнопки **меню** всегда должно вернуться к предыдущему экрану или вернуться к главному меню приложения. На верхнем уровне приложения нажатие кнопки **меню** должно вернуться на начальный экран Apple TV.
- **Обычно не удается отобразить кнопку «назад** », так как при нажатии кнопки **меню** на Siri удаленном переходе назад по стеку экрана не отображается дополнительный элемент управления, дублирующий это поведение. Исключением из этого правила является приобретение экранов или экранов с разрушительными действиями (например, удаление содержимого), где также должна отображаться кнопка **отмены** .
- **Отображать крупные коллекции на одном экране, а не многие** — Siri удаленно, что позволяет быстро и легко перемещаться по большому набору содержимого с помощью жестов. Если приложение работает с большой коллекцией фокусных элементов, рассмотрите возможность их сохранения на одном экране, вместо того чтобы разбивать их на несколько экранов, требующих больше возможностей для навигации по части пользователя.
- **Используйте стандартные элементы управления для навигации** . чтобы создать простой и привычный пользовательский интерфейс, везде, где это возможно, используйте встроенные `UIKit` элементы управления, такие как элементы управления страницы, панели вкладок, сегментированные элементы управления, табличные представления, представления коллекций и разделенные представления для навигации приложения. Поскольку пользователь уже знаком с этими элементами, они интуитивно смогут осуществлять навигацию по приложению.
- **Предпочитать навигацию по горизонтали** . из-за особенностей Apple TV прокрутка влево направо на Siri удаленнее, чем вверх и вниз. Этот вариант следует рассматривать при проектировании макетов содержимого для приложения.

<a name="Focus-and-Selection" />

## <a name="focus-and-selection"></a>Фокус и выбор

На Apple TV изображение, кнопка или другой элемент пользовательского интерфейса считаются _фокусом_ , если он является целевым объектом текущей навигации.

[![](navigation-focus-images/focus01.png "Focus and Selection example")](navigation-focus-images/focus01.png#lightbox)

В отличие от устройств iOS, где пользователь напрямую взаимодействует с элементами на сенсорном экране устройства, пользователи взаимодействуют с элементами tvOS из комнаты с помощью удаленного Siri. Для представления и управления этим взаимодействием с пользователем Apple TV использует модель на основе _фокуса_ .

Используя жесты и кнопки на [удаленном Siri](~/ios/tvos/platform/remote-bluetooth.md#The-Siri-Remote), пользователь перемещает фокус с одного элемента пользовательского интерфейса на другой. После того, как фокус перемещен на нужный элемент, пользователь выбирает содержимое или активирует действие, представленное этим элементом.

При изменении фокуса несложная анимация и эффекты (например, эффект фокусировки на изображениях) используются для четкого выделения элемента пользовательского интерфейса, который в данный момент находится в фокусе.

У Apple есть следующие рекомендации по работе с фокусом и выбором:

- **Использование встроенных элементов управления пользовательского интерфейса для эффектов движения** . с помощью `UIKit` и API фокусировки в пользовательском интерфейсе модель фокуса автоматически применяет эффекты движения и визуальных эффектов по умолчанию к элементам пользовательского интерфейса. Это делает ваше приложение неуправляемым и привычным для пользователей платформы Apple TV и обеспечивает возможность гибкого и интуитивно понятного перемещения между элементами, сфокусированными на фокусе.
- **Перемещение фокуса в ожидаемые направления** — на Apple TV почти каждый элемент использует косвенную манипуляцию. Например, пользователь использует удаленную Siri для перемещения фокуса, и система автоматически прокручивает интерфейс, чтобы он оставался видимым в текущий момент. Если приложение реализует этот тип взаимодействия, убедитесь, что фокус перемещается в направлении жеста пользователя. Таким образом, если пользователь проведите вправо к Siri удаленному фокусу, должен перейти вправо (что может привести к прокрутке экрана влево). Единственным исключением из этого правила являются полноэкранные элементы, использующие прямую манипуляцию (где прокрутка вверх перемещает элемент вверх).
- **Убедитесь, что элемент с упором является очевидным** , так как ваши пользователи взаимодействуют с элементами пользовательского интерфейса из afarština, крайне важно, чтобы элемент, который сейчас находится в данный момент, был недоступен. Обычно это будет обрабатываться автоматически встроенными `UIKit`ными элементами. Для отображения фокуса в пользовательских элементах управления используйте такие функции, как размер или тень элемента.
- **Используйте фокусировки, чтобы сделать элементы, реагирующие на запросы** , небольшими круговыми жестами на Siri удаленном результате в доброй, перемещении элемента с упором в режиме реального времени. Этот [фокусировкиный результат](#Focus-and-Parallax) встроен в _многослойные изображения_ `UIKit`, чтобы дать пользователю возможность подключиться к элементу, к которому осуществляется доступ.
- **Создание элементов с фокусом соответствующего размера** — крупные элементы с большим количеством расстояний проще выбирать и перемещать по меньшим элементам.
- **Разработка элемента пользовательского интерфейса для поиска хорошего или нефокусного ввода** . обычно Apple TV представляет сфокусированный элемент, увеличивая его размер. Убедитесь, что элементы пользовательского интерфейса ваших приложений отлично выглядят в любом размере презентации и, при необходимости, предоставляют активы для элементов большего размера.
- **Представление изменений фокуса** . Используйте анимацию для плавного исчезновения между **элементами с фокусом** и без **фокуса** , чтобы избежать жаррингя переходов.
- **Не отображать курсор** — пользователи хотят перемещаться по пользовательскому интерфейсу приложения с помощью фокуса, а не перемещать курсор по экрану. Пользовательский интерфейс всегда должен использовать модель фокусировки, чтобы предоставить единообразное взаимодействие с пользователем.

<a name="Working-with-Focus" />

### <a name="working-with-focus"></a>Работа с фокусом

Иногда требуется создать настраиваемый элемент управления, который может стать элементом, получающим фокус. Если это так, переопределите `CanBecomeFocused` свойство и возвратите `true`, иначе возвратите `false`. Например:

```csharp
public class myView : UIView
{
    public override bool CanBecomeFocused {
        get {return true;}
    }
}
```

В любой момент можно использовать свойство `Focused` элемента управления `UIKit`, чтобы определить, является ли он текущим элементом. Если `true` элемент пользовательского интерфейса в данный момент находится в фокусе, в противном случае — нет. Например:

```csharp
// Is my view in focus?
if (myView.Focused) {
    // Do something
    ...
}
```

Хотя вы не можете напрямую перемещать фокус на другой элемент пользовательского интерфейса с помощью кода, можно указать, какой элемент пользовательского интерфейса сначала получает фокус при загрузке экрана, присвоив свойству `PreferredFocusedView` значение `true`. Например:

```csharp
// Make the play button the starting focus item
playButton.PreferredFocusedView = true;
```

<a name="Working-with-Focus-Updates" />

### <a name="working-with-focus-updates"></a>Работа с обновлениями фокуса 

Когда пользователь заставляет перемещаться от одного элемента пользовательского интерфейса к другому (например, в ответ на жест на Siri удаленном), _событие обновления фокуса_ будет отправлено как к потере фокуса, так и к элементу, получающему фокус.

Для настраиваемых элементов, которые наследуют от `UIView` или `UIViewController`, можно переопределить несколько методов для работы с событием обновления фокуса:

- **Дидупдатефокус** — этот метод будет вызываться каждый раз, когда представление получает или теряет фокус.
- **Шаулдупдатефокус** — используйте этот метод, чтобы определить, где разрешено перемещение фокуса.

Чтобы запросить, что обработчик фокуса перемещает фокус обратно в элемент пользовательского интерфейса `PreferredFocusedView`, вызовите метод `SetNeedsUpdateFocus` контроллера представления.

> [!IMPORTANT]
> Вызов `SetNeedsUpdateFocus` действует только в том случае, если контроллер представления, к которому он вызывается, содержит представление, в котором в данный момент находится фокус.

<a name="Working-with-Focus-Guides" />

### <a name="working-with-focus-guides"></a>Работа с направляющими фокуса

Подсистема фокусировки, встроенная в tvOS, отлично подходит для обработки перемещений между элементами, которые попадают в горизонтальную и вертикальную сетку. Как правило, необходимо сделать ничего больше, чем добавлять элементы пользовательского интерфейса в структуру интерфейса, и механизм фокуса автоматически будет выполнять перемещение между этими элементами без участия разработчика.

Однако возможны случаи, когда элементы ПОЛЬЗОВАТЕЛЬСКОГО интерфейса не попадают в горизонтальную и вертикальную сетку, но могут быть недоступны, поскольку они по диагонали являются недоступными. Это происходит потому, что обработчик фокуса разрабатывался для обработки простого, нижнего, левого и правого перемещения только между элементами пользовательского интерфейса.

Рассмотрим следующий макет пользовательского интерфейса в качестве примера:

 [![](navigation-focus-images/guide01.png "Working with Focus Guides example")](navigation-focus-images/guide01.png#lightbox)

Так как кнопка " **больше информации** " не находится на горизонтальной и вертикальной сетке с кнопкой " **купить** ", она будет недоступна пользователю. Тем не менее это можно легко исправить с помощью _фокусирования_ , чтобы предоставить подсказки о перемещении обработчику фокуса. 

Направляющая фокус (`UIFocusGuide`) предоставляет невидимую область представления в качестве фокуса подсистеме фокусировки, тем самым позволяя перенаправление фокуса на другое представление.

Таким образом, чтобы решить приведенный выше пример, в контроллер представления можно добавить следующий код, чтобы создать руководство по фокусу между кнопками " **больше информации** " и " **купить** ":

```csharp
public UIFocusGuide FocusGuide = new UIFocusGuide ();
...

public override void ViewDidLoad ()
{
    base.ViewDidLoad ();

    // Add Focus Guide to layout
    View.AddLayoutGuide (FocusGuide);

    // Define Focus Guide that will allow the user to move
    // between the More Info and Buy buttons.
    FocusGuide.LeftAnchor.ConstraintEqualTo (BuyButton.LeftAnchor).Active = true;
    FocusGuide.TopAnchor.ConstraintEqualTo (MoreInfoButton.TopAnchor).Active = true;
    FocusGuide.WidthAnchor.ConstraintEqualTo (BuyButton.WidthAnchor).Active = true;
    FocusGuide.HeightAnchor.ConstraintEqualTo (MoreInfoButton.HeightAnchor).Active = true;
}
```

Сначала создается новый `UIFocusGuide`, который добавляется в коллекцию руководств по макету представления с помощью метода `AddLayoutGuide`.

Далее все привязки верхнего, левого, ширины и высоты корректируются относительно **дополнительных сведений** и кнопок **покупки** для их позиционирования. См.

[![](navigation-focus-images/guide02.png "Example Focus Guide")](navigation-focus-images/guide02.png#lightbox)

Также важно отметить, что новые ограничения активируются при их создании, задав для свойства `Active` значение `true`.

```csharp
FocusGuide.LeftAnchor.ConstraintEqualTo (...).Active = true;
```

После того как новое руководство по фокусу установлено и Добавлено в представление, метод `DidUpdateFocus` контроллера представления может быть переопределен и добавлен следующий код для перемещения между кнопками " **больше информации** " и " **купить** ":

```csharp
public override void DidUpdateFocus (UIFocusUpdateContext context, UIFocusAnimationCoordinator coordinator)
{
    base.DidUpdateFocus (context, coordinator);

    // Get next focusable item from context
    var nextFocusableItem = context.NextFocusedView;

    // Anything to process?
    if (nextFocusableItem == null) return;

    // Decide the next focusable item based on the current
    // item with focus
    if (nextFocusableItem == MoreInfoButton) {
        // Move from the More Info to Buy button
        FocusGuide.PreferredFocusedView = BuyButton;
    } else if (nextFocusableItem == BuyButton) {
        // Move from the Buy to the More Info button
        FocusGuide.PreferredFocusedView = MoreInfoButton;
    } else {
        // No valid move
        FocusGuide.PreferredFocusedView = null;
    }
}
```

Во-первых, этот код получает `NextFocusedView` из переданного `UIFocusUpdateContext` (`context`). Если это представление `null`, то обработка не требуется и метод завершает работу.

Далее вычисляется `nextFocusableItem`. Если он совпадает с кнопками " **больше информации** " или " **купить** ", фокус передается обратной кнопке с помощью свойства `PreferredFocusedView` в разделе "Фокус". Например:

```csharp
// Move from the More Info to Buy button
FocusGuide.PreferredFocusedView = BuyButton;
```

В случае, если ни одна из кнопок не является источником смены фокуса, свойство `PreferredFocusedView` снимается:

```csharp
// No valid move
FocusGuide.PreferredFocusedView = null;
```

<a name="Working-with-Focus-in-Collections" />

### <a name="working-with-focus-in-collections"></a>Работа с фокусом в коллекциях

При принятии решения о том, может ли отдельный элемент быть доступен в `UICollectionView` или `UITableView`, вы переопределяете методы `UICollectionViewDelegate` или `UITableViewDelegate` соответственно. Например:

```csharp
public class CardHandDelegate : UICollectionViewDelegateFlowLayout
{
    ...
    public override bool CanFocusItem (UICollectionView collectionView, NSIndexPath indexPath)
    {
        if (indexPath == null) {
            return false;
        } else {
            var controller = collectionView as CardHandViewController;
            return !controller.Hand [indexPath.Row].IsFaceDown;
        }
    }
}
```

Метод `CanFocusItem` возвращает `true`, если текущий элемент может находиться в фокусе, в противном случае возвращает `false`.

Если вы хотите, чтобы `UICollectionView` или `UITableView` запомнили и восстановите фокус на последнем элементе при потере и восстановлении фокуса, установите для свойства `RemembersLastFocusedIndexPath` значение `true`.

<a name="Focus-and-Parallax" />

## <a name="focus-and-parallax"></a>Фокус и фокусировки

Как упоминалось выше, элемент пользовательского интерфейса считается _фокусом_ , когда он является текущим элементом во время события навигации. Как правило, элемент находится в фокусе, его размер немного увеличивается и визуально повышается с помощью тени. 

Если пользователь делает циклический круглый жест на пульте дистанционного Siri, в ответ на это перемещение элементу с упором будет Sway в реальном времени. По мере появления Sway к его изображению применяется освещенная зона, что делает поверхность ненужной. По истечении определенного периода бездействия любое содержимое, не имеющее фокуса, становится неактивным, а элемент с фокусом увеличивается еще больше. 

Эти эффекты работают вместе, чтобы обеспечить возможность подключения к содержимому на экране телевизора и пользователю, работающему с Apple TV, с дивана.

На Apple TV этот фокусировки эффект используется во всей системе для передачи смысла трехмерной глубины и динамических элементов в фокусы. tvOS использует ряд прозрачных [многослойных изображений](~/ios/tvos/app-fundamentals/icons-images.md#Layered-Images) , которые он перемещает и масштабирует динамически для создания этого результата.

Многоуровневые изображения необходимы для значка приложения tvOS и поддерживаются для динамического наполнения заглавных полок. В то время как это не требуется, Apple настоятельно предлагает реализовать многослойные изображения в любых других фокусных элементах в пользовательском интерфейсе приложения.

### <a name="enabling-parallax"></a>Включение фокусировки

Элемент управления `UIImageView` (или любой элемент управления, наследующий от `UIImageView`) автоматически поддерживает Фокусировкиный результат. По умолчанию эта поддержка отключена, чтобы включить ее, используйте следующий код:

```csharp
myImageView.AdjustsImageWhenAncestorFocused = true;
```

Если этому свойству присвоено значение `true`, представление изображений автоматически получит результат фокусировки, когда он будет выбран пользователем и в фокусе.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье рассматривается понятие фокуса и его использование для управления навигацией в пользовательском интерфейсе приложения Xamarin. tvOS. Изучите, как встроенные элементы управления навигацией tvOS используют фокус, выделение и выделение для обеспечения навигации. Далее мы рассмотрели, как можно использовать фокусировки и многослойные изображения, чтобы дать визуальные подсказки для текущего состояния навигации конечному пользователю. Наконец, он проверил работу с фокусом, сосредоточиться на обновлениях, сосредоточиться на коллекциях и включить фокусировки.

## <a name="related-links"></a>Связанные ссылки

- [Примеры tvOS](https://docs.microsoft.com/samples/browse/?products=xamarin&term=Xamarin.iOS+tvOS)
- [tvOS](https://developer.apple.com/tvos/)
- [Руководства по tvOSму интерфейсу](https://developer.apple.com/tvos/human-interface-guidelines/)
- [Руководством по программированию приложений для tvOS](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/)
