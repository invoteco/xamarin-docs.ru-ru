---
title: Работа с tvOSными представлениями с накоплением в Xamarin
description: В этом документе описывается, как работать с tvOSными представлениями с накоплением в приложении, созданном с помощью Xamarin. Он предоставляет общий обзор представлений с накоплением и обсуждает автоматическое размещение, размещение и определение размеров для представления с накоплением, общее использование, интеграцию с раскадровками и многое другое.
ms.prod: xamarin
ms.assetid: 00B07F85-F30B-4DD4-8664-A61D0A1CDB0E
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 03/16/2017
ms.openlocfilehash: a48e7bd780783a7b33008a5d86011f5497b042d5
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70287973"
---
# <a name="working-with-tvos-stacked-views-in-xamarin"></a>Работа с tvOSными представлениями с накоплением в Xamarin

Элемент управления "представление стека" (`UIStackView`) использует возможности классов автоматического макета и размера для управления стеком подпросмотров (горизонтально или вертикально), который динамически реагирует на изменения содержимого и размер экрана устройства Apple TV.

Макет всех вложенных представлений, присоединенных к представлению «стек», управляется на основе свойств, определенных разработчиком, таких как ось, распределение, выравнивание и отступы:

[![](stacked-views-images/stacked01.png "Диаграмма макета подпредставления")](stacked-views-images/stacked01.png#lightbox)

При использовании `UIStackView` в приложении Xamarin. tvOS разработчик может либо определять вложенные представления в раскадровке в конструкторе iOS, либо добавлять и удалять вложенные представления в C# коде.

## <a name="about-stacked-view-controls"></a>Сведения об элементах управления "представление с накоплением"

Класс предназначен для неотрисовки представления контейнера и поэтому не отображается на холсте, как и другие подклассы `UIView`. `UIStackView` Установка таких свойств, `BackgroundColor` как или переопределение `DrawRect` , не будет иметь визуального влияния.

Существует несколько свойств, которые управляют тем, как представление Stack будет упорядочивать коллекцию вложенных представлений:

- **Axis** — определяет, будет ли представление стека упорядочивать подпредставления **горизонтально** или **вертикально**.
- **Выравнивание** — управляет выравниванием вложенных представлений в представлении стека.
- **Распространение** — управляет изменением размера вложенных представлений в представлении стека.
- **Пробел** — управляет минимальным пространством между каждым подпредставлением в представлении Stack.
- **Относительное выравнивание по базовому плану** — если `true`по вертикали в каждом подпредставлении будет получен производный междустрочный пробел.
- **Поля макета относительные** — размещает подпредставления относительно стандартных полей макета.

Как правило, для размещения небольшого числа подпросмотров используется представление Stack. Более сложные пользовательские интерфейсы могут быть созданы путем вложения одного или нескольких представлений стеков друг в друга.

Можно настроить внешний вид пользовательского интерфейса, добавив дополнительные ограничения для подпредставлений (например, для управления высотой или шириной). Однако следует соблюдать осторожность, чтобы не включать конфликтующие ограничения для тех, которые появились в представлении стека.

<a name="Auto-Layout-and-Size-Classes" />

## <a name="auto-layout-and-size-classes"></a>Классы автоматического макета и размера

При добавлении вложенного представления в представление стека его макет полностью управляется этим представлением стека с помощью классов автомакета и размера для размещения и изменения размера упорядоченных представлений.

Представление "стек" _будет закреплять_ первое и Последнее вложенное представление в его коллекции по **верхнему** и **нижнему** краям для вертикальных представлений стека или по **левому** и **правому** краям для горизонтальных представлений стека. Если задать `LayoutMarginsRelativeArrangement` для `true`свойства значение, то представление закрепляет подпредставления на соответствующие поля, а не на границу.

Представление "стек" использует `IntrinsicContentSize` свойство подпредставления при вычислении размера подпредставлений по определенному `Axis` (за исключением `FillEqually Distribution`). Изменяет размеры всех подпросмотров таким образом, чтобы они совпадали с размером, таким образом заполняя представление Stack `Axis`вдоль. `FillEqually Distribution`

За исключением `Fill Alignment`, представление Stack использует `IntrinsicContentSize` свойство подпредставления для вычисления размера представления, перпендикулярного заданному `Axis`. Для все подпредставления имеют размер `Axis` ,чтобыонизаполнилипредставлениестека,перпендикулярноезаданному.`Fill Alignment`

<a name="Positioning-and-Sizing-the-Stack-View" />

## <a name="positioning-and-sizing-the-stack-view"></a>Размещение и изменение размера представления стека

В то время как представление Stack имеет полный контроль над разметкой любого вложенного представления (на основе `Axis` таких `Distribution`свойств, как и), необходимо по-прежнему располагать`UIStackView`представлением стека () в его родительском представлении, используя классы автоматической разметки и размера.

Как правило, это означает закрепление по крайней мере двух краев представления стека для расширения и контракта, тем самым определяя его расположение. Без каких бы то ни было дополнительных ограничений размер представления стека будет автоматически изменен в соответствии со всеми вложенными представлениями следующим образом:

- Размер по сравнению `Axis` с размером будет суммой всех размеров вложенного представления, а также любого пространства, определенного между каждым вложенным представлением.
- Если свойство имеет `true`значение, размер представлений стека также будет включать в себя пространство для полей. `LayoutMarginsRelativeArrangement`
- Размер, расположенный перпендикулярно `Axis` , будет установлен для самого крупного вложенного представления в коллекции.

Кроме того, можно указать ограничения для **высоты** и **ширины**представления стека. В этом случае вложенные представления будут размещены (в размере) для заполнения пространства, указанного в представлении стека, как определено `Distribution` свойствами и. `Alignment`

`true`-  Если свойство имеет значение, то подпредставления будут размещены на основе базовых показателей первого или последнего подпредставления вместо использования верхней, нижней или средней координаты Y. `BaselineRelativeArrangement` Они рассчитываются в содержимом представления стека следующим образом:

- Представление с вертикальным стеком вернет первое Подпредставление для первого базового плана и последний для последнего. Если одно из этих вложенных представлений является представлением стека, то будет использоваться их первый или последний базовый уровень.
- Горизонтальное представление стека будет использовать его самое высокое для первого и последнего базовых показателей. Если максимально высокое представление является также представлением стека, оно будет использовать его в качестве базового.

> [!IMPORTANT]
> Выравнивание по базовому плану не работает для размеров с растяжением или сжатого представления, так как базовый план вычисляется в соответствии с неверной позицией. Для выравнивания по базовому плану убедитесь, что **Высота** подпредставления совпадает с **высотой**внутреннего представления содержимого.




<a name="Common-Stack-View-Uses" />

## <a name="common-stack-view-uses"></a>Общее представление "стек" использует

Существует несколько типов макетов, которые хорошо подходят для элементов управления представления стека. В соответствии с Apple, вот несколько наиболее распространенных способов использования:

- **Определите размер вдоль оси** — закрепите оба края в представлении `Axis` стека и один из соседних границ, чтобы задать расположение. представление стека будет увеличиваться вдоль оси в соответствии с пространством, определенным во вложенных представлениях.
- **Определить расположение** вложенного представления. Закрепите к смежным краям представления стека до родительского представления, представление стека будет увеличиваться в обоих измерениях в соответствии с вложенными представлениями.
- **Определить размер и расположение стека** — закрепление всех четырех краев представления стека в родительском представлении. представление стека упорядочивает вложенные представления на основе пространства, определенного в представлении стека.
- **Определите размер перпендикулярно оси** — закрепите оба края, перпендикулярные области представления `Axis` стека, и один из граней вдоль оси, чтобы задать ее расположение, представление стека будет увеличиваться перпендикулярно оси в соответствии с пространством, определенным во вложенных представлениях.

<a name="Stack-Views-and-Storyboards" />

## <a name="stack-views-and-storyboards"></a>Представления стека и раскадровки

Самый простой способ работы с представлениями стека в приложении Xamarin. tvOS — добавить их в пользовательский интерфейс приложения с помощью конструктора iOS.

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

1. В **панель решения**дважды `Main.storyboard` щелкните файл и откройте его для редактирования.
1. Разработайте макет отдельных элементов, которые будут добавлены в представление "стек":

    [![](stacked-views-images/layout01.png "Пример макета элемента")](stacked-views-images/layout01.png#lightbox)
1. Добавьте к элементам необходимые ограничения, чтобы обеспечить их правильное масштабирование. Этот шаг важен после добавления элемента в представление стека.
1. Сделайте необходимое число копий (четыре в этом случае):

    [![](stacked-views-images/layout02.png "Необходимое число копий")](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **панели элементов** и поместите его в представление:

    [![](stacked-views-images/layout03.png "Представление \"стек\"")](stacked-views-images/layout03.png#lightbox)
1. Выберите представление стека на **вкладке мини** -приложение **панель свойств** выберите **заполнить** для **выравнивания**, **заполните равномерно** для **распределения** и введите `25` для **интервала**:

    [![](stacked-views-images/layout04.png "Вкладка мини-приложения")](stacked-views-images/layout04.png#lightbox)
1. Разместите представление стека на экране там, где оно нужно, и добавьте ограничения, чтобы они оставались в нужном месте.
1. Выберите отдельные элементы и перетащите их в представление "стек":

    [![](stacked-views-images/layout05.png "Отдельные элементы в представлении \"стек\"")](stacked-views-images/layout05.png#lightbox)
1. Макет будет скорректирован, и элементы будут упорядочены в представлении стека на основе атрибутов, заданных выше.
1. Назначьте **имена** на **вкладке мини** -приложение **обозревателя свойств** , чтобы работать с элементами управления пользовательского интерфейса C# в коде.
1. Сохраните изменения.

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

1. В **Обозреватель решений**дважды `Main.storyboard` щелкните файл и откройте его для редактирования.
1. Разработайте макет отдельных элементов, которые будут добавлены в представление "стек":

    [![](stacked-views-images/layout01.png "Пример макета элемента")](stacked-views-images/layout01.png#lightbox)
1. Добавьте к элементам необходимые ограничения, чтобы обеспечить их правильное масштабирование. Этот шаг важен после добавления элемента в представление стека.
1. Сделайте необходимое число копий (четыре в этом случае):

    [![](stacked-views-images/layout02.png "Необходимое число копий")](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **панели элементов** и поместите его в представление:

    [![](stacked-views-images/layout03-vs.png "Представление \"стек\"")](stacked-views-images/layout03-vs.png#lightbox)
1. Выберите представление стек, на **вкладке мини** -приложение **обозревателя свойств** выберите **заполнить** для **выравнивания**, **заполните равномерное** **распределение** и введите `25` для **интервала**:

    [![](stacked-views-images/layout04-vs.png "Вкладка мини-приложения")](stacked-views-images/layout04-vs.png#lightbox)
1. Разместите представление стека на экране там, где оно нужно, и добавьте ограничения, чтобы они оставались в нужном месте.
1. Выберите отдельные элементы и перетащите их в представление "стек":

    [![](stacked-views-images/layout05-vs.png "Отдельные элементы в представлении \"стек\"")](stacked-views-images/layout05-vs.png#lightbox)
1. Макет будет скорректирован, и элементы будут упорядочены в представлении стека на основе атрибутов, заданных выше.
1. Назначьте **имена** на **вкладке мини** -приложение **обозревателя свойств** , чтобы работать с элементами управления пользовательского интерфейса C# в коде.
1. Сохраните изменения.

-----

> [!IMPORTANT]
> Хотя можно назначать такие действия, как `TouchUpInside` элемент пользовательского интерфейса (например, `UIButton`) в конструкторе iOS при создании обработчика событий, он никогда не будет вызываться, так как Apple TV не имеет сенсорного экрана или поддерживает события касания. При создании действий для элементов пользовательского `Action Type` интерфейса tvOS всегда следует использовать значение по умолчанию.

Дополнительные сведения о работе с раскадровками см. в статье [Hello, tvOS краткое руководство по началу работы](~/ios/tvos/get-started/hello-tvos.md).

В нашем примере мы предоставили розетку и действие для элемента управления "сегмент" и розетку для каждой "карты игрока". В коде мы видим и отображаем проигрыватель на основе текущего сегмента. Например:

```csharp
partial void PlayerCountChanged (Foundation.NSObject sender) {

    // Take Action based on the segment
    switch(PlayerCount.SelectedSegment) {
    case 0:
        Player1.Hidden = false;
        Player2.Hidden = true;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 1:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 2:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = true;
        break;
    case 3:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = false;
        break;
    }
}
```

При запуске приложения четыре элемента будут равномерно распределяться в нашем представлении Stack:

[![](stacked-views-images/layout06.png "При запуске приложения четыре элемента будут равномерно распределены в представлении Stack.")](stacked-views-images/layout06.png#lightbox)

Если число игроков уменьшилось, неиспользуемые представления скрываются, а представление стека корректирует макет таким образом:

[![](stacked-views-images/layout07.png "При уменьшении числа игроков неиспользуемые представления скрываются, а представление стека настраивает макет в соответствии с")](stacked-views-images/layout07.png#lightbox)

<a name="Populate-a-Stack-View-from-Code" />

### <a name="populate-a-stack-view-from-code"></a>Заполнение представления стека из кода

Помимо определения содержимого и макета представления стека в конструкторе iOS, его можно создавать и удалять динамически из C# кода.

Возьмем следующий пример, использующий представление Stack для обработки звездочек в проверке (от 1 до 5):

```csharp
public int Rating { get; set;} = 0;
...

partial void IncreaseRating (Foundation.NSObject sender) {

    // Maximum of 5 "stars"
    if (++Rating > 5 ) {
        // Abort
        Rating = 5;
        return;
    }

    // Create new rating icon and add it to stack
    var icon = new UIImageView (new UIImage("icon.png"));
    icon.ContentMode = UIViewContentMode.ScaleAspectFit;
    RatingView.AddArrangedSubview(icon);

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });

}

partial void DecreaseRating (Foundation.NSObject sender) {

    // Minimum of zero "stars"
    if (--Rating < 0) {
        // Abort
        Rating =0;
        return;
    }

    // Get the last subview added
    var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];

    // Remove from stack and screen
    RatingView.RemoveArrangedSubview(icon);
    icon.RemoveFromSuperview();

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });
}
```

Давайте подробно рассмотрим несколько частей этого кода. Сначала мы используем `if` операторы, чтобы проверить наличие не более пяти звездочек или меньше нуля.

Чтобы добавить новую «звезду», мы загружаем его изображение и устанавливаем **режим содержимого** для **масштабирования аспекта**.

```csharp
var icon = new UIImageView (new UIImage("icon.png"));
icon.ContentMode = UIViewContentMode.ScaleAspectFit;
```

Это обеспечивает искажение значка звезды при добавлении в представление стека.

Далее мы добавим новый значок "звезда" в коллекцию вложенных представлений в представлении стека:

```csharp
RatingView.AddArrangedSubview(icon);
```

Обратите внимание, что мы добавили `UIImageView` `ArrangedSubviews` свойство `UIStackView`к свойству, а не к `SubView`. Все представления, которые должны управляться представлением стека, должны быть добавлены в `ArrangedSubviews` свойство.

Чтобы удалить Подпредставление из представления "стек", сначала мы получаем Подпредставление для удаления:

```csharp
var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];
```

Затем необходимо удалить его из `ArrangedSubviews` коллекции и Super View:

```csharp
// Remove from stack and screen
RatingView.RemoveArrangedSubview(icon);
icon.RemoveFromSuperview();
```

Удаление вложенного представления только `ArrangedSubviews` из коллекции происходит из элемента управления представления стека, но не удаляет его с экрана.

<a name="Dynamically-Changing-Content" />

## <a name="dynamically-changing-content"></a>Динамическое изменение содержимого

Представление "стек" будет автоматически настраивать макет для подпросмотров при добавлении, удалении или скрытии подпредставления. Макет также будет скорректирован, если изменяется любое свойство представления стека (например, `Axis`).

Изменения макета можно анимировать, поместив их в блок анимации, например:

```csharp
// Animate stack
UIView.Animate(0.25, ()=>{
    // Adjust stack view
    RatingView.LayoutIfNeeded();
});
```

Многие свойства представления стека можно указать с помощью классов размера в раскадровке. Эти свойства будут автоматически анимированы в ответ на изменения размера или ориентации.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье описано проектирование и работа с представлением с накоплением в приложении Xamarin. tvOS.



## <a name="related-links"></a>Связанные ссылки

- [Примеры tvOS](https://docs.microsoft.com/samples/browse/?products=xamarin&term=Xamarin.iOS+tvOS)
- [tvOS](https://developer.apple.com/tvos/)
- [Руководства по tvOSму интерфейсу](https://developer.apple.com/tvos/human-interface-guidelines/)
- [Руководством по программированию приложений для tvOS](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/)
