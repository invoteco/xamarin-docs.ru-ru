---
title: Пользовательские элементы управления в Xamarin Designer для iOS
description: Xamarin Designer для iOS поддерживает визуализацию пользовательских элементов управления, созданных в проекте, или ссылок из внешних источников, таких как хранилище компонентов Xamarin.
ms.prod: xamarin
ms.assetid: D8F07D63-B006-4050-9D1B-AC6FCDA71B99
ms.technology: xamarin-ios
author: conceptdev
ms.author: crdun
ms.date: 03/22/2017
ms.openlocfilehash: 51afbdf79248af6f76426dd0e0c862e506a0a22f
ms.sourcegitcommit: 57f815bf0024b1afe9754c0e28054fc0a53ce302
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70768772"
---
# <a name="custom-controls-in-the-xamarin-designer-for-ios"></a>Пользовательские элементы управления в Xamarin Designer для iOS

_Xamarin Designer для iOS поддерживает визуализацию пользовательских элементов управления, созданных в проекте, или ссылок из внешних источников, таких как хранилище компонентов Xamarin._

Xamarin Designer для iOS является мощным средством для визуализации пользовательского интерфейса приложения и обеспечивает поддержку редактирования в режиме WYSIWYG для большинства представлений iOS и контроллеров представлений. Приложение также может содержать пользовательские элементы управления, расширяющие встроенные в iOS. Если эти пользовательские элементы управления написаны с учетом нескольких рекомендаций, они также могут быть отображены в конструкторе iOS, предоставляя даже более широкие возможности редактирования. В этом документе рассматриваются эти рекомендации.

## <a name="requirements"></a>Требования

В области конструктора будут отображены элементы управления, соответствующие следующим требованиям.

1. Это прямой или косвенный подкласс [UIView](xref:UIKit.UIView) или [UIViewController](xref:UIKit.UIViewController). Другие подклассы [нсобжект](xref:Foundation.NSObject) будут отображаться в виде значка в области конструктора.
2. Он имеет [регистераттрибуте](xref:Foundation.RegisterAttribute) , чтобы предоставить его цели — C.
3. У него есть [обязательный конструктор IntPtr](~/ios/internals/api-design/index.md).
4. Он либо реализует интерфейс [IComponent](xref:System.ComponentModel.IComponent) , либо имеет для [десигнтимевисиблеаттрибуте](xref:System.ComponentModel.DesignTimeVisibleAttribute) значение true.

Элементы управления, определенные в коде, отвечающие приведенным выше требованиям, будут отображаться в конструкторе при компиляции содержащего их проекта для симулятора. По умолчанию все пользовательские элементы управления отображаются в разделе **пользовательские компоненты** **области элементов**. Однако [категоряттрибуте](xref:System.ComponentModel.CategoryAttribute) можно применить к классу пользовательского элемента управления, чтобы указать другой раздел.

Конструктор не поддерживает загрузку сторонних библиотек цели-C.

## <a name="custom-properties"></a>Настраиваемые свойства

Свойство, объявленное настраиваемым элементом управления, будет отображаться на панели свойств, если выполняются следующие условия.

1. Свойство имеет открытый метод получения и задания.
1. Свойство имеет [експортаттрибуте](xref:Foundation.ExportAttribute) , а [Бровсаблеаттрибуте](xref:System.ComponentModel.BrowsableAttribute) — значение true.
1. Тип свойства — числовой тип, тип перечисления, String, bool, [SizeF](xref:System.Drawing.SizeF), [уиколор](xref:UIKit.UIColor)или [уиимаже](xref:UIKit.UIImage). Этот список поддерживаемых типов может быть расширен в будущем.

Свойство также можно снабдить [дисплайнамеаттрибуте](xref:System.ComponentModel.DisplayNameAttribute) , чтобы указать метку, которая будет отображаться на панели свойств.

## <a name="initialization"></a>Инициализация

Для `UIViewController` подклассов следует использовать метод [ViewDidLoad](xref:UIKit.UIViewController.ViewDidLoad) для кода, который зависит от представлений, созданных в конструкторе.

Для `UIView` и других `NSObject` подклассов метод [авакефромниб](xref:Foundation.NSObject.AwakeFromNib) является рекомендуемым местом для инициализации пользовательского элемента управления после его загрузки из файла макета. Это обусловлено тем, что пользовательские свойства, заданные на панели свойств, не будут заданы при запуске конструктора элемента управления, но будут установлены перед `AwakeFromNib` вызовом:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        // Initialize the view here.
    }
}
```

Если элемент управления также предназначен для создания непосредственно из кода, может потребоваться создать метод, имеющий общий код инициализации, например:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
    }
}
```

## <a name="property-initialization-and-awakefromnib"></a>Инициализация и Авакефромниб свойств

Следует принять во внимание, когда и где следует инициализировать создаваемые свойства в пользовательском компоненте так, чтобы не перезаписать значения, заданные в конструкторе iOS. В качестве примера рассмотрим следующий код:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    [Export ("Counter"), Browsable (true)]
    public int Counter {get; set;}

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
        Counter = 0;
    }
}
```

`CustomView` Компонент`Counter` предоставляет свойство, которое может быть задано разработчиком в конструкторе iOS. Однако независимо от того, какое значение задано в конструкторе, значение `Counter` свойства всегда будет равно нулю (0). Далее описывается, почему это происходит:

- Экземпляр класса `CustomControl` из файла раскадровки.
- Задаются все свойства, измененные в конструкторе iOS (например, установка значения `Counter` двух (2)).
- Выполняется метод и выполняется вызов `Initialize` метода компонента. `AwakeFromNib`
- В значении `Counter` свойства сбрасывается до нуля (0). `Initialize`

Чтобы устранить описанную выше ситуацию, либо инициализируйте `Counter` свойство в любом расположении (например, в конструкторе компонента), либо не `AwakeFromNib` переопределяйте метод и вызовите `Initialize` , если компоненту не требуется дальнейшая инициализация за пределами в настоящее время обрабатывается его конструкторами.

## <a name="design-mode"></a>Режим конструктора

В области конструктора пользовательский элемент управления должен соответствовать некоторым ограничениям:

- Ресурсы пакета приложений недоступны в режиме конструктора. Изображения доступны при загрузке с помощью [методов уиимаже](xref:UIKit.UIImage) .
- Асинхронные операции, такие как веб-запросы, не должны выполняться в режиме конструктора. Область конструктора не поддерживает анимацию или другие асинхронные обновления пользовательского интерфейса элемента управления.

Пользовательский элемент управления может реализовать [IComponent](xref:System.ComponentModel.IComponent) и использовать свойство [десигнмоде](xref:System.ComponentModel.ISite.DesignMode) для проверки того, находится ли он в области конструктора. В этом примере метка будет отображать «режим конструктора» в области конструктора и «Runtime» во время выполнения:

```csharp
[Register ("DesignerAwareLabel")]
public class DesignerAwareLabel : UILabel, IComponent {

    #region IComponent implementation

    public ISite Site { get; set; }
    public event EventHandler Disposed;

    #endregion

    public DesignerAwareLabel (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        if (Site != null && Site.DesignMode)
            Text = "Design Mode";
        else
            Text = "Runtime";
    }
}
```

Прежде чем пытаться получить `Site` доступ к любому из его членов, следует всегда проверять свойство. `null` Если `Site` имеет `null`значение, то можно спокойно предположить, что элемент управления не выполняется в конструкторе.
В режиме `Site` конструктора будет установлен после вызова конструктора элемента управления и перед `AwakeFromNib` вызовом метода.

## <a name="debugging"></a>Отладка

Элемент управления, соответствующий указанным выше требованиям, будет отображаться на панели элементов и отображен на поверхности.
Если элемент управления не отображается, проверьте наличие ошибок в элементе управления или одну из его зависимостей.

Область конструктора часто может перехватывать исключения, создаваемые отдельными элементами управления, продолжая отображать другие элементы управления. Элемент управления, вызвавший сбой, заменяется красным заполнительом, и вы можете просмотреть трассировку исключений, щелкнув значок с восклицательным знаком:

 ![](ios-designable-controls-overview-images/exception-box.png "Элемент управления с ошибками как красный заполнитель и сведения об исключении")

Если для элемента управления доступны отладочные символы, то трассировка будет содержать имена файлов и номера строк.
Двойной щелчок по строке в трассировке стека приведет к переходу к этой строке в исходном коде.

Если конструктор не может изолировать неисправный элемент управления, в верхней части области конструктора появится предупреждающее сообщение:

 ![](ios-designable-controls-overview-images/info-bar.png "Предупреждающее сообщение в верхней части области конструктора")

Полная визуализация возобновится, когда неисправный элемент управления будет исправлен или удален из области конструктора.

## <a name="summary"></a>Сводка

В этой статье представлено создание и применение пользовательских элементов управления в конструкторе iOS. Сначала в нем описаны требования, которым должны соответствовать элементы управления для подготовки к просмотру в области конструктора и предоставления настраиваемых свойств на панели свойств. Затем он просматривает код программной части для инициализации элемента управления и свойства Десигнмоде. В последний раз было описано, что происходит при возникновении исключений и как устранить эту проблему.
