---
title: Общие сведения о раскадровках в Xamarin. iOS
description: В этом документе содержатся общие сведения о раскадровках в Xamarin. iOS. Здесь описывается, как раскадровка используется для определения пользовательского интерфейса, переходов и использования конструктора iOS для изменения файлов раскадровки.
ms.prod: xamarin
ms.assetid: A3339BD2-9F56-7965-25F5-4B7C991EB775
ms.technology: xamarin-ios
author: lobrien
ms.author: laobri
ms.date: 03/22/2017
ms.openlocfilehash: 86198c7a2fa0460070d012afd0b7b9d078d2a5f3
ms.sourcegitcommit: 6264fb540ca1f131328707e295e7259cb10f95fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/16/2019
ms.locfileid: "69528562"
---
# <a name="introduction-to-storyboards-in-xamarinios"></a>Общие сведения о раскадровках в Xamarin. iOS

В этом пошаговом окне мы объясним, что такое раскадровка, и рассмотрим некоторые ключевые компоненты, например переходов. Мы рассмотрим, как можно создавать и использовать раскадровки и какие преимущества они имеют для разработчика.

Прежде чем формат файла раскадровки появился в Apple как визуальное представление пользовательского интерфейса приложения iOS, разработчики создали файлы XIB для каждого контроллера представления и запустили навигацию между представлениями вручную.  Использование раскадровки позволяет разработчику определять как контроллеры представлений, так и навигацию между ними в области конструктора и обеспечивает редактирование пользовательского интерфейса приложения в режиме WYSIWYG.

Раскадровку можно создать, открыть и изменить с помощью конструктора Xamarin iOS. В этом руководстве также приводится пошаговое руководство по созданию раскадровок с помощью C# конструктора для программирования навигации.


## <a name="requirements"></a>Требования

Раскадровки можно использовать с конструктором iOS в Visual Studio для Mac или с Visual Studio 2017 с установленными рабочими нагрузками Xamarin.

## <a name="what-is-a-storyboard"></a>Что такое раскадровка?

Раскадровка — это визуальное представление всех экранов в приложении. Он содержит последовательность сцен, где каждая сцена представляет *контроллер представления* и его *представления*. Эти представления могут содержать объекты и [элементы управления](~/ios/user-interface/controls/index.md) , позволяющие пользователю взаимодействовать с приложением. Эта коллекция представлений и элементов управления (или вложенных *представлений*) называется *иерархией представления содержимого*. Сцены соединяются объектами перехода, которые представляют переход между контроллерами представления. Обычно это достигается путем создания перехода между объектом в первоначальном представлении и представлением соединения. Связи в области конструктора показаны на рисунке ниже.

 [![](images/storyboardsview.png "В этом изображении показаны связи в области конструктора.")](images/storyboardsview.png#lightbox)

Как видно, раскадровка будет размещаться в каждом из сцен с уже подготовленным содержимым и показывает соединения между ними.  На этом этапе стоит отметить, что при разговоре о сценах на iPhone можно считать, что одна *сцена* на раскадровке равна одному экрану содержимого на устройстве. Однако на iPad может отображаться несколько сцен, например с помощью контроллера представления контекстном меню Action.

Использование раскадровки дает множество преимуществ для создания пользовательского интерфейса приложения, особенно при использовании Xamarin. Во-первых, это визуальное представление пользовательского интерфейса, так как все объекты, включая [пользовательские элементы управления](~/ios/user-interface/designer/ios-designable-controls-overview.md) , подготавливаются во время разработки. Это означает, что перед сборкой или развертыванием приложения можно визуализировать его внешний вид и последовательность. Возьмем приведенный выше образ, например. В области конструктора можно узнать, сколько сцен есть, макет каждого представления и как все связано. Это делает раскадровки настолько мощными.

События более управляемы с помощью раскадровок, особенно при использовании конструктора iOS. Большинство элементов управления пользовательского интерфейса будут иметь список возможных событий в Панель свойств. Обработчик событий можно добавить сюда и выполнить в разделяемом методе класса View Controllers.

Содержимое раскадровки хранится в виде XML-файла. Во время сборки все `.storyboard` файлы компилируются в двоичные файлы, называемые нибс. Во время выполнения эти нибс инициализируются и создаются с созданием экземпляров для создания новых представлений.

## <a name="segues"></a>Переходов

Объект *перехода*или *перехода*используется в разработке iOS для представления перехода между сценами. Чтобы создать перехода, удерживайте нажатой клавишу **CTRL** и перетащите ее с одной сцены на другую. По мере перетаскивания мыши появляется синий соединитель, указывающий, где перехода будет выглядеть, как показано на рисунке ниже:

 [![](images/createsegue.png "Появится синий соединитель, указывающий, где перехода будет выглядеть, как показано на этом изображении.")](images/createsegue.png#lightbox)

При наведении указателя мыши появится меню, позволяющее выбрать действие для нашего перехода. Он может выглядеть примерно так: 

**Pre-iOS 8 и классы размера**

[![](images/segue1.png "Раскрывающийся список действия перехода без классов размера")](images/segue1.png#lightbox)

**При использовании классов размера и адаптивных сегментов**

[![](images/16new.png "Раскрывающийся список действия перехода с классами size")](images/16new.png#lightbox)

> [!IMPORTANT]
> Если вы используете VMWare для виртуальной машины Windows, при нажатии кнопки мыши по умолчанию отображается нажатие клавиши CTRL. Чтобы создать перехода, измените параметры клавиатуры с помощью **параметров** > **Клавиатура & мышь** > и переназначьте **вторичную кнопку** , как показано ниже:
> 
> [![](images/image22.png "Параметры настройки клавиатуры и мыши")](images/image22.png#lightbox)
> 
> Теперь вы можете добавить перехода между контроллерами представления как обычно.

Существуют различные типы переходов, каждый из которых обеспечивает контроль над представлением нового контроллера представления пользователю и тем, как он взаимодействует с другими контроллерами представления в раскадровке. Они описаны ниже. Также можно создать подкласс для объекта перехода, чтобы реализовать пользовательский переход:

- **Показать/отправить** — Push-перехода добавляет контроллер представления в стек навигации. Предполагается, что контроллер представления, исходящий из отправки push, является частью того же контроллера навигации, что и контроллер представления, добавляемый в стек. Это делает то же самое, `pushViewController` что и, и обычно используется при наличии некоторой связи между данными на экранах. Использование push перехода дает вам Люкс с панелью навигации с кнопкой "назад" и заголовком, добавленными в каждое представление в стеке, что позволяет детализировать навигацию по иерархии представлений.
- **Модальный** — модальный перехода создает связь между любыми двумя контроллерами представления в проекте с возможностью отображения анимированного перехода. Контроллер дочернего представления будет полностью скрывать родительский контроллер представления при просмотре. В отличие от Push перехода, которая добавляет кнопку назад для нас; При использовании модального перехода `DismissViewController` необходимо использовать для возврата к предыдущему контроллеру представления.
- **관습** - 모든 맞춤 segue는의 하위 클래스로 만들 수 있습니다 `UIStoryboardSegue`.
- **풀다** - 예를 들어 모달로 표시된보기 컨트롤러를 닫음으로써 푸시 또는 모달보기를 통해 뒤로 탐색하는 데 unwind segue를 사용할 수 있습니다. Помимо этого, вы можете очистить не только одну, но и серию push-и модальных переходов, а также выполнить несколько шагов в иерархии навигации с одним действием очистки. Чтобы понять, как использовать перехода очистки в iOS, прочитайте статью создание рецепта [очистки переходов](https://github.com/xamarin/recipes/tree/master/Recipes/ios/general/storyboard/unwind_segue) .
- Без **исходного кода** — перехода без исходного кода указывает на сцену, содержащую исходный контроллер представления, и поэтому представление, которое пользователь увидит первым. Он представлен перехода, показанным ниже.  

    [![](images/sourcelesssegue.png "Перехода с исходным кодом")](images/sourcelesssegue.png#lightbox)

### <a name="adaptive-segue-types"></a>Адаптивные типы перехода

 в iOS 8 появились [классы размера](~/ios/user-interface/storyboards/unified-storyboards.md#size-classes) , позволяющие файлу раскадровки iOS работать со всеми доступными размерами экрана, что позволяет разработчикам создавать один пользовательский интерфейс для всех устройств iOS. По умолчанию все новые приложения Xamarin. iOS будут использовать классы размера. Чтобы использовать классы размеров из более старых проектов, ознакомьтесь с руководством [Введение в унифицированные](~/ios/user-interface/storyboards/unified-storyboards.md) раскадровки. 
 
В любом приложении, использующем классы размера, также будет использоваться новое [*Адаптивное переходов*](~/ios/user-interface/storyboards/unified-storyboards.md). При использовании классов размера Помните, что мы не указываем Весер напрямую, мы используем iPhone или iPad. Другими словами, мы создаем один пользовательский интерфейс, который всегда будет выглядеть одинаково, независимо от того, насколько реально он должен работать. Адаптивное переходов работает, судя среду и определяя, как лучше представлять содержимое. Ниже приведены адаптивные переходов. 

[![](images/adaptivesegue.png "Раскрывающееся меню адаптивного переходов")](images/adaptivesegue.png#lightbox)

|Перехода|Описание|
|--- |--- |
|Показать|Это очень похоже на Push-перехода, но оно принимает содержимое экрана в учетную запись.|
|Отобразить подробности|Если приложение отображает главное и подробное представление (например, в контроллере с разделением представлений на iPad), содержимое заменит подробное представление. Если приложение отображает только основные сведения или подробности, содержимое будет заменено верхней частью стека контроллера представления.|
|Presentation|Это похоже на модальный перехода и позволяет выбирать стили представления и перехода.|
|Контекстном меню Action презентацию|Это содержимое представлено как контекстном меню Action|

### <a name="transferring-data-with-segues"></a>Передача данных с помощью переходов

Преимущества перехода не заканчиваются переходами. Они также могут использоваться для управления переносом данных между контроллерами представления. Это достигается путем переопределения `PrepareForSegue` метода для первоначального контроллера представления и обработки данных самих. При активации перехода (например, при нажатии кнопки) приложение вызывает этот метод, предоставляя возможность подготовить новый контроллер представления *перед* переходом. В коде, приведенном ниже, из примера [Phoneword](https://docs.microsoft.com/samples/xamarin/ios-samples/hello-ios) демонстрируется следующее: 


```csharp
public override void PrepareForSegue (UIStoryboardSegue segue, 
NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryController = segue.DestinationViewController 
                                  as CallHistoryController;

    if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
}
```

В этом примере `PrepareForSegue` метод будет вызываться при активации перехода пользователем. Сначала необходимо создать экземпляр контроллера представления "получение" и установить его в качестве контроллера представления назначения перехода. Это делается следующей строкой кода:

```csharp
var callHistoryController = segue.DestinationViewController as CallHistoryController;
```

Теперь метод может задавать свойства `DestinationViewController`в. В этом примере мы воспользуемся этим методом, передав список с именем `PhoneNumbers` `CallHistoryController` в объект и назначив его объекту с таким же именем:

```csharp
if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
```

После завершения перехода пользователь `CallHistoryController` увидит список с заполненным списком.

## <a name="adding-a-storyboard-to-a-non-storyboard-project"></a>Добавление раскадровки в проект, не являющийся раскадровкой

Иногда может потребоваться добавить раскадровку в ранее не раскадровую файл. Сделав это в Visual Studio для Mac можно упростить, выполнив следующие действия:

# <a name="visual-studio-for-mactabmacos"></a>[Visual Studio для Mac](#tab/macos)

1. Создайте файл раскадровки, перейдя в **файл > новый файл > iOS > Storyboard**, как показано ниже: 
    
    [![](images/new-storyboard-xs.png "Диалоговое окно «Создание файла»")](images/new-storyboard-xs.png#lightbox)

2. Добавьте имя раскадровки в раздел **Main интерфейса** файла **info. plist**, как показано ниже.
    
    [![](images/infoplist.png "Редактор info. plist")](images/infoplist.png#lightbox)
    
    Это эквивалентно созданию экземпляра исходного контроллера представления в `FinishedLaunching` методе в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве `RootViewController` свойства окна, а затем делает окно, отображаемое на экране.

3. В Переопределите метод по умолчанию `Window` со следующим кодом, чтобы реализовать свойство Window: `AppDelegate`

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

# <a name="visual-studiotabwindows"></a>[Visual Studio](#tab/windows)

1. Создайте файл раскадровки, щелкнув правой кнопкой мыши проект, чтобы **добавить > новый файл > iOS > пустую**раскадровку, как показано ниже: 
    
    [![](images/new-storyboard-vs.png "Диалоговое окно \"новый элемент\"")](images/new-storyboard-vs.png#lightbox)

2. Добавьте имя раскадровки в раздел **главного интерфейса** приложения iOS, как показано ниже.
    
    [![](images/ios-app.png "Редактор info. plist")](images/ios-app.png#lightbox)
    
    Это эквивалентно созданию экземпляра исходного контроллера представления в `FinishedLaunching` методе в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. ниже), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве `RootViewController` свойства окна, а затем делает окно, отображаемое на экране.

3. В Переопределите метод по умолчанию `Window` со следующим кодом, чтобы реализовать свойство Window: `AppDelegate`

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

-----

## <a name="creating-a-storyboard-with-the-ios-designer"></a>Создание раскадровки с помощью конструктора iOS

Раскадровку можно создать с помощью Xamarin Designer для iOS, которая легко интегрируется с Visual Studio для Mac и Visual Studio.

Чтобы приступить к работе с конструктором iOS для создания раскадровок, следуйте инструкциям в многоэкранной программе [Hello, iOS](~/ios/get-started/hello-ios-multiscreen/index.md) . В этом пошаговом руководстве рассматривается Просмотр переходов между контроллерами представления с помощью переходов и управление событиями в элементах управления.

## <a name="instantiate-storyboards-manually"></a>Создание экземпляров раскадровки вручную

Раскадровки полностью заменяют отдельные файлы XIB в проекте, однако отдельные контроллеры представлений в раскадровке можно создавать с `Storyboard.InstantiateViewController`помощью.

Иногда приложения имеют особые требования, которые не могут быть обработаны с помощью встроенных переходов раскадровки, предоставляемых конструктором. Например, если бы мы создавали приложение, которое запускает различные экраны из одной кнопки, в зависимости от текущего состояния приложения, возможно, потребуется создать экземпляры контроллеров представлений вручную и программировать сам переход.

На снимке экрана ниже показаны два контроллера представления в области конструктора без перехода между ними. В следующем разделе будет рассмотрено, как можно настроить этот переход в коде.

 [![](images/viewcontrollerspink.png "На этом снимке экрана показаны два контроллера представления в области конструктора без перехода между ними.")](images/viewcontrollerspink.png#lightbox)

1. Добавить пустую раскадровку _iPhone_ в существующий проект проекта:
    
    [![](images/add-storyboard1.png "Добавление раскадровки")](images/add-storyboard1.png#lightbox)

2. Дважды щелкните только что созданную раскадровку, чтобы открыть ее, и добавьте новый **контроллер навигации** в область конструктора. Так как контроллер навигации не является интерфейсом пользователя, по умолчанию он будет иметь корневой контроллер представления, как показано ниже:

    [![](images/uinavigationcontroller.png "Просмотр контроллеров с помощью переходов")](images/uinavigationcontroller.png#lightbox)

3. Выберите _контроллер представления_ , щелкнув черную полосу внизу. На **панели свойств**конструктора в разделе удостоверение можно указать пользовательский класс, а также уникальный идентификатор для контроллера представления. Задайте для `MainViewController`имени класса и **идентификатора** раскадровки значение.

    [![](images/identitypanelnew.png "Укажите пользовательский класс")](images/identitypanelnew.png#lightbox)

4. Позже нам нужно будет создать экземпляр наших контроллеров представления из раскадровки и использовать идентификатор раскадровки для ссылки на них в нашем коде. Установка идентификатора восстановления в соответствии с ИДЕНТИФИКАТОРом раскадровки гарантирует, что контроллер представления будет правильно создан, если необходимо восстановить состояние.

5. Сейчас у нас только один контроллер представления. Перетащите другой контроллер представления в область конструктора. На панели **свойств**в разделе удостоверение Задайте класс и идентификатор `PinkViewController`раскадровки, как показано ниже:

    [![](images/pinkvcnew.png "Панель свойств")](images/pinkvcnew.png#lightbox)
    
    Интегрированная среда разработки создаст эти пользовательские классы для контроллеров представления. Их можно просмотреть в **панель решения**, как показано на снимке экрана ниже:
    
    [![](images/solution-pad.png "Панель решения")](images/solution-pad.png#lightbox)

6. `PinkViewController`В выберите представление, щелкнув центр фрейма контроллера. В Панель свойств в разделе представление измените **фон** на пурпурный:
    
    [![](images/pinkcontroller.png "Задать цвет фона")](images/pinkcontroller.png#lightbox)

7. Наконец, перетащите кнопку из **панели элементов в область** `MainViewController`. В панель свойств присвойте ему имя `PinkButton` и заголовок готопинк, как показано ниже:

    [![](images/pinkbutton.png "Задание имени кнопки")](images/pinkbutton.png#lightbox)

Раскадровка завершена, но если развернуть проект сейчас, будет выведен пустой экран. Это связано с тем, что нам по-прежнему нужно сообщить интегрированной среде разработки использовать нашу раскадровку и настроить корневой контроллер представления, который будет служить первым представлением. Обычно это можно сделать с помощью наших параметров проекта, как показано выше. Однако в этом примере мы добавим тот же результат в коде, добавив следующий код в **AppDelegate**:

```csharp
public partial class AppDelegate : UIApplicationDelegate
    {
        UIWindow window;
        public static UIStoryboard Storyboard = UIStoryboard.FromName ("MainStoryboard", null);
        public static UIViewController initialViewController;

        public override bool FinishedLaunching (UIApplication app, NSDictionary options)
        {
            window = new UIWindow (UIScreen.MainScreen.Bounds);

            initialViewController = Storyboard.InstantiateInitialViewController () as UIViewController;

            window.RootViewController = initialViewController;
            window.MakeKeyAndVisible ();
            return true;
        }

    }
```

Это большой объем кода, но незнакомо всего несколько строк. Сначала мы регистрируем нашу раскадровку с помощью **AppDelegate** , передав имя раскадровки **файл mainstoryboard**. Далее мы говорим приложению создать экземпляр исходного контроллера представления из раскадровки, вызвав `InstantiateInitialViewController` в нашей раскадровку, и мы установили этот контроллер представления в качестве корневого контроллера представления приложения. Этот метод определяет первый экран, который видит пользователь, и создает новый экземпляр этого контроллера представления.

Обратите внимание на область решения, в которой в интегрированной среде разработки был `corresponding designer.cs` создан `MainViewcontroller.cs` класс, и при добавлении имени класса в панель свойств на шаге 4. Этот класс можно увидеть, создав специальный конструктор, включающий базовый класс:

```csharp
public MainViewController (IntPtr handle) : base (handle) 
{
}
```


При создании раскадровки с помощью конструктора интегрированная среда разработки автоматически добавляет атрибут [[Register]](xref:Foundation.RegisterAttribute) в начало `designer.cs` класса и передает строковый идентификатор, идентичный идентификатору раскадровки, указанному на предыдущем шаге. Будет выполнена привязка C# к соответствующей сцене в раскадровке.

В некоторый момент может потребоваться добавить существующий класс, который **не** был создан в конструкторе. В этом случае вы зарегистрируете этот класс как обычно:

```csharp
[Register ("MainViewController")]
public partial class MainViewController : UIViewController
{
public MainViewController (IntPtr handle) : base (handle) 
{
}

...
}
```

Дополнительные сведения о регистрации классов и методов см. в документации [регистратора типов](http://docs.xamarin.com/guides/ios/advanced_topics/registrar/) .

Последний шаг в этом классе — подключить кнопку и переход к контроллеру розового представления. Мы создадим экземпляр `PinkViewController` из раскадровки. Затем мы будем программировать Push-перехода с помощью `PushViewController`, как показано в следующем примере кода:

```csharp
public partial class MainViewController : UIViewController
{
    UIViewController pinkViewController;

    public MainViewController (IntPtr handle) : base (handle)
    {

    }

    public override void AwakeFromNib ()
    {
    // Called when loaded from xib or storyboard.

    this.Initialize ();
    }

    public void Initialize(){

    //Instantiating View Controller with Storyboard ID 'PinkViewController'
    pinkViewController = Storyboard.InstantiateViewController ("PinkViewController") as PinkViewController;
    }

    public override void ViewDidLoad ()
    {
    base.ViewDidLoad ();

    //When we push the button, we will push the pinkViewController onto our current Navigation Stack
    PinkButton.TouchUpInside += (o, e) =&gt; {
        this.NavigationController.PushViewController (pinkViewController, true);
    };
    }

}
```

При запуске приложения создается 2-экранное приложение:

![](images/finishedstoryboard.png "Экраны запуска примера приложения")

## <a name="conditional-segues"></a>Условное переходов

Часто переход с одного контроллера представления на другой зависит от определенного условия. Например, если мы представили простой экран входа, мы хотим перейти на следующий экран, только *Если* имя пользователя и пароль были проверены.

В следующем примере мы добавим поле Password (пароль) в приведенный выше пример. Пользователь сможет получить доступ к *пинквиевконтроллер* только в том случае, если он введет правильный пароль, в противном случае появится сообщение об ошибке.

Прежде чем начать, выполните шаги 1 – 8 выше. В этих шагах мы создадим нашу раскадровку, начнем с создания пользовательского интерфейса и говорим представителю приложения, какой контроллер представления следует использовать в качестве Рутвиевконтроллер.

1. Теперь создадим пользовательский интерфейс и добавим в него `MainViewController` дополнительные представления, чтобы сделать его похожим на следующем снимке экрана:

    - UITextField
        - Имя. пассвордтекстфиелд
        - Заполнителе ' Введите пароль для секрета '
    - UILabel
        - Полнотекстовым План Неправильный пароль. Вы не должны пройти! '
        - Цвет: Красный
        - Выравнивание Центр
        - Строки 2
        - Флажок "Hidden" установлен    
        
    [![](images/passwordvc.png "Центрированные линии")](images/passwordvc.png#lightbox)
    
2. Создайте перехода между кнопкой "перейти к розовый" и контроллером представления, удерживая нажатой клавишу CTRL, перетащив *пинкбуттон* в *пинквиевконтроллер*, и выбрав пункт **Push-уведомления** при помощи мыши. 

3. Щелкните перехода и присвойте ему *идентификатор* `SegueToPink`:

    [![](images/namesegue.png "Щелкните перехода и присвойте ему идентификатор Сегуетопинк")](images/namesegue.png#lightbox)  
    

4. Наконец, добавьте в `MainViewController` класс следующий метод шаулдперформсегуе:

    ```csharp
    public override bool ShouldPerformSegue (string segueIdentifier, NSObject sender)
    {
        
        if(segueIdentifier == "SegueToPink"){
            if (PasswordTextField.Text == "password") {
                PasswordTextField.ResignFirstResponder ();
                return true;
            }
            else{
                ErrorLabel.Hidden = false;
                return false;
            }
        }
        return base.ShouldPerformSegue (segueIdentifier, sender);
    }
    ```

В этом коде мы сосегуеидентифиерся с нашим `SegueToPink` перехода, поэтому мы можем протестировать условие, в данном случае допустимый пароль. Если наше условие возвращает `true`, перехода будет выполнять и будет `PinkViewController`представлять. Если `false`значение равно, новый контроллер представления не будет представлен.

Этот подход можно применить к любому перехода в этом контроллере представления, установив значение аргумента Сегуеидентифиер в метод Шаулдперформсегуе. В этом случае у нас есть только один идентификатор перехода `SegueToPink`—.

См. условное решение Storyboard. Conditional в [примере раскадровки вручную](https://docs.microsoft.com/samples/xamarin/ios-samples/manualstoryboard) для рабочего примера.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>Использование ссылок раскадровки

Ссылка на раскадровку позволяет использовать большую, сложную структуру раскадровки и разбивать ее на более мелкие раскадровки, на которые можно ссылаться из оригинала, тем самым удаляя сложность и делая полученные отдельные раскадровки проще в проектировании и обслуживании.

Кроме того, ссылка раскадровки может предоставлять привязку к другой сцене в той же раскадровке или в определенной сцене на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Ссылка на внешнюю раскадровку

Чтобы добавить ссылку на внешнюю раскадровку, выполните следующие действия.

1. В **Обозреватель решений**щелкните правой кнопкой мыши имя проекта и выберите **Добавить** > **новый файл...** Раскадровка **iOS** > .  >  Введите **имя** новой раскадровки и нажмите кнопку " **создать** ":
    
    [![](images/ref01.png "Диалоговое окно «Создание файла»")](images/ref01.png#lightbox)
    
2. Разработайте макет новых сцен раскадровки, как обычно и сохраняйте изменения: 
    
    [![](images/ref02.png "Макет новой сцены")](images/ref02.png#lightbox)
    
3. Откройте раскадровку, в которой вы будете добавлять ссылку в конструкторе iOS.

4. Перетащите **ссылку** раскадровки из **панели элементов** на область конструктора: 
    
    [![](images/ref03.png "Ссылка раскадровки")](images/ref03.png#lightbox)
    
5. На вкладке **мини** -приложение **обозревателя свойств**выберите имя раскадровки, созданной ранее: 

    [![](images/ref04.png "Вкладка мини-приложения")](images/ref04.png#lightbox)
    
6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **ссылки** раскадровки: 

    [![](images/ref05.png "Создание перехода")](images/ref05.png#lightbox) 
    
7. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![](images/ref06.png "Выбор пункта \"отобразить\" для завершения перехода")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного с помощью перехода, будет отображен первоначальный контроллер представления из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылка на конкретную сцену во внешней раскадровке

Чтобы добавить ссылку на конкретную сцену, внешняя Раскадровка (а не исходный контроллер представления) выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните внешнюю раскадровку, чтобы открыть ее для редактирования.

2. Добавьте новую сцену и разработайте ее макет, как обычно: 

    [![](images/ref07.png "Новый макет сцены")](images/ref07.png#lightbox)
    
3. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**введите **идентификатор** раскадровки для контроллера представления новой сцены: 

    [![](images/ref08.png "Введите идентификатор раскадровки для нового контроллера представления сцен")](images/ref08.png#lightbox)
    
4. Откройте раскадровку, в которой вы будете добавлять ссылку в конструкторе iOS.

5. Перетащите **ссылку** раскадровки из **панели элементов** на область конструктора: 

    [![](images/ref03.png "Ссылка раскадровки")](images/ref03.png#lightbox)
    
6. На вкладке **мини** -приложение **обозревателя свойств**выберите имя раскадровки и **идентификатор ссылки** (идентификатор раскадровки) созданной ранее сцены: 

    [![](images/ref09.png "Вкладка мини-приложения")](images/ref09.png#lightbox)
    
7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **ссылки** раскадровки: 

    [![](images/ref10.png "Создание перехода")](images/ref10.png#lightbox) 
    
8. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![](images/ref06.png "Выбор пункта \"отобразить\" для завершения перехода")](images/ref06.png#lightbox) 
    
9. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным ИДЕНТИФИКАТОРом раскадровки из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылка на конкретную сцену в той же раскадровке

Чтобы добавить ссылку на определенную сцену в ту же раскадровку, выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните раскадровку, чтобы открыть ее для редактирования.

2. Добавьте новую сцену и разработайте ее макет, как обычно: 

    [![](images/ref11.png "Новый макет сцены")](images/ref11.png#lightbox)

3. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**введите **идентификатор** раскадровки для контроллера представления новой сцены: 

    [![](images/ref12.png "Вкладка мини-приложения")](images/ref12.png#lightbox)
    
4. Перетащите **ссылку** раскадровки из **панели элементов** на область конструктора: 

   [![](images/ref03.png "Ссылка раскадровки")](images/ref03.png#lightbox)
    
5. На вкладке **мини** -приложение **ОБОЗРЕВАТЕЛЯ свойств**выберите **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее. 

    [![](images/ref13.png "Вкладка мини-приложения")](images/ref13.png#lightbox)
    
6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **ссылки** раскадровки: 

    [![](images/ref14.png "Создание перехода")](images/ref14.png#lightbox) 
    
7. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![](images/ref06.png "Выбор пункта \"отобразить\" для завершения перехода")](images/ref06.png#lightbox) 
    
8. Сохраните изменения в раскадровке.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным ИДЕНТИФИКАТОРом раскадровки в той же раскадровке, которая указана в ссылке раскадровки.

## <a name="summary"></a>Сводка

В этой статье описывается концепция раскадровок и их преимущества при разработке приложений iOS. В нем обсуждаются сцены, контроллеры представлений, представления и иерархии представлений, а также принципы связывания сцен с различными типами переходов.  Кроме того, в нем рассматривается ручное создание экземпляров контроллеров представлений из раскадровки и создание условного переходов.



## <a name="related-links"></a>Связанные ссылки

- [Ручная раскадровка (образец)](https://docs.microsoft.com/samples/xamarin/ios-samples/manualstoryboard/)
- [Введение в iOS Designer](~/ios/user-interface/designer/introduction.md)
- [Преобразование в раскадровки](https://developer.apple.com/library/ios/#releasenotes/Miscellaneous/RN-AdoptingStoryboards/)
- [Справочник по классу UIStoryboard](https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html)
