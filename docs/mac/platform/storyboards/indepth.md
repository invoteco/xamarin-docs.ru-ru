---
title: Работа с раскадровками в Xamarin. Mac
description: В этом документе описывается работа с раскадровками в Xamarin. Mac, изучение процесса загрузки из кода, жизненного цикла контроллера представления, цепочки ответчиков, переходов, контроллеров окна, распознавателей жестов и т. д.
ms.prod: xamarin
ms.assetid: DF4DF7C2-DDD7-4A32-B375-5C5446301EC5
ms.technology: xamarin-mac
author: lobrien
ms.author: laobri
ms.date: 03/14/2017
ms.openlocfilehash: 2f3bdc70928dc06719bf7cfb775bf70fae9695a4
ms.sourcegitcommit: c9651cad80c2865bc628349d30e82721c01ddb4a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2019
ms.locfileid: "70227863"
---
# <a name="working-with-storyboards-in-xamarinmac"></a>Работа с раскадровками в Xamarin. Mac

Раскадровка определяет весь пользовательский интерфейс для данного приложения, разбитый на функциональный обзор контроллеров представления. В Interface Builder Xcode каждый из этих контроллеров находится в собственной сцене.

[![Раскадровка в Interface Builder Xcode](indepth-images/intro01.png)](indepth-images/intro01.png#lightbox)

Раскадровка — это файл ресурсов (с расширениями `.storyboard`), который включается в пакет приложения Xamarin. Mac при компиляции и отгрузке. Чтобы определить начальную раскадровку для приложения, измените `Info.plist` файл и выберите **основной интерфейс** из раскрывающегося списка: 

[![Редактор info. plist](indepth-images/sb01.png)](indepth-images/sb01.png#lightbox)

<a name="Loading-from-Code" />

## <a name="loading-from-code"></a>Загрузка из кода

Иногда требуется загрузить определенную раскадровку из кода и создать контроллер представления вручную. Для выполнения этого действия можно использовать следующий код:

```csharp
// Get new window
var storyboard = NSStoryboard.FromName ("Main", null);
var controller = storyboard.InstantiateControllerWithIdentifier ("MainWindow") as NSWindowController;

// Display
controller.ShowWindow(this);
```

`FromName` Загружает файл раскадровки с заданным именем, включенным в пакет приложения. `InstantiateControllerWithIdentifier` Создает экземпляр контроллера представления с заданным удостоверением. Удостоверение задается в Interface Builder Xcode при проектировании пользовательского интерфейса:

[![Задание идентификатора раскадровки](indepth-images/sb02.png)](indepth-images/sb02.png#lightbox)

При необходимости можно использовать `InstantiateInitialController` метод для загрузки контроллера представления, которому назначен исходный контроллер, в Interface Builder:

[![Настройка начального контроллера](indepth-images/sb03.png)](indepth-images/sb03.png#lightbox)

Он помечается **точкой входа** раскадровки и стрелкой открытия завершенного выше.

<a name="View-Controllers" />

## <a name="view-controllers"></a>Контроллеры представления

Контроллеры представления определяют связи между определенным представлением информации в приложении Mac и моделью данных, предоставляющей эти сведения. Каждая сцена верхнего уровня в раскадровке представляет один контроллер представления в коде приложения Xamarin. Mac.

<a name="The-View-Controller-Lifecycle" />

### <a name="the-view-controller-lifecycle"></a>Жизненный цикл контроллера представления

В `NSViewController` класс были добавлены несколько новых методов для поддержки раскадровок в macOS. Самое важное — следующие методы используются для реагирования на жизненный цикл представления, контролируемого данным контроллером представления:

- `ViewDidLoad`— Этот метод вызывается, когда представление загружается из файла раскадровки.
- `ViewWillAppear`— Этот метод вызывается непосредственно перед отображением представления на экране.
- `ViewDidAppear`— Этот метод вызывается непосредственно после отображения представления на экране.
- `ViewWillDisappear`— Этот метод вызывается непосредственно перед удалением представления с экрана.
- `ViewDidDisappear`— Этот метод вызывается непосредственно после удаления представления с экрана.
- `UpdateViewConstraints`— Этот метод вызывается, когда ограничения, определяющие положение и размер автоматического макета представления, нуждаются в обновлении.
- `ViewWillLayout`— Этот метод вызывается непосредственно перед тем, как подпредставления этого представления будут размещены на экране.
- `ViewDidLayout`— Этот метод вызывается непосредственно после того, как подпредставления представления будут размещены на экране.

<a name="The-Responder-Chain" />

### <a name="the-responder-chain"></a>Цепочка ответчиков

Кроме того `NSViewControllers` , теперь являются частью _цепочки ответчиков_окна:

[![Цепочка ответчиков](indepth-images/vc01.png)](indepth-images/vc01.png#lightbox)

И, таким образом, они могут принимать и отвечать на такие события, как вырезание, копирование и вставка элементов меню. Этот контроллер автоматического просмотра выполняется только в приложениях, работающих на macOS Sierra (10,12) и более поздних версиях.

<a name="Containment" />

### <a name="containment"></a>Вложение

В раскадровках контроллеры представлений (например, контроллер разделенного представления и контроллер представления вкладок) теперь могут реализовать _Включение_, чтобы они могли "содержать" другие контроллеры подпредставления:

[![Пример включения контроллера представления](indepth-images/vc02.png)](indepth-images/vc02.png#lightbox)

Дочерние контроллеры представлений содержат методы и свойства для привязки их к контроллеру родительского представления и для работы с отображением и удалением представлений с экрана.

Все контроллеры представлений контейнеров, встроенные в macOS, имеют определенную структуру, о которой Apple рекомендует при создании собственных пользовательских контроллеров представлений контейнеров.

[![Макет контроллера представления](indepth-images/vc03.png)](indepth-images/vc03.png#lightbox)

Контроллер представления коллекции содержит массив элементов представления коллекций, каждый из которых содержит один или несколько контроллеров представления, содержащих собственные представления.

<a name="Segues" />

## <a name="segues"></a>Переходов

Переходов предоставляют связи между всеми сценами, определяющими пользовательский интерфейс приложения. Если вы знакомы с обработкой раскадровок в iOS, то знаете, что переходов для iOS обычно определяет переходы между полноэкранными представлениями. Это отличается от macOS, когда переходов обычно определяет "[вложение](#Containment)", где одна сцена является дочерней для родительской сцены.

В macOS большинство приложений обычно группируют свои представления вместе в одном окне с помощью элементов пользовательского интерфейса, таких как разделенные представления и вкладки. В отличие от iOS, когда представления должны быть переведены на экран и выключаться из-за ограниченного объема физической области отображения.

<a name="Presentation-Segues" />

### <a name="presentation-segues"></a>Переходов представления

Учитывая, что macOS тенденции к вложению, существуют ситуации, где используются _переходов представления_ , например модальные окна, представления листов и поповерс. macOS предоставляет следующие встроенные типы перехода:

- **Показать** — отображает целевой объект перехода как не модальное окно. Например, используйте этот тип перехода для представления другого экземпляра окна документа в приложении.
- **Modal** — представляет целевой объект перехода как модальное окно. Например, используйте этот тип перехода, чтобы показать окно настроек для приложения.
- **Лист** — представляет целевой объект перехода как лист, присоединенный к родительскому окну. Например, используйте этот тип перехода для представления листа поиска и замены.
- **Контекстном меню Action** — представляет целевой объект перехода как в окне контекстном меню Action. Например, используйте этот тип перехода для представления параметров при щелчке пользователем элемента пользовательского интерфейса.
- **Custom** — представляет целевой объект перехода с помощью пользовательского типа перехода, определенного разработчиком. Дополнительные сведения см. в разделе [Создание настраиваемых переходов](#Creating-Custom-Segues) ниже.

При использовании представления переходов можно переопределить `PrepareForSegue` метод контроллера родительского представления для представления на инициализацию и переменные и предоставить все данные представленному контроллеру представления.

<a name="Triggered-Segues" />

### <a name="triggered-segues"></a>Активированный переходов

Активированный переходов позволяет указать именованный переходов (с помощью свойства **идентификатора** в Interface Builder) и активировать их событиями, такими как пользователь, нажимая кнопку или вызывая `PerformSegue` метод в коде:

```csharp
// Display the Scene defined by the given Segue ID
PerformSegue("MyNamedSegue", this);
``` 

Идентификатор перехода определяется в Interface Builder Xcode при размещении пользовательского интерфейса приложения.

[![Ввод имени перехода](indepth-images/sg02.png)](indepth-images/sg02.png#lightbox)

В контроллере представления, который выступает в качестве источника перехода, следует переопределить `PrepareForSegue` метод и выполнить инициализацию, необходимую перед выполнением перехода и отображения указанного контроллера представления:

```csharp
public override void PrepareForSegue (NSStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    // Take action based on Segue ID
    switch (segue.Identifier) {
    case "MyNamedSegue":
        // Prepare for the segue to happen
        ...
        break;
    }
}
```

При необходимости можно переопределить `ShouldPerformSegue` метод и управлять тем, выполняется ли фактическое выполнение перехода с помощью C# кода. Для контроллеров представлений, представленных вручную, `DismissController` вызовите их метод, чтобы удалить их из отображения, когда они больше не нужны.

<a name="Creating-Custom-Segues" />

### <a name="creating-custom-segues"></a>Создание настраиваемых переходов

Возможны случаи, когда приложению требуется тип перехода, не предоставленный сборкой переходов, определенной в macOS. В этом случае можно создать пользовательский перехода, который можно назначить в Interface Builder Xcode при создании макета пользовательского интерфейса приложения.

Например, чтобы создать новый тип перехода, который заменяет текущий контроллер представления внутри окна (вместо того чтобы открывать целевую сцену в новом окне), можно использовать следующий код:

```csharp
using System;
using AppKit;
using Foundation;

namespace OnCardMac
{
    [Register("ReplaceViewSeque")]
    public class ReplaceViewSeque : NSStoryboardSegue
    {
        #region Constructors
        public ReplaceViewSeque() {

        }

        public ReplaceViewSeque (string identifier, NSObject sourceController, NSObject destinationController) : base(identifier,sourceController,destinationController) {

        }

        public ReplaceViewSeque (IntPtr handle) : base(handle) {
        }

        public ReplaceViewSeque (NSObjectFlag x) : base(x) {
        }
        #endregion

        #region Override Methods
        public override void Perform ()
        {
            // Cast the source and destination controllers
            var source = SourceController as NSViewController;
            var destination = DestinationController as NSViewController;

            // Swap the controllers
            source.View.Window.ContentViewController = destination;

            // Release memory
            source.RemoveFromParentViewController ();
        }
        #endregion

    }
        
}
```

Обратите внимание на несколько моментов:

- Мы используем `Register` атрибут, чтобы предоставить этот класс цели-C/macOS.
- Мы переопределяем `Perform` метод для фактического выполнения действия нашего пользовательского перехода.
- Мы заменяем `ContentViewController` контроллер окна на тот, который определен целевым объектом (назначением) перехода.
- Мы удаляем исходный контроллер представления для освобождения памяти с помощью `RemoveFromParentViewController` метода.

Чтобы использовать этот новый тип перехода в Interface Builder Xcode, сначала необходимо скомпилировать приложение, а затем переключиться на Xcode и добавить новый перехода между двумя кадрами. Задайте для **стиля** значение **Custom** , а для `ReplaceViewSegue` **класса перехода** — (имя нашего пользовательского класса перехода):

[![Установка класса перехода](indepth-images/sg01.png)](indepth-images/sg01.png#lightbox)

<a name="Triggered-Segues" />

## <a name="window-controllers"></a>Контроллеры окна

Windows Controllers содержит и контролирует различные типы окон, которые может создать приложение macOS. Для раскадровки они имеют следующие возможности.

1. Они должны предоставить контроллер представления содержимого. Это будет тот же контроллер представления содержимого, что и у дочернего окна.
2. Свойство будет содержать раскадровку, из которой был загружен контроллер окна, иначе `null` , если она не загружается из раскадровки. `Storyboard`
3. Можно вызвать `DismissController` метод, чтобы закрыть заданное окно и удалить его из представления.

Как и контроллеры представлений, контроллеры `PerformSegue`окон `PrepareForSegue` реализуют `ShouldPerformSegue` методы, и могут использоваться в качестве источника операции перехода.

Контроллер окна отвечает за следующие возможности приложения macOS:

- Они управляют конкретным окном.
- Они управляют заголовком окна и панелью инструментов (если она доступна).
- Они управляют контроллером представления содержимого для отображения содержимого окна.

<a name="Gesture-Recognizers" />

## <a name="gesture-recognizers"></a>Распознаватели жестов

Распознаватели жестов для macOS практически идентичны своим аналогам в iOS и позволяют разработчику легко добавлять жесты (например, нажатие кнопки мыши) к элементам пользовательского интерфейса приложения.

Однако, когда жесты в iOS определяются конструкцией приложения (например, при касании экрана двумя пальцами), большинство жестов в macOS определяются оборудованием.

С помощью распознавателей жестов можно значительно сократить объем кода, необходимого для добавления пользовательских взаимодействий в элемент пользовательского интерфейса. Так как они могут автоматически определять двойные и одинарные щелчки, щелкните и перетащите события и т. д.

Вместо переопределения `MouseDown` события в контроллере представления следует использовать распознаватель жестов для управления событием пользовательского ввода при работе с раскадровками.

В macOS доступны следующие распознаватели жестов:

- `NSClickGestureRecognizer`— Регистрация событий нажатия кнопки мыши.
- `NSPanGestureRecognizer`— Регистрирует кнопки мыши вниз, события перетаскивания и освобождения.
- `NSPressGestureRecognizer`— Регистрирует удерживание кнопки мыши в течение заданного промежутка времени.
- `NSMagnificationGestureRecognizer`— Регистрирует событие увеличения на основе трекпада оборудования.
- `NSRotationGestureRecognizer`— Регистрирует событие вращения от трекпада оборудования.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>Использование ссылок раскадровки

Ссылка на раскадровку позволяет использовать большую, сложную структуру раскадровки и разбивать ее на более мелкие раскадровки, на которые можно ссылаться из оригинала, тем самым удаляя сложность и делая полученные отдельные раскадровки проще в проектировании и обслуживании.

Кроме того, ссылка раскадровки может предоставлять привязку к другой сцене в той же раскадровке или в определенной сцене на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Ссылка на внешнюю раскадровку

Чтобы добавить ссылку на внешнюю раскадровку, выполните следующие действия.

1. В **Обозреватель решений**щелкните правой кнопкой мыши имя проекта и выберите **Добавить** > **новый файл...** Раскадровка **Mac** > .  >  Введите **имя** новой раскадровки и нажмите кнопку " **создать** ": 

    [![Добавление новой раскадровки](indepth-images/ref01.png)](indepth-images/ref01.png#lightbox)
2. В **Обозреватель решений**дважды щелкните новое имя раскадровки, чтобы открыть его для редактирования в Interface Builder Xcode.
3. Разработайте макет новых сцен раскадровки, как обычно и сохраняйте изменения: 

    [![Проектирование интерфейса](indepth-images/ref02.png)](indepth-images/ref02.png#lightbox)
4. Переключитесь на раскадровку, в которую предполагается добавить ссылку, в Interface Builder.
5. Перетащите **ссылку** раскадровки из **библиотеки объектов** на область конструктора: 

    [![Выбор ссылки раскадровки в библиотеке](indepth-images/ref03.png)](indepth-images/ref03.png#lightbox)
6. В **инспекторе атрибутов**выберите имя раскадровки, созданной ранее: 

    [![Настройка ссылки](indepth-images/ref04.png)](indepth-images/ref04.png#lightbox)
7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **ссылки** раскадровки.  В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![Установка типа перехода](indepth-images/ref06.png)](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровке.
9. Вернитесь к Visual Studio для Mac, чтобы синхронизировать изменения.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного с помощью перехода, будет отображаться начальный контроллер окна из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Ссылка на конкретную сцену во внешней раскадровке

Чтобы добавить ссылку на конкретную сцену, внешняя Раскадровка (а не исходный контроллер окна) выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните внешнюю раскадровку, чтобы открыть ее для редактирования в Interface Builder Xcode.
2. Добавьте новую сцену и разработайте ее макет, как обычно: 

    [![Проектирование макета в Xcode](indepth-images/ref07.png)](indepth-images/ref07.png#lightbox)
3. В **инспекторе удостоверений**введите идентификатор раскадровки для контроллера окна новой сцены: 

    [![Задание идентификатора раскадровки](indepth-images/ref08.png)](indepth-images/ref08.png#lightbox)
4. Откройте раскадровку, в которую вы будете добавлять ссылку, в Interface Builder.
5. Перетащите **ссылку** раскадровки из **библиотеки объектов** на область конструктора: 

    [![Выбор ссылки раскадровки из библиотеки](indepth-images/ref03.png)](indepth-images/ref03.png#lightbox)
6. В **инспекторе удостоверений**выберите имя раскадровки и **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее. 

    [![Задание идентификатора ссылки](indepth-images/ref09.png)](indepth-images/ref09.png#lightbox)
7. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **ссылки** раскадровки. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![Установка типа перехода](indepth-images/ref06.png)](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровке.
9. Вернитесь к Visual Studio для Mac, чтобы синхронизировать изменения.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным ИДЕНТИФИКАТОРом раскадровки из внешней раскадровки, указанной в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылка на конкретную сцену в той же раскадровке

Чтобы добавить ссылку на определенную сцену в ту же раскадровку, выполните следующие действия.

1. В **Обозреватель решений**дважды щелкните раскадровку, чтобы открыть ее для редактирования.
2. Добавьте новую сцену и разработайте ее макет, как обычно: 

    [![Изменение раскадровки в Xcode](indepth-images/ref11.png)](indepth-images/ref11.png#lightbox)
3. В **инспекторе удостоверений**введите идентификатор раскадровки для контроллера окна новой сцены: 

    [![Задание идентификатора раскадровки](indepth-images/ref12.png)](indepth-images/ref12.png#lightbox)
4. Перетащите **ссылку** раскадровки из **панели элементов** на область конструктора: 

    [![Выбор ссылки раскадровки из библиотеки](indepth-images/ref03.png)](indepth-images/ref03.png#lightbox)
5. В **инспекторе атрибутов**выберите **идентификатор ссылки** (идентификатор раскадровки) для сцены, созданной ранее. 

    [![Задание идентификатора ссылки](indepth-images/ref13.png)](indepth-images/ref13.png#lightbox)
6. Щелкните мини-приложение пользовательского интерфейса (например, кнопка) в существующей сцене и создайте новый перехода для только что созданной **ссылки** раскадровки. В контекстном меню выберите команду " **отобразить** ", чтобы завершить перехода: 

    [![Выбор типа перехода](indepth-images/ref06.png)](indepth-images/ref06.png#lightbox) 
7. Сохраните изменения в раскадровке.
8. Вернитесь к Visual Studio для Mac, чтобы синхронизировать изменения.

При запуске приложения и выборе элемента пользовательского интерфейса, созданного перехода из, отображается сцена с заданным ИДЕНТИФИКАТОРом раскадровки в той же раскадровке, которая указана в ссылке раскадровки.

<a name="Complex-Storyboard-Example" />

## <a name="complex-storyboard-example"></a>Пример сложной раскадровки

Сложный пример работы с раскадровками в приложении Xamarin. Mac см. в [примере приложения SourceWriter](https://docs.microsoft.com/samples/xamarin/mac-samples/sourcewriter). SourceWriter — это простой редактор исходного кода, который предоставляет поддержку для автозавершения и выделения простого синтаксиса.

Код SourceWriter полностью закомментирован, и там, где это возможно, предоставлены ссылки из основных технологий и методов на соответствующую информацию в документации по руководствам для Xamarin.Mac.

## <a name="related-links"></a>Связанные ссылки

- [Привет, Mac](~/mac/get-started/hello-mac.md)
- [Работа с Windows](~/mac/user-interface/window.md)
- [Рекомендации по работе с человеческим интерфейсом OS X](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/)
- [Введение в Windows](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/WinPanel/Introduction.html#//apple_ref/doc/uid/10000031-SW1)
