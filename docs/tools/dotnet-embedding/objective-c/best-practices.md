---
title: Рекомендации по внедрению .NET для цели-C
description: В этом документе описаны различные рекомендации по использованию внедрения .NET с целью-C. В нем обсуждается предоставление подмножества управляемого кода, предоставление API чункиер, именование и многое другое.
ms.prod: xamarin
ms.assetid: 63C7F5D2-8933-4D4A-8348-E9CBDA45C472
author: davidortinau
ms.author: daortin
ms.date: 11/14/2017
ms.openlocfilehash: 2f632e3218d817aa0162a63ea81c61ca18c52b93
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73006789"
---
# <a name="net-embedding-best-practices-for-objective-c"></a>Рекомендации по внедрению .NET для цели-C

Это черновик и может не синхронизироваться с функциями, которые в настоящее время поддерживаются средством. Мы надеемся, что этот документ будет развиваться отдельно и в конечном итоге соответствует окончательному средству, т. е. Мы предлагаем долгосрочные наилучшие подходы, а не немедленные решения.

Большая часть этого документа также относится к другим поддерживаемым языкам. Однако все приведенные примеры относятся C# к и цели-C.

## <a name="exposing-a-subset-of-the-managed-code"></a>Предоставление подмножества управляемого кода

Созданная собственная библиотека или платформа содержит код цели-C для вызова каждого из предоставляемых управляемых API. Чем больше интерфейс API вы выберете (сделать общедоступным), тем больше будет собственная библиотека _связывания_ .

Рекомендуется создать другую, более мелкую сборку, чтобы предоставить разработчикам машинного кода только необходимые API. Это фасадной также позволит вам более контролировать видимость, именование, проверку ошибок... созданного кода.

## <a name="exposing-a-chunkier-api"></a>Предоставление API чункиер

Есть плата за переход с машинного на управляемый (и обратно). Таким образом, лучше предоставлять _больших вместо_ неактивных API-интерфейсов для разработчиков машинного кода, например

**Активных**

```csharp
public class Person {
  public string FirstName { get; set; }
  public string LastName { get; set; }
}
```

```objc
// this requires 3 calls / transitions to initialize the instance
Person *p = [[Person alloc] init];
p.firstName = @"Sebastien";
p.lastName = @"Pouliot";
```

**Больших**

```csharp
public class Person {
  public Person (string firstName, string lastName) {}
}
```

```objc
// a single call / transition will perform better
Person *p = [[Person alloc] initWithFirstName:@"Sebastien" lastName:@"Pouliot"];
```

Так как число переходов меньше, производительность будет выше. Он также требует меньшего объема создаваемого кода, поэтому в этом случае также создается небольшая собственная библиотека.

## <a name="naming"></a>Именование

Такое именование является одной из двух самых сложных проблем, связанных с компьютерной обработкой, которые кэшируют ошибки недействительности и отключения. Надеюсь, внедрение .NET может быть экранировано от всех, кроме именования.

### <a name="types"></a>Типы

Цель-C не поддерживает пространства имен. Как правило, его типы начинаются с префикса 2 (для Apple) или 3 (для третьей стороны), например `UIView` для представления UIKit, которое обозначает платформу.

Для типов .NET пропуск пространства имен невозможно, так как он может привести к дублированию или путанице имен. Это делает существующие типы .NET очень длинными, например

```csharp
namespace Xamarin.Xml.Configuration {
  public class Reader {}
}
```

будет использоваться следующим образом:

```objc
id reader = [[Xamarin_Xml_Configuration_Reader alloc] init];
```

Однако вы можете повторно предоставить тип следующим образом:

```csharp
public class XAMXmlConfigReader : Xamarin.Xml.Configuration.Reader {}
```

сделав его более удобным для использования, например:

```objc
id reader = [[XAMXmlConfigReader alloc] init];
```

### <a name="methods"></a>Методы

Даже хорошие имена .NET могут быть неидеальными для API цели-C.

Соглашения об именовании в цели-C отличаются от .NET (в стиле Camel, а не в стиле Pascal, более подробно).
Ознакомьтесь с [рекомендациями по написанию кода для Cocoa](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF).

С точки зрения разработчика "цель-C" метод с префиксом `Get` подразумевает, что вы не владеете экземпляром, т. е. [правилом Get](https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).

Это правило именования не имеет соответствия в мире GC для .NET; метод .NET с префиксом `Create` будет вести себя одинаково в .NET. Однако для разработчиков цели-C это обычно означает, что вы владеете возвращаемым экземпляром, т. е. [правилом создания](https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).

## <a name="exceptions"></a>Исключения

В .NET широко распространено использование исключений для сообщения об ошибках. Однако они работают достаточно долго и не сильно идентичны в цели-C. Когда это возможно, их следует скрыть от разработчика цели-C.

Например, шаблон .NET `Try` гораздо легче будет использовать из кода цели-C:

```csharp
public int Parse (string number)
{
  return Int32.Parse (number);
}
```

поглощен

```csharp
public bool TryParse (string number, out int value)
{
  return Int32.TryParse (number, out value);
}
```

### <a name="exceptions-inside-init"></a>Исключения в `init*`

В .NET конструктор должен либо быть выполнен, либо возвращать (_надеюсь_) допустимый экземпляр или вызывать исключение.

В отличие от этого, цель-C позволяет `init*` возвращать `nil`, если экземпляр не может быть создан. Это распространенный, но не общий шаблон, используемый во многих платформах Apple. В некоторых других случаях может произойти `assert` (и завершить текущий процесс).

Генератор соответствует тому же шаблону `return nil` для созданных методов `init*`. Если создается управляемое исключение, оно будет напечатано (с помощью `NSLog`) и `nil` будет возвращено вызывающему.

## <a name="operators"></a>Операторы

Цель-C не позволяет перегружать операторы как C# есть, поэтому они преобразуются в селекторы классов.

["Понятные"](https://docs.microsoft.com/dotnet/standard/design-guidelines/operator-overloads) именованные методы создаются в качестве предпочтений перегрузкам операторов при их обнаружении и могут привести к упрощению использования API.

Классы, переопределяющие операторы `==` анд\ор `!=`, должны также переопределять стандартный метод Equals (Object).
