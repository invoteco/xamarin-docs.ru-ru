---
title: Взаимодействие между слабо связанными компонентами
description: 'В этой главе объясняется, как мобильное приложение eShopOnContainers реализует шаблон публикации и подписки, что позволяет осуществлять взаимодействие на основе сообщений между компонентами, которые неудобно связывать с ссылками на объекты и типы. '
ms.prod: xamarin
ms.assetid: 1194af33-8a91-48d2-88b5-b84d77f2ce69
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 4763e73f0eafa24cc4a2fc42a6d69b457d863b8d
ms.sourcegitcommit: 6264fb540ca1f131328707e295e7259cb10f95fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/16/2019
ms.locfileid: "69529149"
---
# <a name="communicating-between-loosely-coupled-components"></a>Взаимодействие между слабо связанными компонентами

Шаблон "публикация-подписка" — это шаблон обмена сообщениями, в котором издатели отправляют сообщение без знания о получателях, известных как подписчики. Аналогичным образом подписчики прослушивают определенные сообщения, не зная издателей.

События в .NET реализуют шаблон «публикация-подписка» и являются наиболее простым и простым подходом для уровня связи между компонентами, если слабая связь не требуется, например элемент управления и страница, в которой он содержится. Однако время существования издателя и подписчика связывается ссылками на объекты друг с другом, а тип подписчика должен иметь ссылку на тип издателя. Это может создать проблемы с управлением памятью, особенно если существуют кратковременные объекты, которые подписываются на событие статического или долговременного объекта. Если обработчик событий не удаляется, подписчик будет поддерживаться ссылкой на него на издателе, и это предотвратит или откладывает сборку мусора подписчика.

## <a name="introduction-to-messagingcenter"></a>Введение в Мессагингцентер

Класс Xamarin.Forms [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) реализует шаблон "публикация-подписка", который обеспечивает взаимодействие на основе сообщений между компонентами, которые неудобно связывать по ссылкам объектов и типов. Этот механизм позволяет издателям и подписчикам взаимодействовать без ссылки друг на друга, помогая сократить зависимости между компонентами, а также разрешать независимое разработку и тестирование компонентов.

Класс [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) предоставляет функцию многоадресной публикации и подписки. Это означает, что может существовать несколько издателей, публикующих одно сообщение, и может быть несколько подписчиков, прослушивающих одно и то же сообщение. Эта связь показана на рис. 4-1:

![](communicating-between-loosely-coupled-components-images/messagingcenter.png "Функция многоадресной публикации и подписки")

**Рис. 4-1.** Функция многоадресной публикации и подписки

Издатели отправляют сообщения с помощью метода [`MessagingCenter.Send`](xref:Xamarin.Forms.MessagingCenter.Send*), а подписчики прослушивают сообщения с помощью метода [`MessagingCenter.Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*). Кроме того, подписчики могут также отменять подписку на сообщения, если это необходимо, с помощью метода [`MessagingCenter.Unsubscribe`](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*).

На внутреннем уровне класс [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) использует слабые ссылки. Это означает, что он не будет поддерживать объекты в активном состоянии и позволит им собирать мусор. Поэтому необходимо отменять подписку на сообщения только в том случае, если классу больше не требуется получать сообщения.

Мобильное приложение eShopOnContainers использует [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) класс для обмена данными между слабо связанными компонентами. Приложение определяет три сообщения:

- Сообщение публикуется `CatalogViewModel` классом при добавлении элемента в корзину покупок. `AddProduct` В случае `BasketViewModel` возврата класс подписывается на сообщение и увеличивает количество элементов в корзине покупок в ответе. Кроме того, `BasketViewModel` класс также отменяет подписывание этого сообщения.
- Сообщение публикуется `CatalogViewModel` классом, когда пользователь применяет торговую марку или фильтр типа к элементам, отображаемым в каталоге. `Filter` В случае `CatalogView` возврата класс подписывается на сообщение и обновляет пользовательский интерфейс, чтобы отображались только те элементы, которые соответствуют условиям фильтра.
- Сообщение публикуется `MainViewModel` классом при `CheckoutViewModel` переходе к `MainViewModel` следующему успешному созданию и отправке нового заказа. `ChangeTab` В случае `MainView` возврата класс подписывается на сообщение и обновляет пользовательский интерфейс, чтобы вкладка **Мой профиль** была активной, чтобы отображались заказы пользователя.

> [!NOTE]
> [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) Хотя класс допускает обмен данными между слабо связанными классами, он не предоставляет единственно архитектурное решение для этой проблемы. Например, взаимодействие между моделью представления и представлением также может быть достигнуто подсистемой привязки и уведомлениями об изменении свойств. Кроме того, связь между двумя моделями представления также может быть достигнута путем передачи данных во время навигации.

В мобильном приложении [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) eShopOnContainers используется для обновления в пользовательском интерфейсе в ответ на действие, происходящее в другом классе. Поэтому сообщения публикуются в потоке пользовательского интерфейса, при этом подписчики получают сообщение в том же потоке.

> [!TIP]
> Выполнить упаковку в поток пользовательского интерфейса при выполнении обновлений пользовательского интерфейса. Если сообщение, отправленное из фонового потока, требуется для обновления пользовательского интерфейса, обработайте сообщение в потоке пользовательского интерфейса на подписчике, вызвав [`Device.BeginInvokeOnMainThread`](xref:Xamarin.Forms.Device.BeginInvokeOnMainThread(System.Action)) метод.

Дополнительные сведения о [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter)см. в разделе [мессагингцентер](~/xamarin-forms/app-fundamentals/messaging-center.md).

## <a name="defining-a-message"></a>Определение сообщения

[`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter)сообщения — это строки, используемые для распознавания сообщений. В следующем примере кода показаны сообщения, определенные в мобильном приложении eShopOnContainers:

```csharp
public class MessengerKeys  
{  
    // Add product to basket  
    public const string AddProduct = "AddProduct";  

    // Filter  
    public const string Filter = "Filter";  

    // Change selected Tab programmatically  
    public const string ChangeTab = "ChangeTab";  
}
```

В этом примере сообщения определяются с помощью констант. Преимущество такого подхода заключается в том, что он обеспечивает безопасность типов во время компиляции и поддержку рефакторинга.

## <a name="publishing-a-message"></a>Публикация сообщения

Издатели уведомляют подписчиков о сообщении с помощью одной из перегрузок [`MessagingCenter.Send`](xref:Xamarin.Forms.MessagingCenter.Send*). В следующем примере кода демонстрируется публикация `AddProduct` сообщения.

```csharp
MessagingCenter.Send(this, MessengerKeys.AddProduct, catalogItem);
```

В этом примере [`Send`](xref:Xamarin.Forms.MessagingCenter.Send*) метод задает три аргумента:

- Первый аргумент указывает класс отправителя. Класс Sender должен быть указан любым подписчикам, желающим получить сообщение.
- Второй аргумент указывает само сообщение.
- Третий аргумент указывает полезные данные, которые будут отправлены подписчику. В этом случае полезные данные являются `CatalogItem` экземпляром.

[`Send`](xref:Xamarin.Forms.MessagingCenter.Send*) Метод опубликует сообщение и его полезные данные с помощью метода пожара и-забыть. Поэтому сообщение отправляется, даже если отсутствуют подписчики, зарегистрированные для получения сообщения. В этом случае отправленное сообщение игнорируется.

> [!NOTE]
> [`MessagingCenter.Send`](xref:Xamarin.Forms.MessagingCenter.Send*) Метод может использовать универсальные параметры для управления доставкой сообщений. Таким образом, разные подписчики могут получать несколько сообщений с общим удостоверением, но отправлять различные типы полезных данных.

## <a name="subscribing-to-a-message"></a>Подписка на сообщение

Подписчики могут зарегистрироваться для получения сообщения с помощью одной из перегрузок [`MessagingCenter.Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*). В следующем примере кода показано, как мобильное приложение eShopOnContainers подписывается на, и обрабатывает `AddProduct` сообщение:

```csharp
MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>(  
    this, MessageKeys.AddProduct, async (sender, arg) =>  
{  
    BadgeCount++;  

    await AddCatalogItemAsync(arg);  
});
```

В этом примере [`Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*) метод подписывается `AddProduct` на сообщение и выполняет делегат обратного вызова в ответ на получение сообщения. Этот делегат обратного вызова, указанный в лямбда-выражении, выполняет код, который обновляет пользовательский интерфейс.

> [!TIP]
> Рассмотрите возможность использования неизменяемых полезных данных. Не пытайтесь изменить полезные данные из делегата обратного вызова, так как несколько потоков могут одновременно получить доступ к полученным данным. В этом сценарии полезные данные должны быть неизменными, чтобы избежать ошибок параллелизма.

Подписчику может не потребоваться обрабатывать каждый экземпляр опубликованного сообщения, и это можно контролировать с помощью аргументов универсального типа, указанных в методе [`Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*). В этом примере подписчик будет принимать `AddProduct` только сообщения, отправленные `CatalogViewModel` из класса, полезные данные `CatalogItem` которого являются экземпляром.

## <a name="unsubscribing-from-a-message"></a>Отмена подписки на сообщение

Если подписчики больше не должны получать сообщения, можно отменить подписку на них. Это достигается с одной из [`MessagingCenter.Unsubscribe`](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) перегрузок, как показано в следующем примере кода:

```csharp
MessagingCenter.Unsubscribe<CatalogViewModel, CatalogItem>(this, MessengerKeys.AddProduct);
```

В этом примере [`Unsubscribe`](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) синтаксис метода отражает аргументы типа, указанные при подписке на `AddProduct` получение сообщения.

## <a name="summary"></a>Сводка

Класс Xamarin.Forms [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) реализует шаблон "публикация-подписка", который обеспечивает взаимодействие на основе сообщений между компонентами, которые неудобно связывать по ссылкам объектов и типов. Этот механизм позволяет издателям и подписчикам взаимодействовать без ссылки друг на друга, помогая сократить зависимости между компонентами, а также разрешать независимое разработку и тестирование компонентов.


## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
