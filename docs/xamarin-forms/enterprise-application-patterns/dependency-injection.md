---
title: Внедрение зависимостей
description: В этой главе объясняется, как мобильное приложение eShopOnContainers использует внедрение зависимостей для отделения конкретных типов от кода, который зависит от этих типов.
ms.prod: xamarin
ms.assetid: a150f2d1-06f8-4aed-ab4e-7a847d69f103
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 11/04/2019
ms.openlocfilehash: 08fb22627ab6b40c94c17d94321ed0bac60beedd
ms.sourcegitcommit: eedc6032eb5328115cb0d99ca9c8de48be40b6fa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/07/2020
ms.locfileid: "78915310"
---
# <a name="dependency-injection"></a>Внедрение зависимостей

Как правило, конструктор класса вызывается при создании экземпляра объекта, а все значения, необходимые объекту, передаются в конструктор в качестве аргументов. Это пример внедрения зависимостей, который, в частности, называется *внедрением конструктора*. Зависимости, необходимые объекту, вставляются в конструктор.

Указывая зависимости как типы интерфейсов, внедрение зависимостей позволяет разделять конкретные типы от кода, зависящего от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.

Существуют также другие типы внедрения зависимостей, такие как *внедрение свойства*и *Внедрение вызова метода*, но они являются менее часто видимыми. Поэтому в этой главе основное внимание уделяется только выполнению внедрения конструктора с помощью контейнера внедрения зависимостей.

<a name="introduction_to_dependency_injection" />

## <a name="introduction-to-dependency-injection"></a>Введение в внедрение зависимостей

Внедрение зависимостей представляет собой специализированную версию шаблона инверсии управления (IoC), где отзываемая проблема — это процесс получения необходимой зависимости. При внедрении зависимостей другой класс отвечает за внедрение зависимостей в объект во время выполнения. В следующем примере кода показано, как структурирован класс `ProfileViewModel` при использовании внедрения зависимостей.

```csharp
public class ProfileViewModel : ViewModelBase  
{  
    private IOrderService _orderService;  

    public ProfileViewModel(IOrderService orderService)  
    {  
        _orderService = orderService;  
    }  
    ...  
}
```

Конструктор `ProfileViewModel` получает экземпляр `IOrderService` в качестве аргумента, который вставляется другим классом. Единственной зависимостью в классе `ProfileViewModel` является тип интерфейса. Таким образом, класс `ProfileViewModel` не имеет сведений о классе, который отвечает за создание экземпляра объекта `IOrderService`. Класс, отвечающий за создание экземпляра объекта `IOrderService`, и его вставка в класс `ProfileViewModel`, называется *контейнером внедрения зависимостей*.

Контейнеры внедрения зависимостей уменьшают взаимосвязь между объектами, предоставляя возможность создавать экземпляры классов и управлять временем существования в зависимости от конфигурации контейнера. Во время создания объектов контейнер внедряет все зависимости, необходимые объекту. Если эти зависимости еще не созданы, контейнер сначала создает и разрешает их зависимости.

> [!NOTE]
> Внедрение зависимостей также может быть реализовано вручную с помощью фабрик. Однако использование контейнера предоставляет дополнительные возможности, такие как управление жизненным циклом и регистрация через сканирование сборок.

Использование контейнера внедрения зависимостей имеет несколько преимуществ.

- Контейнер устраняет необходимость класса для определения его зависимостей и управления временем существования.
- Контейнер позволяет сопоставлять реализованные зависимости, не влияя на класс.
- Контейнер упрощает тестирование, позволяя макетирование зависимостей.
- Контейнер повышает удобство поддержки, позволяя легко добавлять новые классы в приложение.

В контексте приложения Xamarin. Forms, использующего MVVM, контейнер внедрения зависимостей обычно используется для регистрации и разрешения моделей представлений, а также для регистрации служб и их внедрения в модели представления.

Существует множество доступных контейнеров внедрения зависимостей с помощью мобильного приложения eShopOnContainers, использующего Тиниок для управления созданием экземпляров модели представления и классов служб в приложении. Тиниок был выбран после оценки ряда различных контейнеров и обладает высокой производительностью мобильных платформ по сравнению с большинством хорошо известных контейнеров. Она упрощает создание слабо связанных приложений и предоставляет все функции, которые часто обнаруживаются в контейнерах внедрения зависимостей, в том числе методы для регистрации сопоставлений типов, разрешения объектов, управления жизненным циклом объектов и вставки зависимых объектов в конструкторы объектов, которые он разрешает. Дополнительные сведения о Тиниок см. в разделе [тиниок](https://github.com/grumpydev/TinyIoC/wiki) on GitHub.com.

В Тиниок тип `TinyIoCContainer` предоставляет контейнер внедрения зависимостей. На рис. 3-1 показаны зависимости при использовании этого контейнера, который создает экземпляр объекта `IOrderService` и внедряет его в класс `ProfileViewModel`.

![](dependency-injection-images/dependencyinjection.png "Dependencies example when using dependency injection")

**Рис. 3-1.** Зависимости при использовании внедрения зависимостей

Во время выполнения контейнер должен быть уверен, какую реализацию интерфейса `IOrderService` следует создать, прежде чем он сможет создать экземпляр объекта `ProfileViewModel`. Это включает в себя следующее:

- Контейнер, который решает, как создать экземпляр объекта, реализующего интерфейс `IOrderService`. Это называется *регистрацией*.
- Контейнер, создающий экземпляр объекта, который реализует интерфейс `IOrderService`, и объект `ProfileViewModel`. Это называется *разрешением*.

В конечном итоге приложение завершит использование объекта `ProfileViewModel`, и оно станет доступным для сборки мусора. На этом этапе сборщик мусора должен удалить экземпляр `IOrderService`, если другие классы не используют один и тот же экземпляр.

> [!TIP]
> Написание кода, независимого от контейнера. Всегда пытайтесь записать код, не зависящий от контейнера, чтобы отделить приложение от конкретного используемого контейнера зависимостей.

## <a name="registration"></a>Регистрация

Прежде чем можно будет внедрить зависимости в объект, необходимо сначала зарегистрировать типы зависимостей в контейнере. Регистрация типа обычно подразумевает передачу контейнера интерфейс и конкретный тип, реализующий интерфейс.

Существует два способа регистрации типов и объектов в контейнере с помощью кода:

- Зарегистрируйте тип или сопоставление с контейнером. При необходимости контейнер будет строить экземпляр указанного типа.
- Зарегистрируйте существующий объект в контейнере как одноэлементный. При необходимости контейнер вернет ссылку на существующий объект.

> [!TIP]
> Контейнеры внедрения зависимостей не всегда подходят. Внедрение зависимостей предоставляет дополнительные сложности и требования, которые могут быть нецелесообразными или полезными для небольших приложений. Если у класса нет зависимостей или он не зависит от других типов, он может не иметь смысла размещать его в контейнере. Кроме того, если класс содержит один набор зависимостей, которые являются неотъемлемой частью типа и никогда не изменяются, может не иметь смысла размещать его в контейнере.

Регистрация типов, требующих внедрения зависимостей, должна выполняться в одном методе в приложении, и этот метод должен вызываться на раннем этапе жизненного цикла приложения, чтобы гарантировать, что приложение знает о зависимостях между его классами. В мобильном приложении eShopOnContainers это выполняется классом `ViewModelLocator`, который создает объект `TinyIoCContainer` и является единственным классом в приложении, который содержит ссылку на этот объект. В следующем примере кода показано, как мобильное приложение eShopOnContainers объявляет объект `TinyIoCContainer` в классе `ViewModelLocator`:

```csharp
private static TinyIoCContainer _container;
```

Типы регистрируются в конструкторе `ViewModelLocator`. Для этого сначала создается экземпляр `TinyIoCContainer`, который демонстрируется в следующем примере кода:

```csharp
_container = new TinyIoCContainer();
```

Затем типы регистрируются в объекте `TinyIoCContainer`, а в следующем примере кода демонстрируется наиболее распространенная форма регистрации типа:

```csharp
_container.Register<IRequestProvider, RequestProvider>();
```

Показанный здесь метод `Register` сопоставляет тип интерфейса с конкретным типом. По умолчанию каждая регистрация интерфейса настраивается как одноэлементный, чтобы каждый зависимый объект получал один и тот же общий экземпляр. Таким образом, в контейнере будет существовать только один экземпляр `RequestProvider`, который совместно используется объектами, требующими введения `IRequestProvider` с помощью конструктора.

Конкретные типы также могут быть зарегистрированы напрямую без сопоставления типа интерфейса, как показано в следующем примере кода:

```csharp
_container.Register<ProfileViewModel>();
```

По умолчанию каждая регистрация конкретного класса настраивается в виде нескольких экземпляров, чтобы каждый зависимый объект получал новый экземпляр. Поэтому при разрешении `ProfileViewModel` будет создан новый экземпляр, и контейнер будет внедрять необходимые зависимости.

<a name="resolution" />

## <a name="resolution"></a>Решение

После регистрации типа его можно разрешить или внедрить как зависимость. Если тип разрешается и контейнеру необходимо создать новый экземпляр, он внедряет все зависимости в экземпляр.

Как правило, при разрешении типа происходит одно из трех действий:

1. Если тип не был зарегистрирован, контейнер создает исключение.
1. Если тип был зарегистрирован как одноэлементный, контейнер возвращает одноэлементный экземпляр. Если этот тип вызывается в первый раз, контейнер создает его при необходимости и сохраняет ссылку на него.
1. Если тип не был зарегистрирован как singleton, контейнер возвращает новый экземпляр и не поддерживает ссылку на него.

В следующем примере кода показано, как можно разрешить тип `RequestProvider`, который был ранее зарегистрирован в Тиниок:

```csharp
var requestProvider = _container.Resolve<IRequestProvider>();
```

В этом примере Тиниок запрашивает разрешение конкретного типа для `IRequestProvider` типа вместе с любыми зависимостями. Как правило, метод `Resolve` вызывается, когда требуется экземпляр определенного типа. Сведения об управлении временем существования разрешенных объектов см. [в разделе Управление временем существования разрешенных объектов](#managing_the_lifetime_of_resolved_objects).

В следующем примере кода показано, как мобильное приложение eShopOnContainers создает экземпляры типов моделей представления и их зависимостей:

```csharp
var viewModel = _container.Resolve(viewModelType);
```

В этом примере Тиниок запрос на разрешение типа модели представления для запрошенной модели представления, и контейнер также будет разрешать все зависимости. При разрешении типа `ProfileViewModel` зависимости, которые разрешаются, являются `ISettingsService`ным объектом и объектом `IOrderService`. Поскольку регистрации интерфейса использовались при регистрации классов `SettingsService` и `OrderService`, Тиниок возвращает одноэлементные экземпляры для классов `SettingsService` и `OrderService`, а затем передает их конструктору класса `ProfileViewModel`. Дополнительные сведения о том, как конструкция eShopOnContainers Mobile App формирует модели представления и связывает их с представлениями, см. в разделе [Автоматическое создание модели представления с указателем модели представления](~/xamarin-forms/enterprise-application-patterns/mvvm.md#automatically_creating_a_view_model_with_a_view_model_locator).

> [!NOTE]
> Регистрация и разрешение типов в контейнере влечет затраты с точки зрения производительности из-за использования отражения в контейнере для создания каждого типа, особенно если зависимости перестраиваются при каждом переходе по страницам в приложении. При наличии большого числа зависимостей или глубоких зависимостей стоимость создания может значительно возрасти.

<a name="managing_the_lifetime_of_resolved_objects" />

## <a name="managing-the-lifetime-of-resolved-objects"></a>Управление временем существования разрешенных объектов

После регистрации типа с помощью регистрации конкретного класса поведением по умолчанию для Тиниок является создание нового экземпляра зарегистрированного типа каждый раз, когда тип разрешается, или когда механизм зависимости внедряет экземпляры в другие классы. В этом сценарии контейнер не хранит ссылку на разрешенный объект. Однако при регистрации типа с помощью регистрации интерфейса поведение по умолчанию для Тиниок заключается в управлении временем существования объекта в качестве одноэлементного. Таким образом, экземпляр остается в области, пока контейнер находится в области, и удаляется, когда контейнер выходит из области действия и уничтожается сборщиком мусора, или когда код явным образом удаляет контейнер.

Поведение регистрации Тиниок по умолчанию можно переопределить с помощью методов API Fluent `AsSingleton` и `AsMultiInstance`. Например, метод `AsSingleton` можно использовать с методом `Register`, чтобы контейнер создавал или возвращал одноэлементный экземпляр типа при вызове метода `Resolve`. В следующем примере кода показано, как Тиниок указывает, как создать одноэлементный экземпляр класса `LoginViewModel`:

```csharp
_container.Register<LoginViewModel>().AsSingleton();
```

При первом разрешении типа `LoginViewModel` контейнер создает новый объект `LoginViewModel` и сохраняет ссылку на него. При каждом последующих разрешениях `LoginViewModel`контейнер возвращает ссылку на объект `LoginViewModel`, который был создан ранее.

> [!NOTE]
> Типы, регистрируемые как singleton-экземпляры, удаляются при удалении контейнера.

## <a name="summary"></a>Сводка

Внедрение зависимостей позволяет разделять конкретные типы от кода, который зависит от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.

Тиниок — это упрощенный контейнер, который обладает высокой производительностью мобильных платформ по сравнению с большинством хорошо известных контейнеров. Она упрощает создание слабо связанных приложений и предоставляет все функции, которые часто обнаруживаются в контейнерах внедрения зависимостей, в том числе методы для регистрации сопоставлений типов, разрешения объектов, управления жизненным циклом объектов и вставки зависимых объектов в конструкторы объектов, которые он разрешает.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
